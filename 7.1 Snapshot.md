# 7.1 Pruning and Snapshots

## 7.1.1 Introduction
This section defines the *Pruning and snapshot* protocol.


## 7.1.2 Dependencies
The *Pruning and snapshot* protocol depends on:

+ Timestamps: Core module to enable pruning.
+ Tip Selection Algorithm: No messages can be referenced for the part of the Tangle that is being pruned.
+ UTXO: Transactions whose outputs are unspent, remain after the snapshot.
+ Branches: We require that at the point of pruning only master branch and rejected branch exist.
+ Markers: We require that the part of the Tangle being pruned is not dependent on Markers, i.e. Markers are removed or weight propagation is not applied any longer. 
+ Approval weight: We require that the approval weight is concluded at a time much before messages reach the pruning age.
+ Voting: We require that any voting is concluded much before messages reach the pruning age. 
+ Data flow: A relaxed past cone check is applied.

## 7.1.3 Pruning

### 7.1.3.1 Proof of Inclusion and Pruning

In order to keep the ledger concise, data that is sufficiently old can be removed. We call this process pruning. Thus, the IOTA 2.0 protocol for a standard node does not attempt to keep all information back until the Genesis. 
Rather the protocol effectively becomes a mechanism to prove whether a certain message was, at some point in the past, included in the ledger. This can be done e.g. through a Merkle tree proof. 

Transactions are payloads of value messages, for which a more complex pruning mechanism is used. Specifically when a transaction contains an unspent output, see [5.1. UTXO](./5.1%20UTXO.md), the transaction shall be kept when pruning the ledger. 
A transaction can be pruned if all its outputs are spent. An optimization of this process is possible by reducing the message to only keeping the information about the unspent outputs, however the implementation will be more complicated, and thus is not considered for this first iteration of the protocol.

### 7.1.3.2 Pruning dependencies

Pruning of messages is done when messages reach the age `DELTA_PRUNE`, where the age of a message is the difference between now and the message timestamp. 

We require several conditions to be fulfilled in order to allow for a smooth pruning process: 
- Timestamp precision is enforced through voting, see [4.2.3 General Timestamp rules](./4.2%20Timestamps.md/#4.2.3%20General%20Timestamp%20rules). 
- Messages cannot attach to a message whose timestamp has an age difference of more than `DELTA`, see [4.2.3.1 Age of parents](./4.2%20Timestamps.md/#4.2.3.1%20Age%20of%20parents).
- Transaction must pass a relaxed past cone check, see [2.4.4.6 Booker - Point 7](./2.4%20Data%20Flow.md/#2.4.4.6%20Booker). 
- Finalization of messages must be guaranteed to happen before the point of pruning. Thus, any message must be either confirmed accepted or confirmed rejected before the elapse of the pruning age. 
- The filtering out of messages with wrong timestamps, voting on conflicts and the accumulation of sufficient approval weight takes a time much smaller than `DELTA_PRUNE`. 
- In order to allow a smooth pruning, any message at the age `DELTA_PRUNE` must either belong to the branch `masterBranch` or to a rejected branch. This simply means that messages are either confirmed or orphaned. 

With the above conditions we can safely assume any message before the time `DELTA_PRUNE>>DELTA` can be pruned. In summary this is for the following reasons:
- Timestamps are sufficiently accurate.
- Messages can only create parent-child relationships with messages that have a timestamp that is more recent than a predefined age.
- Branches are cleaned up at the depth of pruning, i.e. all messages that have pruning age are either confirmed accepted or confirmed rejected.
- Transactions are only pruned once all of their outputs are confirmed spent. 


## 7.1.3.3 Pruning process

A UTXO output is considered *confirmed spent*, when the message containing a transaction spending it is confirmed accepted. A flag `confirmedSpent` *shall* be set to `TRUE` in the metadata of the output when this event is triggered.

Once a message reaches the age `DELTA_PRUNE` several checks are performed, if

+ the message is not a value message it can be removed. 
+ the message is a value message and is confirmed rejected, i.e. orphaned, it can be pruned. 
+ the message is a value message and is confirmed accepted (i.e. is confirmed and a member of the `masterBranch`), it is checked whether any of the outputs is not confirmed spent.
+ all outputs are confirmed spent, then the value message is pruned. 
+ any of the outputs are unspent, i.e. not confirmed spent, the message *shall* be stored, and kept until all outputs are confirmed spent.

## 7.1.3.4 Post pruning

Transactions with unspent outputs at the time of pruning remain in the database. Once all their outputs are confirmed spent, i.e. the flags `confirmedSpent` are `TRUE`, the transaction is deleted.

Those messages that survive the initial pruning process become part of a collection of messages called *pruning collection*. Once a transaction is confirmed spent it is removed from the pruning collection.

## 7.1.4 Partial snapshots

In this subsection we define partial snapshots, which create a partial view of the ledger state. This partial view can then be employed to e.g. enable syncing of a node.

In this section we describe a trusted syncing mechanism.

### 7.1.4.1 Epoch collections

The timestamp tool *Epochs*, defined in [Section 4.2.6 - Epochs](./4.2%20Timestamps.md/#4.2.6%20Epochs), enables to group Messages objectively in groups, which we call epoch collections. 

Since eventually nodes must share the same perception, nodes will reach consensus which confirmed messages are contained within a given epoch. Due to the age restriction of parents, see [4.2.3.1 Age of parents](./4.2%20Timestamps.md/#4.2.3.1%20Age%20of%20parents), no messages can be appended to an epoch once the age of the epoch is larger than `DELTA`. 
Note that for those epochs, whose age is more than `DELTA_PRUNE`, the perception on the confirmed messages in that epoch is the same for all nodes.

Since messages get pruned by timestamp, there is a point in time at which the pruning time is within a given epoch. During this time the epoch collection gets emptied of data messages and confirmed spent transactions. 
For the purpose of this section we do not require to track epochs, whose age is larger than the pruning time. 
Thus, as the pruning time moves forward the oldest available epoch collection is updated and increases incrementally. Furthermore, the oldest available epoch collection is not complete for most of the time. 

We can combine the pruning collection and one or more of the epoch collections into a partial view of the ledger state, called partial snapshot, where the newer messages are excluded.

### 7.1.4.2 Application: Syncing process

Nodes obtain new messages by recording incoming messages from their neighbors. They then attempt to solidify these messages by requesting missing parent messages.
This process, together with the pruning and epoch collections, enables a syncing process.

A node may sync in a trusted manner in the following way:
1. The node requesting from a trusted peer the pruning collection, as well as the last and the penultimate epoch collection. If `DELTA` is larger than the length of an epoch further epoch collections should be requested, in order to ensure that no missing messages reference messages past the pruning time. 
1. If the syncing process takes excessively long, it could happen that peers are pruning certain messages before the node can send solidification requests for those messages. Therefore, the node *shall* record whether an epoch has elapsed and if this is the case, request the next epoch collection from the trusted peer. This is in order to ensure that the Tangle can be loaded fully from the pruning collection up until the tips.
