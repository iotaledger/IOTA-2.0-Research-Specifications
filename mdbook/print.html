<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IOTA 2.0 Research Specifications</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="0.0 Preface.html">Preface</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Control Files</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.1 Introduction.html"><strong aria-hidden="true">1.1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.2.</strong> Table of Contents</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.3.</strong> Terminology</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.4.</strong> Index of parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.5.</strong> References</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Structure</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">2.1.</strong> Data Types</div></li><li class="chapter-item expanded "><a href="2.2 Message Layout.html"><strong aria-hidden="true">2.2.</strong> Message Layout</a></li><li class="chapter-item expanded "><a href="2.3 Standard Payloads Layout.html"><strong aria-hidden="true">2.3.</strong> Payloads Layout</a></li><li class="chapter-item expanded "><a href="2.4 Data flow.html"><strong aria-hidden="true">2.4.</strong> Data Flow</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Network Layer</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Communication Models</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Bootstrapping</div></li><li class="chapter-item expanded "><a href="3.3 Peer Discovery.html"><strong aria-hidden="true">3.3.</strong> Peer Discovery</a></li><li class="chapter-item expanded "><a href="3.4 Neighbor Selection.html"><strong aria-hidden="true">3.4.</strong> Neighbor Selection</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Manual Peering</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Communication Layer</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.1 The Tangle.html"><strong aria-hidden="true">4.1.</strong> The Tangle</a></li><li class="chapter-item expanded "><a href="4.2 Timestamps.html"><strong aria-hidden="true">4.2.</strong> Timestamps</a></li><li class="chapter-item expanded "><a href="4.3 Tip Selection Algorithm.html"><strong aria-hidden="true">4.3.</strong> Tip Selection Algorithm</a></li><li class="chapter-item expanded "><a href="4.4 Solidification.html"><strong aria-hidden="true">4.4.</strong> Solidification</a></li><li class="chapter-item expanded "><a href="4.5 Rate Control.html"><strong aria-hidden="true">4.5.</strong> Rate Control</a></li><li class="chapter-item expanded "><a href="4.6 Congestion Control.html"><strong aria-hidden="true">4.6.</strong> Congestion Control</a></li><li class="chapter-item expanded "><a href="4.7 Markers.html"><strong aria-hidden="true">4.7.</strong> Markers</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Message Creation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Value Transfer Application</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.1 UTXO.html"><strong aria-hidden="true">5.1.</strong> UTXO</a></li><li class="chapter-item expanded "><a href="5.2 Ledger State.html"><strong aria-hidden="true">5.2.</strong> Ledger State</a></li><li class="chapter-item expanded "><a href="5.3 Mana.html"><strong aria-hidden="true">5.3.</strong> Mana</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Consensus Applications</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.1 Objects of Consensus.html"><strong aria-hidden="true">6.1.</strong> Object of Consensus</a></li><li class="chapter-item expanded "><a href="6.2 Opinion Setting.html"><strong aria-hidden="true">6.2.</strong> Opinion Setting</a></li><li class="chapter-item expanded "><a href="6.3 Fast Probabilistic Consensus.html"><strong aria-hidden="true">6.3.</strong> FPC</a></li><li class="chapter-item expanded "><a href="6.4 Finalization.html"><strong aria-hidden="true">6.4.</strong> Finalization</a></li><li class="chapter-item expanded "><a href="6.5 dRNG.html"><strong aria-hidden="true">6.5.</strong> dRNG</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><div>Appendix</div></li><li class="chapter-item expanded affix "><div>Snapshots</div></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">IOTA 2.0 Research Specifications</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Written on 2 June 2021</p>
<h1 id="iota-20-research-specifications"><a class="header" href="#iota-20-research-specifications">IOTA 2.0 Research Specifications</a></h1>
<p>This document contains the research specifications of the IOTA 2.0 Protocol.  Their purpose is to carefully explain the current state of the IOTA 2.0 protocol to developers, both internal and external, who wish to build on or test Nectar, to academics who want to analyze, model and optimize the protocol and need rigorous description of each module, and to community members and anybody who just want to learn more about the protocol.</p>
<p>We hope this document is a useful guide to the IOTA 2.0 research specifications, and we hope that you dive into them to learn as much as you can about how the IOTA 2.0 DevNet works! However, before reading the specifications, we would like to explain a few points to the reader. </p>
<h2 id="what-are-research-specifications"><a class="header" href="#what-are-research-specifications">What are research specifications?</a></h2>
<p>This collection includes specifications on each key experimental component of Coordicide. However, there are two important caveats regarding these documents.</p>
<p>First, none of the parameters are finalized. Although our previous studies give certain ranges for each of these parameters, tuning each parameter to its optimum value requires a lot of testing and research. Luckily, we can conduct this research while the software is being developed since the parameters we are fine tuning are very easy to change in the code. In these specifications, each parameter is set to an educated estimate.</p>
<p>Second, several non-experimental components of the protocol are omitted from this document. For example, snapshotting (the module which manages the pruning of old messages in perma-nodes) and a description of the gossip protocol are omitted. Both of these components are well understood parts of the current Chrysalis mainnet, and thus we felt including them was not worth delaying the specifications release.   In the table of contents on the readme file, you can find the missing specifications that we will add over the summer.</p>
<p>A final point to note is that these specifications are not stable nor are they subject to a strict versioning system. Nectar is a research prototype. As such, it will be used to conduct research and refine the specifications as necessary to optimize the protocol. Over the coming months we will be collecting data and performing experiments on the IOTA 2.0 DevNet. We learned a great deal about the protocol just by building it, and the information gained from testing at this stage will further improve the protocol and future implementations. </p>
<p>Specifically, we will:</p>
<ul>
<li>Optimize parameters </li>
<li>Improve the software implementations of the protocol in conjunction with developing the Bee and Hornet nodes</li>
<li>Identify and remove any potential performance bottlenecks </li>
<li>Optimize the performance of each module</li>
<li>Simplify the protocol by eliminating any elements which are found to be unnecessary.</li>
</ul>
<p>As we make these improvements to the protocol, these specifications will change. </p>
<p>Any protocol which reaches adoption continuously evolves and improves, and the IOTA protocol will be no different. The IOTA Research Department will always strive to make new discoveries to perfect the protocol, and we will also always maintain some sort of research specifications to track the proposed changes. </p>
<h2 id="nectar-documentation-vs-research-specifications"><a class="header" href="#nectar-documentation-vs-research-specifications">Nectar Documentation vs Research Specifications</a></h2>
<p>The reader may notice the GoShimmer repository on GitHub contains its own <a href="https://goshimmer.docs.iota.org/protocol_specification.html">documentation</a> describing the protocol. How does that documentation relate to these specifications? What is the relationship between Nectar and these specifications?</p>
<p>The Nectar documentation describes how the protocol works on the IOTA 2.0 DevNet, whereas the IOTA 2.0 research specifications describe what the IOTA 2.0 protocol should look like. In theory these should be the same (and someday they will be), but currently there are some differences.</p>
<p>The Nectar documentation was developed for two purposes. First, it was to help our research engineers figure out how to code certain modules, since parts of the prototype were written before the specs. Second, the documentation helps others, both internally and externally, to navigate the code base. As a result, the Nectar documentation is not complete, only covering the core portions of the protocol. </p>
<p>Also, since Nectar is a prototype, a few shortcuts were taken in the implementation. For example, the dRNG committee is fixed, rather than rotating based on consensus mana. This simplifies the implementation while allowing us to conduct the requisite research. The research specifications tell how the committee is supposed to be selected. </p>
<h2 id="protocol-vs-implementation-specifications"><a class="header" href="#protocol-vs-implementation-specifications">Protocol vs Implementation Specifications</a></h2>
<p>A protocol is an agreement between several nodes on how to exchange and interpret data. The implementation of the protocol is the software that performs the actual operations dictated by the protocol. The protocol is unique and fixed, while the implementation varies. For example, HTTP (HyperText Transfer Protocol) dictates how your browser should communicate with internet servers. There are several browsers (Firefox, Chrome, Safari, etc.) which run this protocol. Internally, these browsers work very differently from each other, having different features and designs, but they all communicate with a server in the same way. </p>
<p>IOTA 2.0 is a standardized protocol, and thus will have special protocol specifications dictating how IOTA nodes must behave. The IOTA Foundation will create two software implementations of this protocol: Bee and Hornet, written in rust and go respectively. However, each of these implementations will have implementation specifications which describe exactly how the software works. Using the protocol specifications, anybody can (and hopefully eventually will) write their own software implementations with their own implementation specifications. </p>
<p>These research specifications are a mix of both the protocol specifications and the implementation specifications. Why is this the case? Because all of our ideas must be tested in code, we have to develop the protocol and an implementation of the protocol at the same time. Any ideas which cannot be efficiently implemented have to be rejected. Now that we have a working prototype, we can begin separating the protocol from these specifications while the engineering department works on the implementation. </p>
<div style="break-before: page; page-break-before: always;"></div><p>These specifications are for a research prototype and are a work in progress, thus they may change.  Please refer to the preface for a description of their exact status. </p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>These are the research specifications for the IOTA 2.0 protocol. To orientate the reader, we provide a brief summary of their contents along with an overview of the protocol. </p>
<p>The first chapter of these specifications contains control files to help the reader navigate these pages. The second chapter of these specifications outlines the general structure of the protocol, including the layouts of messages and their payloads and how messages are processed.</p>
<p>Chapter 3 discusses the networking layer. This layer maintains the underlying IOTA network and includes the gossip protocol, managing connections with peers, and bootstrapping while joining the network.  The networking layer largely functions independently from the rest of the protocol, allowing the other modules to abstract these components to sending and receiving messages in gossip.</p>
<p>Chapters 4, 5, and 6 include the bulk of the protocol.  Chapter 4 describes the communication layer, which manages the information transmitted through the networking layer.</p>
<p>Running on top of the communication layer, the application layer provides actual services to clients. Anybody can develop applications, and nodes can choose which applications to run. Of course, these applications can also be dependent on each other. While third-party applications are clearly out of the realm of this document, there are several core applications which must be run by all nodes.  The core applications are split into two groups: the value transfer application and the consensus applications, which are discussed in Chapters 5 and 6 respectively.</p>
<p><img src="https://i.imgur.com/qiZtuon.png" alt="" /></p>
<h2 id="the-communication-layer"><a class="header" href="#the-communication-layer">The communication layer</a></h2>
<p>The communication layer manages the information communicated through the network layer, including processing information received from the gossip, storing information, checking various validity conditions, and deciding what information to send to neighbors. </p>
<p>All the data and transactions exchanged in IOTA 2.0 protocol is contained in objects called messages. All messages are stored in a data structure called the Tangle.  Since each message contains the hash of at least two other messages, the Tangle has a DAG structure which secures all the data, making the history of each message immutable. We refer to these references as &quot;approval&quot; since a message should only reference another if it approves of its history.</p>
<p>Each message contains a timestamp, and the protocol enforces various objective and subjective rules regarding them.</p>
<p>When nodes create new messages,  they must decide which messages their new message should reference.  To do this, the node uses the tip selection algorithm to select tips, messages which are not yet referenced.  Since references denote approval, tip selection algorithm ultimately decides which transactions and data will be included into the ledger.  The node uses flags managed by the consensus applications to maintain a pool of tips with a &quot;correct&quot; history.  The tip selection algorithm just randomly selects tips from this pool.</p>
<p>To prevent the network from being overloaded, the rate control uses adaptive PoW to coarsely limit the messages created during a spam attack while keeping the network usable for honest nodes.  The congestion control module manages fine grained access, using a <a href="https://en.wikipedia.org/wiki/Deficit_round_robin">deficit round robin scheduler</a> to decide which messages are added to the ledger and gossiped.  The scheduler is designed to have the following properties:</p>
<ol>
<li>Consistency: all honest nodes will schedule the same messages</li>
<li>Fair access: the nodes' messages will be scheduled at a fair rate according to their access mana (explained below)</li>
<li>Utilisation: when there is demand, the entire throughput will be used</li>
<li>Bounded latency: network delay of all messages will be bounded</li>
<li>Security: these properties hold even in the presence of an attacker
Lastly, the congestion control module includes a rate setter for honest nodes to use which allows them to determine the proper rate they can issue messages.</li>
</ol>
<h2 id="the-value-transfer-application"><a class="header" href="#the-value-transfer-application">The Value Transfer Application</a></h2>
<p>The Value Transfer Application maintains the ledger state and a quantity called mana which is held by each node. Changes to the ledger are made through objects called transactions submitted to the Tangle via messages. Transactions are dependent on each other, and these dependencies are tracked in the UTXO DAG.  By monitoring the UTXO DAG, a node can easily detect when two transactions intend to make conflicting changes to the ledger.</p>
<p>Once conflicts are detected, they are tracked in a sophisticated data structure called the Branch DAG.  Each branch represents a valid and monotonic choice of conflicts.  These choices, and hence the branches, are naturally partially ordered by inclusion, and thus the branches have a DAG structure.  Each message and transaction is flagged with a branch, indicating the conflicts that each transaction or message depends upon. Since each message and transaction must have a valid history, these dependencies always form a branch. </p>
<p>The consensus applications choose which branches are correct, resolving the conflicts,  and which transactions are finalised,  deciding how to mutate the balances of the ledger. </p>
<p>The value transfer application also manages the mana state, which is the IOTA 2.0 Sybil protection mechanism. Every node has holds two quantities: access mana and consensus mana. Every time a transaction moves funds, a roughly equal amount of consensus mana and access mana are pledged to two nodes. Thus mana is an extension  of the ledger state.</p>
<p>The amount of mana a node has determines how it can interact with certain modules.  For example, the congestion control algorithm schedules messages according to access mana.  The consensus applications dRNG, FPC, approval weight and autopeering all use consensus mana.</p>
<h2 id="the-consensus-applications"><a class="header" href="#the-consensus-applications">The consensus applications</a></h2>
<p>The consensus applications allow the network to come to consensus on which messages have accurate timestamps and which conflicts should be accepted and which rejected. These questions are decided through the binary voting protocol Fast Probabilistic Consensus, or FPC for short.  This binary voting protocol exchanges opinions with randomly selected nodes to come to consensus on  a bit.  To prevent an attacker from maintaining a metastable state, FPC effectively breaks &quot;ties&quot; of opinions using a random number generated by the dRNG module.</p>
<p>Using the outcomes of FPC, nodes come to consensus on which branches new messages should be attached.  The approval weight essentially tracks how many nodes have issued a message in a future cone of a message, weighted by their consensus mana.   After the approval weight of a message (or a branch) becomes large enough, the branch is considered finalised.</p>
<p>Some nodes may miss certain instances of FPC voting, because they are either new or they temporarily lost connectivity. These nodes may come to the wrong conclusions using FPC voting. </p>
<p>However, such nodes will always compute the approval weight correctly. Thus, if a conflict approved by FPC conflicts with a branch finalised by approval weight, the node will always default to the approval weight.  In this way, FPC provides an initial round of consensus for nodes which are active in the network, and then the approval weight provides the final consensus.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-message-layout"><a class="header" href="#22-message-layout">2.2 Message Layout</a></h1>
<p>This section describes the <em>Message Layout</em>, its syntactical validation and additional metadata that may be stored by a node for a message.</p>
<h2 id="221-parameters"><a class="header" href="#221-parameters">2.2.1 Parameters</a></h2>
<ul>
<li><code>MAX_MESSAGE_SIZE</code> The maximum allowed message size.</li>
<li><code>MIN_STRONG_PARENTS</code> The minimum amount of strong parents a message must reference.</li>
</ul>
<h3 id="2211-parameter-default-values"><a class="header" href="#2211-parameter-default-values">2.2.1.1 Parameter Default Values</a></h3>
<p>The following values shall be set as the default for the above parameters on initiation of the node application: </p>
<ul>
<li><code>MAX_MESSAGE_SIZE</code> = 64KB</li>
<li><code>MIN_STRONG_PARENTS</code>  = 1</li>
</ul>
<h2 id="222-message-structure"><a class="header" href="#222-message-structure">2.2.2 Message Structure</a></h2>
<p>The structure of a Tangle message is defined in Table 2.2-1 below. </p>
<p><strong>Table 2.2-1: Message Structure</strong></p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The message version. The schema specified in this specification is for version <strong>1</strong> only. </td>
    </tr>
    <tr>
        <td>Parents count</td>
        <td>uint8</td>
        <td>The amount of parents preceding the current message.</td>
    </tr>
    <tr>
        <td>Parents type</td>
        <td>uint8</td>
        <td>Bitwise encoding of parent type matching the order of preceding parents starting at <code>least significant bit</code>. <code>1</code> indicates a strong parent, while <code>0</code> signals a weak parent. At least <code>MIN_STRONG_PARENTS</code> parent type must be strong.</td>
    </tr>
    <tr>
        <td colspan="1">
            Parents <code>between(1,8)</code>
        </td>
        <td colspan="2">
            <details open="true">
                <summary>Parents, ordered by hash ASC</summary>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Parent</td>
                        <td>ByteArray[32]</td>
                        <td>The Message ID of the <i>parent Message</i>.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Issuer public key (Ed25519)</td>
        <td>ByteArray[32]</td>
        <td>The public key of the node issuing the message.</td>
    </tr>
    <tr>
        <td>Issuing timestamp</td>
        <td>time</td>
        <td>A value that shall represent the issuance time of the message.</td>
    </tr>
    <tr>
        <td>Payload length</td>
        <td>uint32</td>
        <td>The length of the Payload in bytes. Since its type may be unknown to the node, it must be declared in advance. 0 length means no payload will be attached.</td>
    </tr>
    <tr>
        <td colspan="1">
            Payload
        </td>
        <td colspan="2">
            <details open="true">
                <summary>Generic Payload</summary>
                <blockquote>
                An outline of a general payload
                </blockquote>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Payload Type</td>
                        <td>uint32</td>
                        <td>
                            The type of the payload. It will instruct the node how to parse the fields that follow. Types in the range of 0-127 are "core types", that all nodes are expected to know.
                        </td>
                    </tr>
                    <tr>
                        <td>Data Fields</td>
                        <td>ANY</td>
                        <td>A sequence of fields, where the structure depends on <code>Payload Type</code>.</td>
                    </tr>
                </table>
            </details>
            </td>
    </tr>
    <tr>
        <td>Nonce</td>
        <td>uint64</td>
        <td>The nonce which lets this message fulfill the Rate Control requirement.</td>
    </tr>
    <tr>
        <td>Signature (Ed25519)</td>
        <td>ByteArray[64]</td>
        <td>Signature of the issuing node's private key signing the BLAKE2b-256 hash of the entire message bytes.</td>
    </tr>
</table>
<h2 id="223-message-id"><a class="header" href="#223-message-id">2.2.3 Message ID</a></h2>
<p>BLAKE2b-256 hash of the byte contents of the message. It shall be used by the nodes to index the messages and by external APIs.</p>
<h2 id="224-syntactical-validation"><a class="header" href="#224-syntactical-validation">2.2.4 Syntactical Validation</a></h2>
<p>Messages that do not pass the Syntactical Validation <em>shall be</em> discarded. Only syntactically valid messages continue in the data flow, i.e., shall be allowed to pass to the Semantic Validation step.</p>
<p>A message is syntactically valid if:</p>
<ol>
<li>The message length does not exceed <code>MAX_MESSAGE_SIZE</code> bytes.</li>
<li>When the message parsing is complete, there are not any trailing bytes left that were not parsed.</li>
<li>At least 1 and at most 8 distinct parents are given, ordered ASC and at least <code>MIN_STRONG_PARENTS</code> are strong parents. </li>
</ol>
<h2 id="225-semantic-validation"><a class="header" href="#225-semantic-validation">2.2.5 Semantic Validation</a></h2>
<p>Messages that do not pass the Semantic Validation <em>shall be</em> discarded. Only semantically valid messages shall be allowed to continue in the data flow.</p>
<p>A message is semantically valid if:</p>
<ol>
<li>The Message PoW Hash contains at least the number of leading 0 defined as required by the Rate Control module (see <a href="./4.5%20Rate%20Control.html">Section 4.5 - Rate Control</a>.</li>
<li>The signature of the issuing node is valid.</li>
<li>It passes the parents age checks (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>).</li>
</ol>
<h2 id="226-metadata"><a class="header" href="#226-metadata">2.2.6 Metadata</a></h2>
<p>In addition to a message itself, a node may store additional data that describes its local perception of a message which is not part of the Tangle ('Message metadata'). Where such metadata is defined, the metadata element names and types defined in Table 2.2-2 below shall be used. </p>
<p><strong>Table 2.2-2: Message Metadata</strong></p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>receivedTime</td>
        <td>time</td>
        <td>The local time the message was received by the node.</td>
    </tr>
    <tr>
        <td>solid</td>
        <td>bool</td>
        <td>Denotes whether a message is solid, i.e., its past cone is known.</td>
    </tr>
    <tr>
        <td>solidificationTime</td>
        <td>time</td>
        <td>The local time the message got solid.</td>
    </tr>
    <tr>
        <td>branchID</td>
        <td>ByteArray[32]</td>
        <td>The branch ID of the message, i.e., the part of the Tangle where the message is located.</td>
    </tr>
    <tr>
        <td>scheduled</td>
        <td>bool</td>
        <td>Denotes whether a message was scheduled by the scheduler.</td>
    </tr>
    <tr>
        <td>booked</td>
        <td>bool</td>
        <td>Denotes whether a message was booked and therefore is part of the local Tangle.</td>
    </tr>
    <tr>
        <td>eligible</td>
        <td>bool</td>
        <td>Denotes whether a message is eligible, i.e., it's timestamp is good.</td>
    </tr>
    <tr>
        <td>invalid</td>
        <td>bool</td>
        <td>Denotes whether a message has been deemed invalid, i.e., it or its parents do not pass all checks from filters to message booker.</td>
    </tr>
    <tr>
        <td>opinion</td>
        <td>Opinion</td>
        <td>Contains the node's opinion on the issuing timestamp of a message. </td>
    </tr>
</table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-standard-payloads-layout"><a class="header" href="#23-standard-payloads-layout">2.3 Standard Payloads Layout</a></h1>
<p>Payloads may contain arbitrary data up to <code>MAX_PAYLOAD_SIZE</code>, which allows building additional protocols on top of the base protocol in the same way as TCP/IP allows to define additional protocols on top of its generic data segment.</p>
<p>Payloads may recursively contain other payloads, that enables the creation of higher-level protocols based on the same concepts of layers, as in traditional software and network architecture.</p>
<p>Payloads other than transactions are, by definition, always liked with a level of knowledge 3.</p>
<h2 id="231-dependencies"><a class="header" href="#231-dependencies">2.3.1 Dependencies</a></h2>
<p>The Standard payload Layout specification depends on the following specification:</p>
<ul>
<li><a href="./2.2%20Message%20Layout.html">2.2 - Message Layout</a></li>
</ul>
<h2 id="232-payload-definition-guideline"><a class="header" href="#232-payload-definition-guideline">2.3.2 Payload definition guideline</a></h2>
<p>Each payload shall be described by the <code>uint32</code> <strong>payload type</strong> field. To separate user-defined payloads from essential core payloads and allow future extension of the protocol, the first four places (types 0-255) are reserved for core payload definitions, and all user-defined payloads that do not restrict this rule shall be discarded.</p>
<p>Additionally, all payloads shall start with the following fields, in the presented order (Table 2.3.1).</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Size</td>
        <td>uint32</td>
        <td>The size of the payload.</td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>The type of the payload.</td>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The version of the payload.</td>
    </tr>
</table>
<p><em>Table 2.3.1 Required fields of a payload.</em></p>
<h2 id="233-parameters"><a class="header" href="#233-parameters">2.3.3 Parameters</a></h2>
<p>The Table 2.3.2 presents the parameter list that each node must know.
| Name | Description | Value |
| -----| ------ | ----------- |
|<code>MAX_PAYLOAD_SIZE</code> | The maximum allowed payload size in bytes. Determined by the difference between <code>MAX_MESSAGE_SIZE</code> (defined in <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message Layout</a>) and the total size of the remaining message fields. | 65157 |</p>
<p><em>Table 2.3.2 Standard Payload Layout parameters.</em></p>
<h2 id="234-user-defined-payloads"><a class="header" href="#234-user-defined-payloads">2.3.4 User-defined payloads</a></h2>
<p>A node may choose to interpret user-defined payloads by listening to its specific <strong>payload type</strong> (possibly via third-party code/software). If a node does not know a certain <strong>payload type</strong>, it simply treats it as arbitrary data.</p>
<h2 id="235-core-payloads"><a class="header" href="#235-core-payloads">2.3.5 Core payloads</a></h2>
<p>The core protocol defines several payloads that every node needs to interpret and process in order to participate in the network.
All core payloads, along with their types, are listed in the Table 2.3.3.</p>
<table>
    <tr>
        <th>Payload Name</th>
        <th>Payload Type</th>
    </tr>
    <tr>
        <td>Pure data</td>
        <td>value 1</td>
    </tr>
    <tr>
        <td>Transaction</td>
        <td>value 0</td>
    </tr>
    <tr>
        <td>FPC statement</td>
        <td>value 2</td>
    </tr>
    <tr>
        <td>dRNG Application Message</td>
        <td>value 3</td>
    </tr>
    <tr>
        <td>dRNG DKG</td>
        <td>value 4</td>
    </tr>
    <tr>
        <td>dRNG Beacon</td>
        <td>value 5</td>
    </tr>
    <tr>
        <td>dRNG Collective Beacon</td>
        <td>value 6</td>
    </tr>
    <tr>
        <td>Salt Declaration</td>
        <td>value 7</td>
    </tr>
    <tr>
        <td>Indexation</td>
        <td>value 8</td>
    </tr>
</table>
<p><em>Table 2.3.3 List of all core payloads with its corresponding types.</em></p>
<h3 id="2351-pure-data-payload"><a class="header" href="#2351-pure-data-payload">2.3.5.1 Pure data payload</a></h3>
<p>Pure data payloads allow to send unsigned messages (Table 2.3.4). </p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Size</td>
        <td>uint32</td>
        <td>The size of the payload.</td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>
        Set to <strong>value 1</strong> to denote a <i>Data Payload</i>.
        </td>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The version of the payload.</td>
    </tr>
    <tr>
        <td>Data</td>
        <td>ByteArray</td>
        <td>The raw data payload.</td>
    </tr>
</table>
<p><em>Table 2.3.4 Pure data payload.</em></p>
<h3 id="2352-transaction-payload"><a class="header" href="#2352-transaction-payload">2.3.5.2 Transaction payload</a></h3>
<p>The ledger state is changed through transactions payloads or value transfers. More details on transactions could be found in <a href="./5.1%20UTXO.html">Section 5.1 - UTXO</a> specification.
The detailed description of transaction payload's serialized form is presented in Table 2.3.5.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Size</td>
        <td>uint32</td>
        <td>The size of the payload.</td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>
        Set to <strong>value 0</strong> to denote a <i>Transaction Payload</i>.
        </td>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The version of the payload.</td>
    </tr>
    <tr>
        <td valign="top">Essence <code>oneOf</code></td>
        <td colspan="2">
            <details open="true">
                <summary>Transaction Essence</summary>
                <blockquote>
                Describes the essence data making up a transaction.
                </blockquote>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>Version</td>
                        <td>uint8</td>
                        <td>
                        The version number of the <i>Transaction Essence</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Timestamp</td>
                        <td>time</td>
                        <td>
                        The timestamp of the <i>Transaction</i> creation.
                        </td>
                    </tr>
                    <tr>
                        <td>Access Mana Pledge nodeID</td>
                        <td>ByteArray[32]</td>
                        <td>
                        The nodeID to which access mana of the <i>Transaction</i> is pledged.
                        </td>
                    </tr>
                    <tr>
                        <td>Consensus Mana Pledge nodeID</td>
                        <td>ByteArray32]</td>
                        <td>
                        The nodeID to which consensus mana of the <i>Transaction</i> is pledged.
                        </td>
                    </tr>
                    <tr>
                        <td>Inputs Count</td>
                        <td>uint16</td>
                        <td>The amount of inputs proceeding.</td>
                    </tr>
                    <tr>
                        <td valign="top">Inputs <code>anyOf</code></td>
                        <td colspan="2">
                            <details>
                                <summary>UTXO Input</summary>
                                <blockquote>
                                Describes an input which references an unspent transaction output to consume.
                                </blockquote>
                                <table>
                                    <tr>
                                        <td><b>Name</b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Input Type</td>
                                        <td>uint8</td>
                                        <td>
                                            Set to <strong>value 0</strong> to denote an <i>UTXO Input</i>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>Transaction ID</td>
                                        <td>ByteArray[32]</td>
                                        <td>The BLAKE2b-256 hash of the transaction from which the UTXO comes from.</td>
                                    </tr>
                                    <tr>
                                        <td>Transaction Output Index</td>
                                        <td>uint16</td>
                                        <td>The index of the output on the referenced transaction to consume.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                   <tr>
                        <td>Outputs Count</td>
                        <td>uint16</td>
                        <td>The amount of outputs proceeding.</td>
                    </tr>
                   <tr>
                        <td valign="top">Outputs <code>anyOf</code></td>
                        <td colspan="2">
                            <details>
                                <summary>SigLockedSingleOutput</summary>
                                <blockquote>
                                Describes a deposit to a single address which is unlocked via a signature.
                                </blockquote>
                                <table>
                                    <tr>
                                        <td><b>Name</b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Output Type</td>
                                        <td>uint8</td>
                                        <td>
                                            Set to <strong>value 0</strong> to denote a <i>SigLockedSingleOutput</i>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td valign="top">Address <code>oneOf</code></td>
                                        <td colspan="2">
                                            <details>
                                                <summary>Ed25519 Address</summary>
                                                <table>
                                                    <tr>
                                                        <td><b>Name</b></td>
                                                        <td><b>Type</b></td>
                                                        <td><b>Description</b></td>
                                                    </tr>
                                                    <tr>
                                                        <td>Address Type</td>
                                                        <td>uint8</td>
                                                        <td>
                                                            Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Address</td>
                                                        <td>ByteArray[32]</td>
                                                        <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                                                    </tr>
                                                </table>
                                            </details>
                                            <details>
                                                <summary>BLS Address</summary>
                                                <table>
                                                    <tr>
                                                        <td><b>Name</b></td>
                                                        <td><b>Type</b></td>
                                                        <td><b>Description</b></td>
                                                    </tr>
                                                    <tr>
                                                        <td>Address Type</td>
                                                        <td>uint8</td>
                                                        <td>
                                                            Set to <strong>value 1</strong> to denote a <i>BLS Address</i>.
                                                        </td>
                                                    </tr>
                                                    <tr>
                                                        <td>Address</td>
                                                        <td>ByteArray[49]</td>
                                                        <td>The raw bytes of the BLS address which is a BLAKE2b-256 hash of the BLS public key.</td>
                                                    </tr>
                                                </table>
                                            </details>
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>Amount</td>
                                        <td>uint64</td>
                                        <td>The amount of tokens to deposit with this <i>SigLockedSingleOutput</i> output.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                    <tr>
                        <td>Payload Length</td>
                        <td>uint32</td>
                        <td>The length in bytes of the optional payload.</td>
                    </tr>
                   <tr>
                        <td valign="top">Payload <code>optOneOf</code></td>
                        <td colspan="2">
                            <details>
                                <summary>Indexation Payload</summary>
                            </details>
                        </td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Unlock Blocks Count</td>
        <td>uint16</td>
        <td>The count of unlock blocks proceeding. Must match count of specified inputs.</td>
    </tr>
    <tr>
        <td valign="top">Unlock Blocks <code>anyOf</code></td>
        <td colspan="2">
            <details open="true">
                <summary>Signature Unlock Block</summary>
                <blockquote>
                Defines an unlock block containing signature(s) unlocking input(s).
                </blockquote>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Unlock Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 0</strong> to denote a <i>Signature Unlock Block</i>.
                        </td>
                    </tr>
                    <tr>
                        <td valign="top">Signature <code>oneOf</code></td>
                        <td colspan="2">
                             <details>
                                <summary>Ed25519 Signature</summary>
                                <table>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td>Signature Type</td>
                                        <td>uint8</td>
                                        <td>
                                            Set to <strong>value 1</strong> to denote an <i>Ed25519 Signature</i>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>Public key</td>
                                        <td>ByteArray[32]</td>
                                        <td>The public key of the Ed25519 keypair which is used to verify the signature.</td>
                                    </tr>
                                    <tr>
                                        <td>Signature</td>
                                        <td>ByteArray[64]</td>
                                        <td>The signature signing the serialized <i>Transaction Essence</i>.</td>
                                    </tr>
                                </table>
                            </details>
                            <details>
                                <summary>BLS Signature</summary>
                                <table>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td>Signature Type</td>
                                        <td>uint8</td>
                                        <td>
                                            Set to <strong>value 1</strong> to denote a <i>BLS Signature</i>.
                                        </td>
                                    </tr>
                                    <tr>
                                        <td>Signature</td>
                                        <td>ByteArray</td>
                                        <td>The signature signing the serialized <i>Transaction Essence</i>.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                </table>
            </details>
            <details open="true">
                <summary>Reference Unlock Block</summary>
                <blockquote>
                References a previous unlock block in order to substitute the duplication of the same unlock block data for inputs which unlock through the same data.
                </blockquote>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Unlock Type</td>
                        <td>uint8</td>
                        <td>
                            Set to <strong>value 1</strong> to denote a <i>Reference Unlock Block</i>.
                        </td>
                    </tr>
                    <tr>
                        <td>Reference</td>
                        <td>uint16</td>
                        <td>Represents the index of a previous unlock block.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p><em>Table 2.3.5 Transaction payload.</em></p>
<h3 id="2353-fpc-statement"><a class="header" href="#2353-fpc-statement">2.3.5.3 FPC statement</a></h3>
<p>Opinions on conflicts of transactions and timestamps of the messages, mainly issued by high mana nodes. Details regarding FPC see <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Section 6.3 - Fast Probabilistic Consensus</a> specification.</p>
<p>The Table 2.3.6 describes the entirety of a <i>FPC statement</i>'s serialized form.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Size</td>
        <td>uint32</td>
        <td>The size of the FPC statement payload.</td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>
        Set to <strong>2</strong> to denote a <i>FPC statement Payload</i>.
        </td>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The version of the FPC statement payload.</td>
    </tr>
    <tr>
        <td>Conflicts Count</td>
        <td>uint32</td>
        <td>The number of conflicts proceeding.</td>
    </tr>
    <tr>
        <td valign="top">Conflicts <code>optOneOf</code></td>
        <td colspan="2">
            <details open="true">
                <summary>Conflict</summary>
                <blockquote>
                    Describes a voting details in a given round for a transaction conflict.
                </blockquote>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>TransactionID</td>
                        <td>ByteArray[32]</td>
                        <td>The ID of the conflicting transaction.</td>
                    </tr>
                    <tr>
                        <td valign="top">Opinion</td>
                        <td colspan="2">
                            <details open="true">
                                <summary>Represents the node's opinion value over the conflict in a given round.</summary>
                                <table>
                                    <tr>
                                        <td><b>Name</b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Value</td>
                                        <td>uint8</td>
                                        <td>The node's opinion value in a given round.</td>
                                    </tr>
                                    <tr>
                                        <td>Round</td>
                                        <td>uint8</td>
                                        <td>The round number.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Timestamps Count</td>
        <td>uint32</td>
        <td>The number of timestamp voting proceeding.</td>
    </tr>
    <tr>
        <td valign="top">Timestamps <code>optOneOf</code></td>
        <td colspan="2">
            <details open="true">
                <summary>Timestamp</summary>
                <blockquote>
                    Describes the voting details over the timestamp for a given message and round.
                </blockquote>
                <table>
                    <tr>
                        <td><b>Name</b></td>
                        <td><b>Type</b></td>
                        <td><b>Description</b></td>
                    </tr>
                    <tr>
                        <td>MessageID</td>
                        <td>ByteArray[32]</td>
                        <td>The ID of the message that contains the timestamp.</td>
                    </tr>
                    <tr>
                        <td valign="top">Opinion</td>
                        <td colspan="2">
                            <details open="true">
                                <summary>Represents the node's opinion value over the conflict in a given round.</summary>
                                <table>
                                    <tr>
                                        <td><b>Name</b></td>
                                        <td><b>Type</b></td>
                                        <td><b>Description</b></td>
                                    </tr>
                                    <tr>
                                        <td>Value</td>
                                        <td>uint8</td>
                                        <td>The node's opinion value in a given round.</td>
                                    </tr>
                                    <tr>
                                        <td>Round</td>
                                        <td>uint8</td>
                                        <td>The round number.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p><em>Table 2.3.6 FPC statement</em></p>
<h3 id="2354-drng-beacon-payloads"><a class="header" href="#2354-drng-beacon-payloads">2.3.5.4 dRNG beacon payloads</a></h3>
<p>Messages that contain randomness (issued by the dRNG committee nodes). A single <code>Beacon</code> message is not sufficient to reveal the random number. Instead, <code>sigThreshold</code> or more <code>Beacon</code> messages are needed for the random number to be revealed. To recover the random number from the individual <code>Beacon</code> messages, all nodes in the network would need to perform Lagrange interpolation. To avoid that, the committee nodes produce a <code>CollectiveBeacon</code>, which contains a pre-computed random number (meaning that the committee nodes perform the Lagrange interpolation on their own). More information in <a href="./6.6%20dRNG.html">Section 6.5 - Distributed Random Number Generator</a>.
The Table 2.3.7 describes the dRNG <code>Beacon</code> and <code>CollectiveBeacon</code> payload's serialized form.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
    <tr>
        <td>Size</td>
        <td>uint32</td>
        <td>The size of the payload.</td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>Set to <strong>6</strong> to denote a <i>Collective Beacon</i> payload or to <strong>5</strong> for <i>Beacon</i> payload.</td>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The version of the payload.</td>
    </tr>
    <tr>
        <td>InstanceID</td>
        <td>uint32</td>
        <td>The identifier of the dRNG instance.</td>
    </tr>
    </tr>
    <tr>
    <td valign="top">dRNG subpayload <code>oneOf</code></td>
    <td colspan="2">
    <details open="true">
    <summary>TypeBeacon</summary>
    <blockquote>
    Defines payload data for Beacon payload type.
    </blockquote>
    <table>
    <tr>
    <td><b>Name</b></td>
    <td><b>Type</b></td>
    <td><b>Description</b></td>
    </tr>
    <tr>
    <td>Round</td>
    <td>uint64</td>
    <td>The round of the current beacon.</td>
    </tr>
    <tr>
    <td>PartialPK</td>
    <td>ByteArray[96]</td>
    <td>The public key of the issuer.</td>
    </tr>
    <tr>
    <td>PartialSignature</td>
    <td>ByteArray[96]</td>
    <td>The collective signature of the current beacon.</td>
    </tr>
    </table>
    </details>
    <details open="true">
    <summary>TypeCollectiveBeacon</summary>
    <blockquote>
    Defines payload data for CollectiveBeacon payload type.
    </blockquote>
    <table>
    <tr>
    <td><b>Name</b></td>
    <td><b>Type</b></td>
    <td><b>Description</b></td>
    </tr>
    <tr>
    <td>Round</td>
    <td>uint64</td>
    <td>The round of the current beacon.</td>
    </tr>
    <tr>
    <td>PrevSignature</td>
    <td>ByteArray[96]</td>
    <td>The collective signature of the previous beacon.</td>
    </tr>
    <tr>
    <td>Signature</td>
    <td>ByteArray[96]</td>
    <td>The collective signature of the current beacon.</td>
    </tr>
    <tr>
    <td>DistributedPK</td>
    <td>ByteArray[48]</td>
    <td>The distributed public key.</td>
    </tr>
    </table>
    </details>
    </td>
    </tr>
</table>
<p><em>Table 2.3.7 dRNG beacon payload.</em></p>
<h3 id="2355-drng-application-message"><a class="header" href="#2355-drng-application-message">2.3.5.5 dRNG application message</a></h3>
<p>A message used by a node to declare its willingness to participate in the Committee Selection process. Any node can issue an application message. However, low mana nodes are unlikely to be selected; hence, they can decide to not take part in sending application messages. The payload's serialized form is described in Table 2.3.8.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <tr>
            <td>Size</td>
            <td>uint32</td>
            <td>The size of the payload.</td>
        </tr>
        <tr>
            <td>Payload Type</td>
            <td>uint32</td>
            <td>Set to <strong>3</strong> to denote a <i>Application Message</i> payload.</td>
        </tr>
        <tr>
            <td>Version</td>
            <td>uint8</td>
            <td>The version of the payload.</td>
        </tr>
        <tr>
            <td>InstanceID</td>
            <td>uint32</td>
            <td>The identifier of the dRNG instance.</td>
        </tr>
    </tr>
</table>
<p><em>Table 2.3.8 dRNG application message payload.</em></p>
<h3 id="2356-drng-dkg-payload"><a class="header" href="#2356-drng-dkg-payload">2.3.5.6 dRNG DKG payload</a></h3>
<p>The <code>Deal messages</code> exchanged to produce a public/private collective key during the DKG phase (Table 2.3.9). The <code>Deal messages</code> are issued by the nodes that qualified for the dRNG committee participation (see <a href="./6.6%20dRNG.html">Section 6.5 - Distributed Random Number Generator</a>).</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <tr>
            <td>Size</td>
            <td>uint32</td>
            <td>The size of the payload.</td>
        </tr>
        <tr>
            <td>Payload Type</td>
            <td>uint32</td>
            <td>Set to <strong>4</strong> to denote a <i>Deal Message</i> payload.</td>
        </tr>
        <tr>
            <td>Version</td>
            <td>uint8</td>
            <td>The version of the payload.</td>
        </tr>
        <tr>
            <td>InstanceID</td>
            <td>uint32</td>
            <td>The identifier of the dRNG instance.</td>
        </tr>
        <tr>
            <td>FromIndex</td>
            <td>uint32</td>
            <td>The index of the dealer.</td>
        </tr>
        <tr>
            <td>ToIndex</td>
            <td>uint32</td>
            <td>The index of the verifier.</td>
        </tr>
        <tr>
    <td valign="top">Deal <code>oneOf</code></td>
    <td colspan="2">
    <details open="true">
    <summary>EncryptedDeal</summary>
    <blockquote>
    An encrypted share struct.
    </blockquote>
    <table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Dhkey</td>
            <td>ByteArray</td>
            <td>An ephemeral Diffie-Hellman key.</td>
        </tr>
        <tr>
            <td>Nonce</td>
            <td>ByteArray</td>
            <td>The nonce used in AES-GCM.</td>
        </tr>
        <tr>
            <td>EncryptedShare</td>
            <td>ByteArray</td>
            <td>The ciphertext of the share.</td>
        </tr>
        <tr>
            <td>Threshold</td>
            <td>uint32</td>
            <td>The threshold of the secret sharing protocol (decided during committee selection).</td>
        </tr>
        <tr>
            <td>Commitments</td>
            <td>ByteArray</td>
            <td>The commitments of the polynomial used to derive the share.</td>
        </tr>
    </table>
    </details>
    </tr>
</table>
<p><em>Table 2.3.9 dRNG DKG payload.</em></p>
<h3 id="2357-salt-declaration-payload"><a class="header" href="#2357-salt-declaration-payload">2.3.5.7 Salt declaration payload</a></h3>
<p>The salt declaration payload is used by nodes to declare their initial salt. In a salt declaration message, the declaring node includes the fields specified in Table 2.3.10.</p>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
    <tr>
        <td>Size</td>
        <td>uint32</td>
        <td>The size of the payload.</td>
    </tr>
    <tr>
        <td>Payload Type</td>
        <td>uint32</td>
        <td>Set to <strong>7</strong> to denote a <i>Salt declaration</i>.</td>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The version of the payload.</td>
    </tr>
    <tr>
        <td>NodeID</td>
        <td>uint32</td>
        <td>The declaring node ID (which may be different from the node ID of the issuer of the message).</td>
    </tr>
    <tr>
    <td valign="top">Salt <code>oneOf</code></td>
    <td colspan="2">
    <details open="true">
    <summary>Salt</summary>
    <blockquote>
    The public salt of the requester defined.
    </blockquote>
    <table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Bytes</td>
            <td>ByteArray</td>
            <td> The value of the salt.</td>
        </tr>
        <tr>
            <td>ExpTime</td>
            <td>time</td>
            <td>The expiration time of the salt.</td>
        </tr>
    </table>
    </details>
    </tr>
    <tr>
        <td>Timestamp</td>
        <td>time</td>
        <td>The timestamp of the payload, which shall be close to the timestamp of its containing message.</td>
    </tr>
    <tr>
        <td>Signature</td>
        <td></td>
        <td>The node signature, that ensures all 'redeclarations' would be malicious.</td>
    </tr>
<table>
<p><em>Table 2.3.10 Salt declaration payload.</em></p>
<h3 id="2358-indexations-payload"><a class="header" href="#2358-indexations-payload">2.3.5.8 Indexations payload</a></h3>
<p>Allows the addition of an index to the encapsulating message, as well as some arbitrary data.
Nodes will expose an API that will enable the querying of messages by the index.
Adding those capabilities may open nodes to DOS attack vectors:</p>
<ol>
<li>Proliferation of index keys that may blow up the node's DB</li>
<li>Proliferation of messages associated with the same index</li>
</ol>
<p>Node implementations may provide weak guarantees regarding the completion of indexes to address the above scenarios.</p>
<p>Besides the index, the payload will also have a data field.
A message that has been attached to the Tangle has several useful properties: verifying that the content of the data did not change 
and determining the approximate time it was published by checking timestamps. If the payload will be incorporated under
the <code>signed transaction payload</code>, the content will be signed as well.</p>
<p>The structure of the payload is presented in Table 2.3.11.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Size</td><td>uint32</td><td>The size of the payload.</td></tr>
<tr><td>Payload Type</td><td>uint32</td><td>Set to <strong>8</strong> to denote an <i>Indexation payload</i>.</td></tr>
<tr><td>Version</td><td>uint8</td><td>The version of the payload.</td></tr>
<tr><td>Index</td><td>ByteArray</td><td>The index key of the message.</td></tr>
<tr><td>Data</td><td>ByteArray</td><td>Data we are attaching.</td></tr>
</tbody></table>
<p><em>Table 2.3.11 Indexations payload.</em></p>
<p>Note that <code>index</code> field should be 1 to 64 bytes long for the payload to be valid. The <code>data</code> may have a length of 0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-data-flow"><a class="header" href="#24-data-flow">2.4 Data flow</a></h1>
<p>This section provides a high-level description of the interaction between components of the IOTA 2.0 protocol. The protocol can be divided into three main elements: a P2P overlay network, an immutable data structure, and a consensus mechanism. In the IOTA 2.0 protocol, these three elements are abstracted into layers, wheresimilarly to other architecturesupper layers build on the functionality provided by the layers below them. The definition of the different layers is merely about the convenience of creating a clear separation of concerns. All modules and their interactions will be described later in this document.</p>
<p><img src="https://i.imgur.com/qiZtuon.png" alt="" /></p>
<h2 id="241-network-layer"><a class="header" href="#241-network-layer">2.4.1 Network Layer</a></h2>
<p>The network will be maintained by the network layer modules, which can be characterized as a pure P2P overlay network, meaning that it is a system that runs on top of another network (e.g., the internet), and where all nodes have the same roles and perform the same actions (in contrast to client-server systems). IOTA 2.0's Network Layer consists of two basic modules: the <a href="./3.3%20Peer%20Discovery.html">peer discovery</a> module (which provides a list of nodes actively using the network), and the <a href="./3.4%20Neighbor%20Selection.html">neighbor selection</a> module (also known as autopeering), which actually select peers. Finally, the gossip is managed by the network layer as well.</p>
<h2 id="242-communication-layer"><a class="header" href="#242-communication-layer">2.4.2 Communication Layer</a></h2>
<p>The communication layer concerns the information propagated through the network layer, which is contained in objects called messages. This layer forms a DAG with messages as vertices called <a href="./4.1%20The%20Tangle.html">The Tangle</a>: a replicated, shared and distributed data structure that emerges through a combination of deterministic rules, cooperation, and (either direct or virtual) votingas FPC and approval weight based finality. Since nodes have finite capabilities, the number of messages that the network can process is limited. Thus, the network might become overloaded, either simply because of honest heavy usage or because of malicious (spam) attacks. To protect the network from halting or even from getting inconsistent, the <a href="./4.5%20Rate%20Control.html">rate control</a> and <a href="./4.6%20Congestion%20Control.html">congestion control</a> modules control when and how many messages can be gossiped. </p>
<h2 id="243-decentralized-application-layer"><a class="header" href="#243-decentralized-application-layer">2.4.3 (Decentralized) Application Layer</a></h2>
<p>On top of the communication layer lives the application layer. Anybody can develop applications that run on this layer, and nodes can choose which applications to run. Of course, these applications can also be dependent on each other. There are several core applications that must be run by all nodes, as the value transfer applications, which maintains the <a href="./5.2%20Ledger%20State.html">ledger state</a> and a quantity called <a href="./5.3%20Mana.html">Mana</a>, that serves as a scarce resource to our Sybil protection mechanism. Additionally, all nodes must run what we call the consensus applications, which regulate timestamps in the messages and resolve conflicts. The <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Fast Probabilistic Consensus</a> (Fast Probabilistic Consensus) application provides a binary voting protocol that produces consensus on a bit. <a href="./6.1%20Objects%20of%20Consensus.html">Section 6.1 - Object of Consensus</a> outlines how this binary voting protocol is used to vote on actual objects, particularly transactions and timestamps. In particular, FPC determines which transactions are to be written to the ledger, and which ones should be left to be orphaned. The FPC application uses another application called <a href="./6.6%20dRNG.html">dRNG</a> (distributed Random Number Generator). Lastly, the Node Perception Reorganization application enables nodes to reorganize their perception of the Tangle if needed.</p>
<h2 id="244-data-flow---overview"><a class="header" href="#244-data-flow---overview">2.4.4 Data flow - Overview</a></h2>
<p>The diagram below represents the interaction between the different modules in the protocol. Each blue box represents a component, which have events (in yellow boxes) that belong to them. Those events will trigger methods (the green boxes), that can also trigger other methods. This triggering is represented by the arrows in the diagram. Finally, the purple boxes represent events that do no belong to the component that triggered them.</p>
<p>As an example, take the Parser component. The function <code>ProcessGossipMessage</code> will trigger the method <code>Parse</code>, which is the only entry to the component. There are three possible outcomes to the <code>Parser</code>: triggering a <code>ParsingFailed</code> event, a <code>MessageRejected</code> event, or a <code>MessageParsed</code> event. In the last case, the event will trigger the <code>StoreMessage</code> method (which is the entry to the Storage component), whereas the first two events do not trigger any other component.</p>
<p><img src="https://i.imgur.com/H2TPkQd.png" alt="" /></p>
<p>We present what we call the data flow, i.e., the life cycle of a message, from message reception (meaning that we focus here on the point of view of a node receiving a message issued by another node) up until acceptance in the Tangle. The message creation complete process is described in Section 4.8 - Message Creation. Notice that any message, either created locally by the node or received from a neighbor needs to pass through most of the data flow. Specifically, all messages pass from the Storage component to the Tip Manager.</p>
<h3 id="2441-message-factory"><a class="header" href="#2441-message-factory">2.4.4.1 Message Factory</a></h3>
<p>The IssuePayload function creates a valid payload which is provided to the CreateMessage method, along with a set of parents chosen with the <a href="./4.3%20Tip%20Selection%20Algorithm.html">Section 4.3 - Tip Selection Algorithm</a>. Then, the Message Factory component is responsible to find a nonce compatible with the PoW requirements defined by the <a href="./4.5%20Rate%20Control.html">rate control</a> module. Finally, the message is signed (see <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message Layout</a>). Notice that the message generation should follow the rates imposed by the rate setter, as defined in <a href="./4.6%20Congestion%20Control.html">Section 4.6 - Congestion Control</a></p>
<h3 id="2442-parser"><a class="header" href="#2442-parser">2.4.4.2 Parser</a></h3>
<p>The first step after the arrival of the message to the message inbox is the parsing, which consists of the five following different filtering processes (meaning that the messages that don't pass these steps will not be stored):</p>
<ol>
<li>Recently Seen Bytes: it compares the incoming messages with a pool of recently seen bytes to filter duplicates. If the message does not pass this check, the message is dropped. If it passes the check, it goes to the next step. </li>
<li>Parsing and Syntactical Validation: it checks if the message and the payload (when present) are syntactically valid, as defined in <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message Layout</a> and <a href="./2.3%20Standard%20Payloads%20Layout.html">Section 2.3 - Payloads Layout</a>. If the parsing fails, a <code>ParsingFailed</code> event is triggered; if the Syntactical Validation fails, a <code>MessageRejected</code> event is triggered. If it passes both checks, it goes to the next step. </li>
<li>Timestamp Difference Check: it checks if the timestamps of the payload and the message are consistent with each other, i.e., if <code>transaction.timestamp+TW &gt;= message.timestamp &gt;= transaction.timestamp</code>, where TW is the maximal difference between message timestamp and transaction timestamp, as defined in <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>. Evidently, this step is only executed when the message contains a payload. If the message does not pass this check, a <code>MessageRejected</code> event is triggered. If it passes the check, it goes to the next step. </li>
<li>Signature check: it checks if the message signature is valid (see <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message Layout</a>). If the message does not pass this check, a <code>MessageRejected</code> event is triggered. If it passes the check, it goes to the next step. </li>
<li>aPoW check: it checks if the PoW requirements are met, as defined in <a href="./4.5%20Rate%20Control.html">Section 4.5 - Rate Control</a>. If the message does not pass this check, a <code>MessageRejected</code> event is triggered. If it passes the check, a <code>MessageParsed</code> event is issued, which will trigger the Storage module. </li>
</ol>
<p><img src="https://i.imgur.com/YwmO0Ec.png" alt="" /></p>
<h3 id="2443-storage"><a class="header" href="#2443-storage">2.4.4.3 Storage</a></h3>
<p>Only the messages that pass the Parser will be stored, along with its metadata <code>receivedTime</code>. As defined in <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message Layout</a>, the message has additional metadata fields, such as <code>solidificationTime</code> and other Boolean flags, that will be set in future points of the data flow. The storage also performs a cleaning process, which can be triggered periodically or everytime a message is marked as invalid, to delete invalid messages.</p>
<h3 id="2444-solidifier"><a class="header" href="#2444-solidifier">2.4.4.4 Solidifier</a></h3>
<p>The solidification is the process of requesting missing messages. In this step, the node checks if all the past cone of the message is known; in the case that the node realizes that a message in the past cone is missing, it will send a request to its neighbors asking for that missing message. This process is recursively repeated until all of a message's past cone up to the genesis (or snapshot) becomes known to the node (for more information, see <a href="./4.4%20Solidification.html">Section 4.4 - Solidification</a>).
This way, the protocol enables any node to retrieve the entire message history, even for nodes that have just joined the network. When the solidification process successfully ends, the flag <code>solid</code> in its metadata is set to <code>TRUE</code>. In the case that the process does not terminate successfully, the flag <code>invalid</code> is set to <code>TRUE</code>. If, while solidifying, the node realizes that one of the parents of the message is <code>invalid</code>, the message itself is also marked as <code>invalid</code>.</p>
<p>Also in the solidifier, the &quot;Parents age check&quot; is performed. It consists in checking if the timestamp of the message and the timestamps of each of its parents satisfy
<code>parent.timestamp+DELTA &gt;= message.timestamp &gt;= parent.timestamp</code> (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>). As in the solidification case, if the above condition is not met, the message is marked as <code>invalid</code>.</p>
<p><img src="https://i.imgur.com/8j7bQQ8.png" alt="" /></p>
<h3 id="2445-scheduler"><a class="header" href="#2445-scheduler">2.4.4.5 Scheduler</a></h3>
<p>One may think of the scheduler as a gatekeeper to the more expensive computations. Once the steps above are successful, the message is enqueued into the outbox. The outbox is split into several queues, each one corresponding to a different node issuing messages. Once the message is enqueued into the right place, the queue is sorted by increasing message timestamp. The dequeueing process is done using a modified version of the deficit round robin (DRR) algorithm, as described in <a href="./4.6%20Congestion%20Control.html">Section 4.6 - Congestion Control</a>. A maximum (fixed) global rate <code>SCHEDULING_RATE</code>, at which messages will be scheduled, is set.</p>
<h3 id="2446-booker"><a class="header" href="#2446-booker">2.4.4.6 Booker</a></h3>
<p>After scheduling, the message goes to the booker. This step is different between messages that contain a transaction payload and messages that do not contain it. </p>
<p>In the case of a non-value message, booking into the Tangle occurs after the conflicting parents branches check, i.e., after checking if the parents' branches contain sets of (two or more) transactions that belong to the same conflict set (see <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>). In the case of this check not being successful, the message is marked as <code>invalid</code> and not booked.</p>
<p>In the case of a value message, initially, the following check is done:</p>
<ol>
<li>UTXO check: it checks if the inputs of the transaction were already booked. If the message does not pass this check, the message is not booked and a <code>TransactionNotBooked</code> event is triggered. If it passes the check, it goes to the next block of steps. </li>
</ol>
<p>Then, the following objective checks are done:</p>
<ol start="2">
<li>Balances check: it checks if the sum of the values of the generated outputs equals the sum of the values of the consumed inputs. If the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step. </li>
<li>Unlock conditions: checks if the unlock conditions (see <a href="./2.3%20Standard%20Payloads%20Layout.html">Section 2.3 - Standard Payloads Layout</a>) are valid. If the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step. </li>
<li>Inputs' branches validity check: it checks if all the consumed inputs belong to a valid branch. If the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step. </li>
</ol>
<p>After the objective checks, the following subjective checks are done:</p>
<ol start="5">
<li>Inputs' branches rejection check: it checks if all the consumed inputs belong to a non-rejected branch. Notice that this is not an objective check, so the node is susceptible (even if with a small probability) to have its opinion about rejected branches changed by a reorganization. For that reason, if the message does not pass this check, the message is booked into the Tangle and ledger state (even though the balances are not altered by this message, since it will be booked to a rejected branch). This is what we call &quot;lazy booking&quot;, which is done to avoid huge re-calculations in case of a reorganization of the ledger. If it passes the check, it goes to the next step. </li>
<li>Double spend check: it checks if any of the inputs is conflicting with a transaction that was already confirmed. As in the last step, this check is not objective and, thus, if the message does not pass this check, it is lazy booked into the Tangle and ledger state, into an invalid branch. If it passes the check, it goes to the next step. </li>
</ol>
<p>At this point, the missing steps are the most computationally expensive:</p>
<ol start="7">
<li>Past cone check: it checks if the inputs of the transaction were generated by transactions in the past cone of the message. As this check is objective, if the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step. </li>
<li>Inputs' conflicting branches check: it checks if the branches of the inputs are conflicting. As in the last step, if the message does not pass this check, the message is marked as <code>invalid</code> and not booked. If it passes the check, it goes to the next step. </li>
<li>Conflict check: it checks if the inputs are conflicting with an unconfirmed transaction. In this step, the branch to which the message belongs is computed. In both cases (passing the check or not), the message is booked into the ledger state and the Tangle, but its branch ID will be different depending on the outcome of the check (see <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>).</li>
</ol>
<p><img src="https://i.imgur.com/ra09bbl.png" alt="" /></p>
<p>Finally, after a message is booked, it can be gossiped.</p>
<h3 id="2447-opinion-former"><a class="header" href="#2447-opinion-former">2.4.4.7 Opinion Former</a></h3>
<p>The opinion former consists of two independent processes, that can be done in parallel: the payload opinion setting and the message timestamp opinion setting. The message timestamp opinion setting is described in <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>, and it's done after a initial timestamp check (and possible FPC voting, as described in <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Section 6.3 - Fast Probabilistic Consensus</a>). </p>
<p>In parallel to the message timestamp opinion setting, a payload evaluation is also done. If the message does not contain a transaction payload, the payload opinion is automatically set to <code>liked</code>. Otherwise, it has to pass the FCoB rule (and possibly, an FPC voting) in order to be <code>liked</code>, as described in <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a> and <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Section 6.3 - Fast Probabilistic Consensus</a>. </p>
<p><img src="https://i.imgur.com/biQIikd.png" alt="" /></p>
<h3 id="2448-tip-manager"><a class="header" href="#2448-tip-manager">2.4.4.8 Tip Manager</a></h3>
<p>The first check done in the tip manager is the eligibility check, which is defined in <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>, after passing it, a message is said to be <code>eligible</code> for tip selection (otherwise, it's <code>not eligible</code>).  If a message is eligible for tip selection and its payload is <code>liked</code>, along with all its weak past cone, the message is added to the strong tip pool and its parents are removed from the strong tip pool (for more information about the different tip pools, see <a href="./4.3%20Tip%20Selection%20Algorithm.html">Section 4.3 - Tip Selection Algorithm</a>). If a message is eligible for tip selection, its payload is <code>liked</code> and the message is not in the strong pool, it is added to the weak tip pool and its parents are removed from any the pool that they are included.</p>
<p><img src="https://i.imgur.com/ui8LZll.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-peer-discovery"><a class="header" href="#33-peer-discovery">3.3 Peer Discovery</a></h1>
<h2 id="331-introduction"><a class="header" href="#331-introduction">3.3.1 Introduction</a></h2>
<p>This section defines the <em>Peer Discovery</em> protocol, its logic and the different requests and responses exchanged.</p>
<p>In order to establish connections, an IOTA node needs to discover and maintain a list of the reachable IP addresses of other peers. Moreover, some external modules, such as the <em>Neighbor Selection</em> and the <em>Fast Probabilistic Consensus (FPC)</em> may require an updated list of known peers.</p>
<p>The main goal of the <em>Peer Discovery</em> protocol is to expose an interface providing a list of all the verified peers.</p>
<p>Throughout this section the terms <code>Node</code> and <code>Peer</code> are used interchangeably to refer to a <code>Node</code> device.</p>
<p>The usage of the <em>Ping</em> and <em>Pong</em> mechanism is to be considered as a bidirectional exchange similarly to how described by other standards such as <a href="https://core-wg.github.io/coap-sig/">CoAP</a> and <a href="https://tools.ietf.org/html/rfc6455#section-5.5.2">WebSocket</a>.</p>
<h2 id="332-detailed-design"><a class="header" href="#332-detailed-design">3.3.2 Detailed design</a></h2>
<p>To bootstrap the peer discovery, a node <em>must</em> be able to reach one or more entry nodes. To achieve this, the implementation of the protocol <em>shall</em> provide a hard-coded list of trusted <strong>entry nodes</strong> run by the IF or by trusted community members that answer to peer discovery packets coming from new nodes joining the IOTA network. This approach is a common practice of many distributed networks <a href="https://ieeexplore.ieee.org/iel7/9739/8649699/08456488.pdf">[Neudecker 2018]</a>. 
Public Key-based Cryptography (PKC) <em>shall</em> be used for uniquely <a href="3.3%20Peer%20Discovery.html#Node_identities">identifying</a> peers and for authenticating each packet. 
The usage of the Ping and Pong protocols is that <a href="3.3%20Peer%20Discovery.html#Ping"><em>Ping</em></a> are sent to verify a given peer and, upon reception of a valid <a href="3.3%20Peer%20Discovery.html#Pong"><em>Pong</em></a> as a response from that peer, the peer is verified.
Once a peer has been verified, it can be queried to discover new peers by sending a <a href="3.3%20Peer%20Discovery.html#DiscoveryRequest"><em>DiscoveryRequest</em></a>. As a response, a <a href="3.3%20Peer%20Discovery.html#DiscoveryResponse"><em>DiscoveryResponse</em></a> <em>shall</em> be returned, containing a list of new peers. The new peer nodes in this list <em>shall</em> be verified by the receiving application.</p>
<p>This process is summarized in the following figure and detailed in the following subsections:</p>
<p><img src="https://i.imgur.com/U51tPeK.png" alt="" /></p>
<h3 id="3321-node-identities"><a class="header" href="#3321-node-identities">3.3.2.1 Node identities</a></h3>
<p>Every node has a cryptographic identity, a key on the ed25519 elliptic curve. The <code>blake2b</code> hash of the public key of the peer serves as its identifier or <code>node ID</code>.</p>
<h3 id="3322-verification"><a class="header" href="#3322-verification">3.3.2.2 Verification</a></h3>
<p>The verification process aims at both verifying peer identities and checking their online status. Each peer <em>shall</em> maintain a list of all the known peers. This list <em>shall</em> be called <code>known_peer_list</code>. Elements of any known peer list <em>shall</em> contain a reference to a <a href="3.3%20Peer%20Discovery.html#Peer">Peer</a> and a time at which it <em>shall</em> be verified/re-verified. 
As such, the <code>known_peer_list</code> can be seen as a time-priority queue. A newly discovered peer gets added to the list at the current time. Whenever a peer is verified, its time value on the <code>known_peer_list</code> gets updated to the time at which that peer <em>shall</em> be re-verified. 
The intent of this arrangement is to allow the node application to first verify newly discovered (and thus still unverified) peers and then to re-verify older peers (to confirm their online status) by iterating over the <code>known_peer_list</code>.
It is worthwhile to note that the order in which the <code>known_peer_list</code> is worked through is important. For example, if the peer is added to the front ('head') of the <code>known_peer_list</code>, it is possible for an adversary to front-fill the <code>known_peer_list</code> with a selection of its own nodes. This is resolved by the use of the time-priority queue.</p>
<p>The verification process always initiates from a <a href="3.3%20Peer%20Discovery.html#Ping">Ping</a>. Upon reception of a <a href="3.3%20Peer%20Discovery.html#Ping">Ping</a>, a peer <em>shall</em> check its validity by:</p>
<ul>
<li>verifying that the signature of the <a href="3.3%20Peer%20Discovery.html#Ping">Ping</a> is valid and discarding the request otherwise;</li>
<li>checking that the <code>version</code> and <code>network_id</code> fields match its configuration and discarding the <a href="3.3%20Peer%20Discovery.html#Ping">Ping</a> otherwise;</li>
<li>checking that the <code>timestamp</code> field is fresh (i.e., not older than a given time) and discarding the packet otherwise;</li>
<li>checking that the <code>dest_addr</code> matches its IP address and discarding the <a href="3.3%20Peer%20Discovery.html#Ping">Ping</a> otherwise.</li>
</ul>
<p>Upon successful validation of a received <a href="3.3%20Peer%20Discovery.html#Ping">Ping</a>, a peer <em>shall</em> respond with a <a href="3.3%20Peer%20Discovery.html#Pong">Pong</a>. In case the sender of the <em>Ping</em> is a new peer from the perspective of the receiving node, the receiver peer <em>shall</em> add it to its <code>known_peer_list</code>. This enables the verification process to also occur in the reverse direction. </p>
<p>Upon reception of a <a href="3.3%20Peer%20Discovery.html#Pong">Pong</a>, a peer <em>shall</em> check its validity by:</p>
<ul>
<li>verifying that the signature of the <a href="3.3%20Peer%20Discovery.html#Pong">Pong</a> is valid and discarding it otherwise;</li>
<li>checking that the <code>req_hash</code> field matches a request (i.e. <em>Ping</em>) previously sent and not expired (i.e., the difference between the timestamp of the <em>Ping</em> and <em>Pong</em> is not greater than a given threshold) and discarding the associated <em>Ping</em> or <em>Pong</em> otherwise;</li>
<li>checking that the <code>dest_addr</code> matches its IP address and discarding the associated <em>Ping</em> or <em>Pong</em> otherwise.</li>
</ul>
<p>Upon successful validation of a received <a href="3.3%20Peer%20Discovery.html#Pong">Pong</a>, a peer <em>shall</em>:</p>
<ul>
<li>add the peer sender of the <em>Pong</em> to a list of verified peers called <code>verified_peer_list</code>;</li>
<li>move the peer entry of the <code>known_peer_list</code> to the tail.</li>
</ul>
<h3 id="3323-removal"><a class="header" href="#3323-removal">3.3.2.3 Removal</a></h3>
<p>While verifying a new peer, if no or an invalid <em>Pong</em> is received after <code>max_verify_attempts</code> attempts, that node <em>shall</em> be removed from the <code>known_peer_list</code>. Each expected reply should have a timeout such that if no answer is received after that, an attempt is considered concluded and counted as failed. </p>
<p>Each peer on the <code>verified_peer_list</code> <em>shall</em> be re-verified after <code>verification_lifetime</code> hours; while re-verifying a peer, if no or invalid <em>Pong</em> is received after <code>max_reverify_attempts</code> attempts, the peer <em>shall</em> be removed from the <code>verified_peer_list</code>.</p>
<h3 id="3324-discovery"><a class="header" href="#3324-discovery">3.3.2.4 Discovery</a></h3>
<p>Each peer entry of the <code>verified_peer_list</code> may be used to discover new peers. This process is initiated by sending a <a href="3.3%20Peer%20Discovery.html#DiscoveryRequest">DiscoveryRequest</a>.</p>
<p>Upon reception of a <a href="3.3%20Peer%20Discovery.html#DiscoveryRequest">DiscoveryRequest</a>, a peer node <em>shall</em> check its validity by:</p>
<ul>
<li>checking that the sender of the <a href="3.3%20Peer%20Discovery.html#DiscoveryRequest">DiscoveryRequest</a> is a verified peer (i.e. is stored in the <code>verified_peer_list</code>) and discarding the request otherwise;</li>
<li>verifying that the signature of the <a href="3.3%20Peer%20Discovery.html#DiscoveryRequest">DiscoveryRequest</a> is valid and discarding the request otherwise;</li>
<li>checking that the <code>timestamp</code> field is fresh (i.e., not older than a given time) and discarding the request otherwise.</li>
</ul>
<p>Upon successful validation of a received <a href="3.3%20Peer%20Discovery.html#DiscoveryRequest">DiscoveryRequest</a>, a peer <em>shall</em> reply with a <a href="3.3%20Peer%20Discovery.html#DiscoveryResponse">DiscoveryResponse</a>.</p>
<p>Upon reception of a <a href="3.3%20Peer%20Discovery.html#DiscoveryResponse">DiscoveryResponse</a>, a peer <em>shall</em> check its validity by:</p>
<ul>
<li>verifying that the signature of the <a href="3.3%20Peer%20Discovery.html#DiscoveryResponse">DiscoveryResponse</a> is valid and discarding the response otherwise;</li>
<li>checking that the <code>req_hash</code> field matches a discovery request (i.e. <em>DiscoveryRequest</em>) previously sent and not expired (i.e., the difference between the timestamp of the <em>DiscoveryRequest</em> and <em>DiscoveryResponse</em> is not greater than a given threshold) and discarding the response otherwise.</li>
</ul>
<p>Upon successful validation of a received <a href="3.3%20Peer%20Discovery.html#DiscoveryResponse">DiscoveryResponse</a>, a node <em>shall</em> add the nodes contained in the <code>peers</code> field to the <code>known_peer_list</code>.</p>
<h3 id="3325-ping-and-pong-layout"><a class="header" href="#3325-ping-and-pong-layout">3.3.2.5 Ping and Pong Layout</a></h3>
<p>Each <em>Ping</em> and <em>Pong</em> <em>shall</em> be encapsulated into a <code>data</code> field of a generic <code>Request</code> and <code>Response</code>. Its <code>type</code>  <em>shall</em> be specified in the <code>type</code> field. Each request and response <em>shall</em> be signed with the ed25519 private key of the sender's <a href="3.3%20Peer%20Discovery.html#Node_identities">identity</a> and <em>shall</em> contain the related public key, in order to allow the packet receiving node to verify the signature. All the received responses <em>shall</em> be verified and those with invalid signature <em>shall</em> be discarded.</p>
<h4 id="request-and-response-layout"><a class="header" href="#request-and-response-layout">Request and Response Layout</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>type</td>
         <td>uint8</td>
         <td>Defines the type of the request or response.</td>
     </tr>
     <tr>
         <td>data</td>
         <td>ByteArray</td>
         <td>contains the payload of the  request or response (e.g., a Ping).</td>
     </tr>
     <tr>
         <td>public_key</td>
         <td>ByteArray[32]</td>
         <td>The ed25519 public key of the peer's identity used to verify its signatures.</td>
     </tr>
     <tr>
         <td>signature</td>
         <td>ByteArray[32]</td>
         <td>The ed25519 signature of the `data` field, signed by using the private key of the peer's identity.</td>
     </tr>
 </table>
<h4 id="ping"><a class="header" href="#ping">Ping</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>version</td>
         <td>uint32</td>
         <td>The version of the protocol.</td>
     </tr>
      <tr>
         <td>network_id</td>
         <td>uint32</td>
         <td>The network identifier.</td>
     </tr>
     <tr>
         <td>timestamp</td>
         <td>time</td>
         <td>The unix timestamp of the Ping.</td>
     </tr>
     <tr>
         <td>src_addr</td>
         <td>string</td>
         <td>The IP address, in string form, of the sender (e.g., "192.0.2.1", "[2001:db8::1]").</td>
     </tr>
     <tr>
         <td>src_port</td>
         <td>uint32</td>
         <td>The listening port of the sender.</td>
     </tr>
     <tr>
         <td>dst_addr</td>
         <td>string</td>
         <td>The string form of the receiver's IP address. This provides a way to discover the external address (after NAT).</td>
     </tr>
 </table>
<h4 id="pong"><a class="header" href="#pong">Pong</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>req_hash</td>
         <td>ByteArray[32]</td>
         <td>The blake2b digest of the corresponding received Ping.</td>
     </tr>
     <tr>
         <td colspan="1">
             services
         </td>
         <td colspan="2">
             <details open="true">
                 <summary>Services supported by the Pong sender.</summary>
                 <table>
                     <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                     </tr>
                     <tr>
                        <td>serviceID</td>
                        <td>ByteArray[32]</td>
                        <td>The service ID (e.g., autopeering, gossip, fpc).</td>
                     </tr>
                     <tr>
                        <td>network</td>
                        <td>string</td>
                        <td>The string form of the network (e.g., udp, tcp).</td>
                     </tr>
                     <tr>
                        <td>port</td>
                        <td>uint32</td>
                        <td>The listening port of the service.</td>
                     </tr>
                 </table>
             </details>
         </td>
     </tr>
     <tr>
         <td>dst_addr</td>
         <td>string</td>
         <td>the string form of the receiver's IP address. This MUST mirror the src_addr of the Ping's IP packet. It provides a way to discover the external address (after NAT).</td>
     </tr>
 </table>
<h4 id="discoveryrequest"><a class="header" href="#discoveryrequest">DiscoveryRequest</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>timestamp</td>
         <td>time</td>
         <td>The unix timestamp of the DiscoveryRequest.</td>
     </tr>
 </table>
<h4 id="discoveryresponse"><a class="header" href="#discoveryresponse">DiscoveryResponse</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>req_hash</td>
         <td>ByteArray[32]</td>
         <td>The blake2b digest of the corresponding received DiscoveryRequest.</td>
     </tr>
     <tr>
         <td colspan="1">
             peers
         </td>
         <td colspan="2">
             <details open="true">
                 <summary>The list of some randomly chosen peers known by the sender of the DiscoveryResponse <code>between(1,6).</summary>
                 <table>
                     <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                     </tr>
                     <tr>
                        <td>public_key</td>
                        <td>ByteArray[32]</td>
                        <td>The ed25519 public key of the peer's identity used to verify its signature.</td>
                     </tr>
                     <tr>
                        <td>ip</td>
                        <td>string</td>
                        <td>The string form of the peer's IP address.</td>
                     </tr>
                     <tr>
                        <td colspan="1">
                            services
                        </td>
                        <td colspan="2">
                            <details open="true">
                                <summary>Services supported by the peer.</summary>
                                <table>
                                    <tr>
                                        <th>Name</th>
                                        <th>Type</th>
                                        <th>Description</th>
                                    </tr>
                                    <tr>
                                        <td>serviceID</td>
                                        <td>ByteArray[32]</td>
                                        <td>The service ID (e.g., autopeering, gossip, fpc).</td>
                                    </tr>
                                    <tr>
                                        <td>network</td>
                                        <td>string</td>
                                        <td>The string form of the network (e.g., udp, tcp).</td>
                                    </tr>
                                    <tr>
                                        <td>port</td>
                                        <td>uint32</td>
                                        <td>The listening port of the service.</td>
                                    </tr>
                                </table>
                            </details>
                        </td>
                  </tr>
                  <tr>
                 </table>
             </details>
         </td>
     </tr>
 </table>
<h3 id="3326-denial-of-service"><a class="header" href="#3326-denial-of-service">3.3.2.6 Denial of Service</a></h3>
<p>All the requests and responses exchanged during the Peer Discovery protocol are sent via UDP. As such, any UDP based Denial of Service attack could harm the normal functionality of the protocol. To limit this, hardware based protection such as Firewall or alternatively, rate limiting the incoming requests and responses via leaky/token buckets based techniques could be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-neighbor-selection"><a class="header" href="#34-neighbor-selection">3.4 Neighbor Selection</a></h1>
<h2 id="341-introduction"><a class="header" href="#341-introduction">3.4.1 Introduction</a></h2>
<p>This section defines the <em>Neighbor Selection</em> protocol, its logic and the different requests and responses exchanged between nodes.</p>
<p>In order for the network to work efficiently and for the nodes to be kept up-to-date about the ledger state, nodes exchange information with each other. Each node establishes a communication channel with a small subset of nodes (i.e., neighbors) via a process called <code>peering</code>. Such a process must be resilient against eclipse attacks: if all of a nodes neighbors are controlled by an attacker, then the attacker has complete control over the nodes view of the Tangle. Moreover, to prevent or limitate sybil-based attacks, the neighbor selection protocol makes use of a scarce resource dubbed Consensus Mana: arbitrary nodes can be created, but it is difficult to produce high mana nodes.</p>
<p>Throughout this section, the terms <code>Node</code> and <code>Peer</code> are used interchangeably to refer to a <code>Node</code> device. The term <code>neighbors</code> implies a mutual relationship between two nodes put in place as a direct connection established and used by the gossip layer.</p>
<h2 id="342-dependencies"><a class="header" href="#342-dependencies">3.4.2 Dependencies</a></h2>
<p>The <em>Neighbor Selection</em> protocol depends on:</p>
<ul>
<li>Peer discovery: to get a list of the known and verified node peers.</li>
<li>Consensus Mana: to make the neighbor selection based on cMana value. Whenever <em>mana value</em> term is used in this specification, it refers to the Active cMana value from the last finalized epoch.</li>
</ul>
<h2 id="343-detailed-design"><a class="header" href="#343-detailed-design">3.4.3 Detailed design</a></h2>
<p>The goal of the neighbor selection is to build a node's neighborhood (to be used by the gossip protocol) while preventing attackers from tricking other nodes into becoming neighbors. Neighbors are established when one node sends a peering request to another node, which in turn accepts or rejects the request with a peering response. </p>
<p>To prevent attacks, the protocol makes the peering request <em>verifiably random</em> such that attackers cannot create nodes to which the target node will send requests. At its core, the neighbor selection protocol uses both a screening process called <em>Consensus Mana rank</em> and a <em>score function</em> that takes into account some randomness dubbed <em>private salt</em> and <em>public salt</em>. 
Half of the neighbors will be constituted from nodes that accepted the peering request, while half will be constituted of nodes that will request for the peering. The two distinct groups of neighbors are consequently called:
+ Chosen neighbors (outbound). The peers that the node proactively selected through the neighbor selection mechanism.
+ Accepted neighbors (inbound). The peers that sent the peering request to the node and were accepted as a neighbor.</p>
<h3 id="3431-local-variables"><a class="header" href="#3431-local-variables">3.4.3.1 Local variables</a></h3>
<p>Local variables defined here are included to help in understanding the protocol described in this section. The node application shall handle those variables in some form.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>saltUpdateInterval</code></td><td>duration</td><td>The time interval at which nodes shall update their salts.</td></tr>
<tr><td><code>responseTimeout</code></td><td>duration</td><td>The time that node waits for a response during one peering attempt.</td></tr>
<tr><td><code>requestExpirationTime</code></td><td>duration</td><td>The time used for the request timestamp validation, if the timestamp is older than this threshold the request is dropped.</td></tr>
<tr><td><code>maxPeeringAttempts</code></td><td>integer</td><td>The maximum number of peering requests retries sent to the selected node before the next salt update.</td></tr>
</tbody></table>
<h3 id="3432-node-identities"><a class="header" href="#3432-node-identities">3.4.3.2 Node identities</a></h3>
<p>As for the <em>peer discovery</em> protocol, every node has a cryptographic identity, a key on the Ed25519 elliptic curve. The <code>blake2b</code> hash of the public key of the peer node serves as its identifier or <code>node ID</code>.</p>
<h3 id="3433-salt-generation"><a class="header" href="#3433-salt-generation">3.4.3.3 Salt generation</a></h3>
<p>Nodes <em>shall</em> have a public and private salt both defined as array bytes of size 20. Nodes <em>shall</em> update both their public and private salt at a common fixed time interval <code>saltUpdateInterval</code> (e.g. 3 hours).
The public salt is used for outbound peering requests, while the private salt is used during inbound peering requests.</p>
<p>The public salt must satisfy the following requirements:</p>
<ol>
<li>Future salts must be unguessable: mining node ids to reduce the request score <em>shall</em> be prohibitive. This offers protection for the requesting nodes.</li>
<li>Salts <em>must</em> be chosen in a non-arbitrary way: if adversaries may choose their salt, they could manufacture malicious requests to any node.</li>
</ol>
<p>This section proposes to set the public salts using hash chains, while private salts can be randomly generated on the fly. 
The nodes shall create a hash chain <em> = {_0, _1, ..., _m}</em>  where next chain element is created by hashing the previous one: <em>_{i+1} = hash(_i)</em>.
Then nodes shall make public the last element <em>_m</em> of their hash chain as their initial salt. Every future salt is the next element of the hash chain. Under this proposal, property 1 above holds because cryptographic hash functions are virtually irreversible. 
Property 2 holds fairly well: an adversary can only choose one element of their hash chain. Indeed, an adversary can pick a number to be their 300th salt, hash it 300 times, and post that as their initial salt. However, an adversary can only do this for one round since hash functions have effectively random outputs. Thus an adversary is limited in their ability to choose their own salt.</p>
<h3 id="3434-mana-rank-interval"><a class="header" href="#3434-mana-rank-interval">3.4.3.4 Mana rank interval</a></h3>
<p>Each peer discovered and verified via the <em>Peer Discovery</em> protocol <em>shall</em> have a consensus mana value associated with it. The peer running the <em>Neighbor Selection</em> protocol <em>shall</em> keep this information up-to-date and use it to update a data structure called <code>manaRank</code> containing the list of the nodes' identities for each mana value. The aim of this ranking is to select a subset of peers having similar mana to the node preparing the ranking. More specifically, let's define <code>potentialNeighbors</code> to be such a subset, that is divided into a <code>lower</code> and an <code>upper</code> set with respect to a <code>targetMana</code> value (i.e., the mana value of the node performing the ranking). By iterating over the <code>manaRank</code>, each node <em>shall</em> fill both the <code>lower</code> and  <code>upper</code> sets with nodes' identities having a similar rank to itself, not less/greater than a given threshold <code>rho</code> respectively, except when each subset does not reach the minimal size <code>r</code>.</p>
<p>The following pseudocode describes a reference implementation of this process:</p>
<pre><code>Inputs: 
    manaRank: mapping between mana values and the list of nodes' identities with that mana; 
    targetMana: the mana value of the node performing the ranking;
    rho: the ratio determining the length of the rank to consider;
    r: the minimum number of nodes' identities to return for both lower and upper sets;
    Largest(r, targetMana): the set of r largest cMana holders less than targetMana;
    Smallest(r, targetMana): the set of r smallest cMana holders greater than targetMana;

Outputs:
    potentialNeighbors: the set of nodes' identities to consider for neighbor selection;
</code></pre>
<pre><code class="language-vbnet">FOR mana IN manaRank
    nodeID = manaRank[mana]
    IF mana &gt; targetMana
        IF mana / targetMana &lt; rho
            Append(upperSet, nodeID)
    ELSE IF mana == 0 || mana == targetMana
        BREAK
    ELSE IF targetMana / mana &lt; rho
        Append(lowerSet, nodeID)

IF Len(lowerSet) &lt; r
	// set lowerSet with the r largest mana holders less than targetMana
	lowerSet = Largest(r, targetMana)
	
IF Len(upperSet) &lt; r
    // set upperSet with the r smallest mana holders greater than targetMana
	upperSet = Smallest(r, targetMana)

potentialNeighbors = Append(upperSet, lowerSet)
RETURN potentialNeighbors

</code></pre>
<h3 id="3435-selection"><a class="header" href="#3435-selection">3.4.3.5 Selection</a></h3>
<p>The maximum number of neighbors is a parameter of the gossip protocol. This section proposes to use a size of 8 equally divided into 4 chosen (outbound) and 4 accepted (inbound) neighbors. It is crucial to decide on a fixed number of neighbors, as the constant number decreases an eclipse probability exponentially. The chosen <em>k</em> is a compromise between having more connections resulting in lower performance and increased protection from an eclipse attack.</p>
<p>The operations involved during neighbor selection are listed in the following:</p>
<ol>
<li>Get an up-to-date list of verified and known peers from the <em>Peer Discovery</em> protocol. </li>
<li>Use <a href="3.4%20Neighbor%20Selection.html#Mana_rank">mana rank</a> to filter the previous list to obtain a list of peers to be potential neighbors.</li>
<li>Use the score function to request/accept neighbors.</li>
</ol>
<p>The score between two nodes is measured through the score function <em>s</em>, defined by:</p>
<p>s(nodeID1, nodeID2, salt) = hash(nodeID1 || nodeID2 || salt), where:</p>
<ul>
<li><code>nodeID1</code> and <code>nodeID2</code> are the identities of the considered nodes.</li>
<li><code>salt</code> is the salt value that can be private or public depending on the peering direction (inbound/outbound).</li>
<li><code>hash</code> is the <code>blake2b</code> hash function.</li>
<li><code>||</code> is the concatanation operation.</li>
</ul>
<p>Note that the value used as the score is an unsigned integer derived from the first 4 bytes of the byte array after the <code>hash</code> function.</p>
<p>In order to connect to new neighbors, each node with ID <code>ownID</code> and public salt <code>pubSalt</code> keeps a list of potential neighbors derived via <a href="3.4%20Neighbor%20Selection.html#Mana_rank">Mana rank</a> that is sorted by their score <code>d(ownID, , pubSalt)</code>. Then, the node shall send peering requests in <em>ascending order</em>, containing its own current public salt and a timestamp representing the issuance time of the request. 
The connecting node shall repeat this process until it has established connections to enough neighbors or it finds closer peers. Those neighbors make up its list of chosen neighbors. This entire process is also illustrated in the following pseudocode:</p>
<pre><code>Inputs: 
    k: desired amount of neighbors; 
    c: current list of chosen neighbors; 
    p: list of potential peers;
    localID: local nodeID 
    pubSalt: local public salt;
</code></pre>
<pre><code class="language-vbnet">pSorted = SortByScoreAsc(P, localID, pubSalt)
FOR p IN pSorted
    peeringRequest = SendPeeringRequest(p)
    IF peeringRequest.accepted 
        Append(c, p)
        IF Len(c) == Ceil(k/2) 
            RETURN
</code></pre>
<p>More specifically, after sending a peering request a node <em>shall</em>:</p>
<ul>
<li>wait to get a <a href="3.4%20Neighbor%20Selection.html#Peering_Response">Peering Response</a> that could be positive or negative. 
<ul>
<li>If positive, add the peer to its chosen neighbor list</li>
<li>If negative, filter out the peer from future requests until the next salt update or the end of the list of potential neighbors is reached.</li>
<li>If after <code>responseTimeout</code> no response is received, try again for a fixed <code>maxPeeringAttempts</code>. If not successful, filter out the peer from future requests until the next salt update or the end of the list of potential neighbors is reached.</li>
</ul>
</li>
</ul>
<p>Similar to the previous case, in order to accept neighbors, every node with ID ownID <em>shall</em> generate a private salt <code>privSalt</code>.</p>
<p>Upon reception of a <a href="3.4%20Neighbor%20Selection.html#Peering_Request">Peering Request</a>, a peer <em>shall</em> make a decision to accept, reject or discard the request by:</p>
<ul>
<li>verifying that the signature of the <a href="3.4%20Neighbor%20Selection.html#Peering_Request">Peering Request</a> is valid and discard the request otherwise;</li>
<li>checking that the <code>timestamp</code> field is valid (i.e., not older than a given threshold <code>requestExpirationTime</code> specified by the node) and discard the request otherwise;</li>
<li>checking that the <em>mana</em> of the requester peer is within the own <a href="3.4%20Neighbor%20Selection.html#Mana_rank">Mana rank</a> and send back a <em>negative</em> <a href="3.4%20Neighbor%20Selection.html#Peering_Response">Peering Response</a> otherwise;</li>
<li>checking that the requestor salt matches its hash chain by:
<ul>
<li>taking the difference between the timestamp of the peering request and the time the initial salt was set, and then dividing this number by <code>saltUpdateInterval</code>, rounding down;</li>
<li>hashing the requester public salt as many times as the number of salt changes;</li>
<li>finally, if the result does not match the initial salt, discard the peering request;</li>
</ul>
</li>
<li>applying a statistical test to the request defined as <em>s(remoteID, ownID, _remote) &lt; </em> for a fixed threshold , and discard it otherwise; 
<ul>
<li>this test determines the effectiveness of the brute force attack when an attacker tries to establish a connection with a desired peer;</li>
<li>with  set to 0.01 an attacker has only 1% of chance of being successful;</li>
</ul>
</li>
<li>accept the peering request by sending back a <em>positive</em> <a href="3.4%20Neighbor%20Selection.html#Peering_Response">Peering Response</a> if either one of the following conditions is satisfied, and send back a <em>negative</em> <a href="3.4%20Neighbor%20Selection.html#Peering_Response">Peering Response</a> otherwise:
<ul>
<li>the current size of the accepted neighbors list is smaller than <em>Floor(k/2)</em>; </li>
<li>the score defined as <em>s(ownID, remoteID, privSalt)</em> is lower than the current highest score among accepted neighbors. In this case, send a <a href="3.4%20Neighbor%20Selection.html#Peering_Drop">Peering Drop</a> to drop the accepted neighbor with the highest score replaced by the requester peer. </li>
</ul>
</li>
</ul>
<h3 id="3436-neighbor-removal"><a class="header" href="#3436-neighbor-removal">3.4.3.6 Neighbor Removal</a></h3>
<p>Neighbor removal can occur for several reasons:</p>
<ul>
<li>A node is replacing a neighbor with a better (in terms of score function) one;</li>
<li>From the gossip layer, the connection with a neighbor is lost;</li>
<li>If some form of reputation or bad behavior is being monitored, a neighbor could be dropped in case of misbehavior. For example, a node could respond to the peering request but choose not to gossip received messages.</li>
</ul>
<p>Independently from the reason, when a peer drops a neighbor <em>shall</em> send a <a href="3.4%20Neighbor%20Selection.html#Peering_Drop">Peering Drop</a> and remove the neighbor from its requested/accepted neighbor list. Upon reception of a <a href="3.4%20Neighbor%20Selection.html#Peering_Drop">Peering Drop</a>, the peer <em>shall</em> remove the dropping neighbor from its requested/accepted neighbor list.</p>
<h3 id="3437-requests-and-responses"><a class="header" href="#3437-requests-and-responses">3.4.3.7 Requests and responses</a></h3>
<p>Each <em>peering request, response, drop</em> <em>shall</em> be encapsulated into a <code>data</code> field of a generic <code>Request</code> and <code>Response</code>. Its <code>type</code> <em>shall</em> be specified in the <code>type</code> field and signed with the ed25519 private key of the sender's <a href="3.4%20Neighbor%20Selection.html#Node_identities">identity</a> and contain the related public key to allow the receiver to verify the signature. All the received <em>peering request, response, drop</em> <em>shall</em> be verified and those with invalid signatures be discarded.</p>
<h4 id="request-and-response-layout-1"><a class="header" href="#request-and-response-layout-1">Request and Response Layout</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>type</td>
         <td>uint8</td>
         <td>Defines the type of the request or response.</td>
     </tr>
     <tr>
         <td>data</td>
         <td>ByteArray</td>
         <td>Contains the payload of the request or response (e.g., a PeeringRequest).</td>
     </tr>
     <tr>
         <td>public_key</td>
         <td>ByteArray[32]</td>
         <td>The ed25519 public key of the peer's identity used to verify its signatures.</td>
     </tr>
     <tr>
         <td>signature</td>
         <td>ByteArray[32]</td>
         <td>The ed25519 signature of the `data` field, signed by using the private key of the peer's identity.</td>
     </tr>
 </table>
<h4 id="peering-request"><a class="header" href="#peering-request">Peering Request</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>timestamp</td>
         <td>time</td>
         <td>The unix timestamp of the PeeringRequest.</td>
     </tr>
     <tr>
         <td>salt</td>
         <td>ByteArray[20]</td>
         <td>The public salt of the requester.</td>
     </tr>
 </table>
<h4 id="peering-response"><a class="header" href="#peering-response">Peering Response</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>req_hash</td>
         <td>ByteArray[32]</td>
         <td>The blake2b digest of the corresponding received PeeringRequest.</td>
     </tr>
     <tr>
         <td>status</td>
         <td>bool</td>
         <td>The response (true or false) of the PeeringRequest.</td>
     </tr>
 </table>
<h4 id="peering-drop"><a class="header" href="#peering-drop">Peering Drop</a></h4>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>timestamp</td>
         <td>time</td>
         <td>The unix timestamp of the drop.</td>
     </tr>
 </table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="41-the-tangle"><a class="header" href="#41-the-tangle">4.1 The Tangle</a></h1>
<p>This specification describes the data structure used in the IOTA protocol, and introduces its main terminology.</p>
<h2 id="411-description"><a class="header" href="#411-description">4.1.1 Description</a></h2>
<p>The Tangle represents a growing partially-ordered set of messages, linked with each other through cryptographic primitives, and replicated to all nodes in the peer-to-peer network. The Tangle enables the possibility to store data and to keep a ledger, the latter being based on UTXO-DAG formed by transactions contained in messages.</p>
<p>In mathematical terms, the Tangle is a Directed Acyclic (multi)Graph with messages as vertices and directed edges as references to existing messages.
Directed edges are labelled: \(0\) represents direct references flagged as <em>weak</em>, and \(1\) represents direct references flagged as <em>strong</em> (see <a href="./6.4%20Finalization.html">Section 6.4 - Finalization</a>. Messages are linked with each other through cryptographic hashes.
The acyclicity condition means that there is no directed cycle composed of weak or strong edges.</p>
<h2 id="412-definitions"><a class="header" href="#412-definitions">4.1.2 Definitions</a></h2>
<p>In this section we provide some useful terminology which is useful to understand the basic elements of the protocol.</p>
<h3 id="4121-approval-switch"><a class="header" href="#4121-approval-switch">4.1.2.1 Approval switch</a></h3>
<p>Here we present the set of rules, called <em>approval switch</em>, which allow nodes to alternatively approve single messages or the entire past cone of a message.</p>
<ul>
<li>
<p><strong>Parent</strong>: The protocol requires that each message contains a field <code>parents</code> in order to guarantee cryptographic references among messages in the Tangle. These references can be of two types, <em>strong</em> and <em>weak</em>, and are defined by the field <code>parents type</code>. Intuitively, we say that \(y\) is a <em>strong</em> (resp. <em>weak</em>) <em>parent</em> of a message \(x\) if \(x\) has a directed strong (resp. weak) edge to \(y\). Each message has a possible number of parents from 2 to 8 with repetitions (with 2 as a default value), where at least one is a strong parent. More information about parents can be found in <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message layout</a>.</p>
</li>
<li>
<p><strong>Approvers</strong>: A message \(x\) <em>directly approves</em> \(y\) if \(y\) is a parent of \(x\). Moreover, \(x\) is a <em>strong</em> (resp. <em>weak</em>) <em>approver</em> of \(y\) if \(y\) is a strong (resp. weak) parent of \(x\). More generally, we say that a message \(x\) <em>strongly approves</em> \(y\) if there is a directed path of strong approvals from \(x\) to \(y\), and \(x\) <em>weakly approves</em> \(y\) if there is a directed path of approvals of any type from \(x\) to \(y\).</p>
</li>
<li>
<p><strong>Past cone</strong>: We say that the <em>(strong) past cone</em> of \(x\) is the set of all messages strongly approved by \(x\), and the <em>weak past cone</em> of \(x\) is the set of all messages weakly or strongly approved by \(x\). </p>
</li>
<li>
<p><strong>Future cone</strong>: We define the <em>future cone</em> of a message \(x\) as the set of messages that weakly or strongly approve \(x\). Please note that, unlike its past cone, the future cone of a message changes over time.</p>
</li>
<li>
<p><strong>Genesis</strong>: The genesis is the message that creates the entire token supply. Note that this implies that no other tokens will ever be created or, equivalently, no mining occurs. This message has no outgoing edges and is in the weak past cone of every other message.</p>
</li>
</ul>
<p>In short, strong approvals are equivalent to the approvals in the legacy IOTA: if \(x\) strongly approves \(y\), it approves also \(y\)'s past cone. Moreover, weak approvals emulate the <a href="https://github.com/iotaledger/protocol-rfcs/blob/master/text/0005-white-flag/0005-white-flag.md">White Flag</a> approach from Chrysalis: approving a message does not necessarily approve its past cone. This feature allows, for instance, two conflicting messages to be part of the Tangle without creating unmergeable branches.</p>
<h3 id="4122-validity"><a class="header" href="#4122-validity">4.1.2.2 Validity</a></h3>
<p>This subsection introduces the definitions of validity for transactions and messages.</p>
<ul>
<li>
<p><strong>(Transaction) Validity</strong>: A transaction is valid if it passes the syntactical filter and its references are valid (see <a href="./2.3%20Standard%20Payloads%20Layout.html">Section 2.3 - Payloads Layout</a> for information):</p>
<ul>
<li>It is syntactically correct.</li>
<li>Unblock conditions are met (see <a href="./5.1%20UTXO.html">Section 5.1 - UTXO</a> for further information).</li>
<li>Balances are zero, i.e., the sum of the inputs in the transaction's payload is equal to the sum of the outputs spent.</li>
<li>No conflicts in the past cone on the UTXO DAG (two transactions <em>conflict</em> if they consume the same UTXO output).</li>
</ul>
</li>
<li>
<p><strong>(Message) Individual Validity</strong>: A message is considered individually valid if it passes all the objective filters, i.e. the ones included in the Message Parser (see <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>):</p>
<ul>
<li>It is syntactically correct.</li>
<li>Its signature is valid.</li>
<li>Its Proof of Work is correct.</li>
</ul>
</li>
<li>
<p><strong>(Message) Weak Validity</strong>: A message is weakly valid if:</p>
<ul>
<li>Its Individually Valid.</li>
<li>Its parents are weakly valid.</li>
<li>Its transaction is valid.</li>
<li>It passes the Parent Age Check.</li>
</ul>
</li>
<li>
<p><strong>(Message) Strong Validity</strong>: A message is strongly valid if:</p>
<ul>
<li>It is weakly valid.</li>
<li>Its strong parents do not have a conflicting past.</li>
<li>Its strong parents are strongly valid.</li>
</ul>
</li>
</ul>
<h3 id="4123-branches"><a class="header" href="#4123-branches">4.1.2.3 Branches</a></h3>
<p>In the IOTA protocol, multiple version of the ledger state can temporarily coexist. These multiple versions of the ledger state are called <em>branches</em>. As soon as conflicts are detected, new branches are generated where the outputs created by conflicting transactions and those created by transactions that spend these outputs are tracked. If all past conflicts are resolved and no new conflicts are detected, then only one branch will exist. More rigorously, we can refer to a branch as a non-conflicting collection of past cones of outputs in the UTXO DAG. Additional information, as well as the distinction between conflict and aggregated branches, is given in <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger state</a>.</p>
<h3 id="4122-solidification"><a class="header" href="#4122-solidification">4.1.2.2 Solidification</a></h3>
<p>Due to the asynchronicity of the network, we may receive messages for which their past cone has missing elements. We refer to these messages as <em>unsolid</em> messages. It is not possible neither to approve nor to gossip unsolid messages. The actions required to obtain such missing messages is called <em>solidification procedure</em>, and are described in detail in <a href="./4.4%20Solidification.html">Section 4.4 - Solidification</a>.</p>
<h2 id="413-example"><a class="header" href="#413-example">4.1.3 Example</a></h2>
<p>Image 4.1.1 shows an example of the Tangle (strong edges are with a continuous line, weak edges are with a dotted line). Message \(D\) contains a transaction that has been rejected. Thus, in the legacy IOTA implementation, its future cone would be orphaned due to the monotonicity rule. In particular, both messages \(E\) (data) and \(F\) (transaction) directly reference \(D\). In IOTA 2.0, the introduction of the approval switch allows that these messages can be picked up via a weak approval, as messages \(G\) and \(H\) exemplify.</p>
<p><img src="https://imgur.com/Rv1zXFI.png" alt="" /></p>
<p><em>Image 4.1.1 - Example of the IOTA Tangle</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="42-timestamps"><a class="header" href="#42-timestamps">4.2 Timestamps</a></h1>
<h2 id="421-motivation"><a class="header" href="#421-motivation">4.2.1 Motivation</a></h2>
<p>In order to enable snapshotting based on time constraints rather than special messages in the Tangle (e.g. checkpoints), nodes need to share the same perception of time. Specifically, they need to have consensus on the <em>age of messages</em>. This is one of the reasons that messages must contain a field <code>timestamp</code> which represents the creation time of the message and is signed by the issuing node. </p>
<p>Having consensus on the creation time of messages enables not only total ordering but also new applications that require certain guarantees regarding time. Specifically, we use message timestamps to enforce timestamps in transactions, which may also be used in computing the Mana associated to a particular node ID. </p>
<p>In this document, we propose a mechanism to achieve consensus on message timestamps by combining a synchronous and an asynchronous approach. While online nodes may leverage FPC to vote on timestamps, nodes that join the network at a later time use an approach based on the <em>approval weight</em> (described in <a href="./6.4%20Finalization.html">Section 6.4 - Approval Weight and Finality</a>) to determine the validity of timestamps. </p>
<p>This specification also outlines a tool called &quot;Epochs&quot;, which groups messages into different objective periods.  This tool may be used for the following purposes:</p>
<ul>
<li><strong>finality and approval weight:</strong>  the activity of certain nodes within an epoch can be recorded, and then the approval weight (i.e. the number of nodes, weighted by consensus, which issued a message referencing a particular message) can then be measured as a percentage of &quot;active consensus mana&quot;.</li>
<li><strong>committee selection:</strong> a committee elected as the highest active consensus mana holders can be easily and objectively formed for the DRNG committee. </li>
</ul>
<h2 id="422-preliminaries"><a class="header" href="#422-preliminaries">4.2.2 Preliminaries</a></h2>
<h3 id="4221-requirements"><a class="header" href="#4221-requirements">4.2.2.1 Requirements</a></h3>
<p>In DLTs, there are many ways to potentially introduce timestamps.  Any useful timestamping scheme however must satisfy the following requirements.</p>
<ol>
<li>Nodes must have consensus on the timestamp associated to each message.</li>
<li>For every time <code>t</code>, there is a <code>t_1&gt;t</code> such that any new message issued with timestamp <code>t</code> and received by a node after <code>t_1</code> (measured by its local clock) will be considered too far in the past and will be orphaned. </li>
</ol>
<h3 id="4222-dependencies"><a class="header" href="#4222-dependencies">4.2.2.2 Dependencies</a></h3>
<ul>
<li>Opinion Setting</li>
<li>FPC: used to perform voting on timestamps.</li>
<li>Approval weight: corrects opinions on timestamps when out of sync.</li>
</ul>
<h3 id="4233-modules-dependent-on-timestamps"><a class="header" href="#4233-modules-dependent-on-timestamps">4.2.3.3 Modules dependent on timestamps</a></h3>
<ul>
<li>Tip selection: only messages with correct timestamps will be eligible for tip selection.</li>
<li>Active Consensus Mana in approval weight uses epochs.</li>
<li>DRNG uses Epochs.</li>
<li>The Congestion control orders messages by timestamps, and only processes messages whose timestamp is close to the current time.</li>
<li>The rate control system uses timestamps to compute the correct PoWs.</li>
<li>The snapshotting uses timestamps to determine which messages to prune from the tangle.</li>
</ul>
<h3 id="4224-parameters"><a class="header" href="#4224-parameters">4.2.2.4 Parameters</a></h3>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>DLARGE</code></td><td>duration</td><td>Gratuitous network delay estimate~ 15 s</td></tr>
<tr><td><code>W</code></td><td>duration</td><td>window ~1 minute. Require W&gt;2DLARGE</td></tr>
<tr><td><code>DELTA</code></td><td>duration</td><td>Maximal difference between a message timestamp and its parents' message timestamp. Require DELTA&gt;W+DLARGE</td></tr>
<tr><td><code>TW</code></td><td>duration</td><td>Maximal difference between message timestamp and transaction timestamp</td></tr>
<tr><td><code>EPOCHLENGTH</code></td><td>duration</td><td>Length of each epoch = 1 hour</td></tr>
<tr><td><code>SYNCH_THRESHOLD</code></td><td>duration</td><td>the max difference between <code>CurrentTime</code> and <code>TangleTime</code> in which we consider our node in sync</td></tr>
<tr><td><code>TIMESTAMP_CUTOFF</code></td><td>duration</td><td>messages with timestamp older than this will be disliked with level 3 knowledge</td></tr>
</tbody></table>
<h3 id="4225-clock-synchronization"><a class="header" href="#4225-clock-synchronization">4.2.2.5 Clock synchronization</a></h3>
<p>Nodes need to share a reasonably similar perception of time in order to effectively judge the accuracy of timestamps. Therefore, we propose that nodes synchronize their clock on startup and resynchronize periodically every <code>60min</code> to counter <a href="https://en.wikipedia.org/wiki/Clock_drift">drift</a> of local clocks. Instead of changing a nodes' system clock, we introduce an <code>offset</code> parameter to adjust for differences between <em>network time</em> and local time of a node. Initially, the <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">Network Time Protocol (NTP)</a> (<a href="https://github.com/beevik/ntp">Go implementation</a>) may be used to achieve this task. </p>
<p>We gracefully shut down the node if:</p>
<ul>
<li>initial synchronization of time fails</li>
<li>resynchronization fails for more than <code>maxSyncAttempts</code> times </li>
</ul>
<h2 id="423-general-timestamp-rules"><a class="header" href="#423-general-timestamp-rules">4.2.3 General Timestamp rules</a></h2>
<p>Every message contains a timestamp, which is signed by the issuing node.  Thus the timestamp itself is objective and immutable.  Furthermore, transactions will also contain a timestamp, which will be also signed and thus immutable.  We first discuss the rules regarding message timestamps.</p>
<p>In order for a message to be eligible for tip selection, the timestamp of every message in its past cone (both weak and strong) must satisfy certain requirements. These requirements fall into two categories: objective and subjective. The objective criteria only depend on information written directly in the Tangle and are applied immediately upon solidification.  Thus all nodes immediately have consensus on the objective criteria.  In this section, we will discuss these objective criteria.</p>
<p>The quality of the timestamp is a subjective criterion since it is based on the solidification time of the message.  Thus, nodes must use a consensus algorithm, e.g. FPC, to decide which messages should be rejected based on subjective criteria. Specifically, nodes will use FPC to vote on whether or not a timestamp plus <code>W</code> is before the arrival time. </p>
<p>Consensus matters are not discussed in this document: see sections <a href="./6.1%20Objects%20of%20Consensus.html">6.1</a>, <a href="./6.2%20Opinion%20Setting.html">6.2</a> and <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">6.3</a> to discuss how FPC votes on timestamps. </p>
<p>Lastly, for any time <code>t</code>, a node is sure that it has received all the messages with timestamp less than <code>t</code> which will be finalized when
+ <code>CurrentTime &gt;= t + TIMESTAMP_CUTOFF = t + W + 2*DLARGE</code>, i.e. wait ~1.5 minutes
+ <code>SyncStatus = TRUE</code>
Indeed, after <code>TIMESTAMP_CUTOFF = W + 2*DLARGE</code> all messages which arrive will be considered bad with level of knowledge 3: see <a href="/6.1%20Objects%20of%20Consensus.html">Section 6.1 - Object of Consensus</a>. If the node is in sync, then it will have received all old messages which will be confirmed. </p>
<h3 id="4231-age-of-parents"><a class="header" href="#4231-age-of-parents">4.2.3.1 Age of parents</a></h3>
<p>It is problematic when incoming messages reference extremely old messages. If any new message may reference any message in the Tangle, then a node will need to keep all messages readily available, precluding snapshotting. For this reason, we require that the difference between the timestamp of a message and the timestamp of its parents must be at most <code>DELTA</code> units of time. Additionally, we require that timestamps are monotonic, i.e. parents must have a timestamp smaller than their children's timestamps.</p>
<h3 id="4232-message-timestamp-vs-transaction-timestamp"><a class="header" href="#4232-message-timestamp-vs-transaction-timestamp">4.2.3.2 Message timestamp vs transaction timestamp</a></h3>
<p>Transactions contain a timestamp that is signed by the user when creating the transaction. It is thus different from the timestamp in the message which is created and signed by the node. We require </p>
<pre><code>transaction.timestamp+TW &gt;= message.timestamp &gt;= transaction.timestamp
</code></pre>
<p>where <code>TW</code> defines the maximum allowed difference between both timestamps.</p>
<p>If a node receives a transaction from a user with an invalid timestamp it does not create a message but discards the transaction with a corresponding error message to the user. To prevent a user's local clock differences causing issues the node should offer an API endpoint to retrieve its <code>SyncedTime</code> according to the network time. </p>
<h3 id="4233-reattachments"><a class="header" href="#4233-reattachments">4.2.3.3 Reattachments</a></h3>
<p>Reattachments of a transaction are possible during the time window <code>TW</code>. Specifically, a transaction may be reattached in a new message as long as the condition <code>message.timestamp-TW &gt;= transaction.timestamp</code> is fulfilled. If for some reason a transaction is not <em>picked up</em> (even after reattachment) and thus being orphaned, the user needs to create a new transaction with a current timestamp. </p>
<h3 id="4234-age-of-utxo"><a class="header" href="#4234-age-of-utxo">4.2.3.4 Age of UTXO</a></h3>
<p>Inputs to a transaction (unspent outputs) inherit their spent time from the transaction timestamp. Similarly, unspent outputs inherit their creation time from the transaction timestamp as well. For a transaction to be considered valid we require</p>
<pre><code>transaction.timestamp &gt;= inputs.timestamp
</code></pre>
<p>In other words, all inputs to a transaction need to have a smaller or equal timestamp than the transaction. In turn, all created unspent outputs will have a greater or equal timestamp than all inputs.</p>
<h2 id="424-consensus-on-timestamps"><a class="header" href="#424-consensus-on-timestamps">4.2.4 Consensus on timestamps</a></h2>
<p>The accuracy of the timestamps will be enforced through FPC voting.  Specifically, FPC will allow nodes to come to consensus on whether or not <code>timestamp+W</code> is greater than the arrival time: see <a href="./6.2%20Opinion%20Setting.html">Section 6.2 - Opinion Setting</a>. Messages which are deemed to fail this criterion will be rejected. Messages whose entire past cone is both valid, and satisfies this criterion, will be flagged as <code>eligible</code> and can be referenced messages selected by the Tip Selection Algorithm: see <a href="./4.3%20Tip%20Selection%20Algorithm.html">Section 4.3 - Tip Selection Algorithm</a>.</p>
<h3 id="4241-not-in-sync"><a class="header" href="#4241-not-in-sync">4.2.4.1 Not in Sync</a></h3>
<p>Any node not in sync will receive messages much later than the rest of the network.  Thus, all messages will appear to have inaccurate timestamps and will be wrongfully rejected by the algorithms in <a href="./6.2%20Opinion%20Setting.html">Section 6.2 - Opinion Setting</a>. Thus nodes will not actively participate in any voting until their status is in sync, see Section 4.2.5. </p>
<p>In general, a node that just completed the syncing phase must check, for each message, how much mana is in its future cone and set the opinion accordingly.</p>
<p>More specifically:</p>
<ol>
<li>Run the solidification up to being in sync (by following beacons)</li>
<li>Derive local markers</li>
<li>Decide eligibility for every message (5-10% mana min threshold)</li>
</ol>
<p>Clearly this synchronization procedure may only work to make an apparently bad timestamp reset to be a good timestamp.  For example, if a node receives a message one day later than the rest of the network, the node will initially reject the timestamp. However, the resync mechanism will recognize the message is correct because it is buried under an entire day's worth of messages. </p>
<p>What about the converse situation? Being out of sync will only delay the arrival of a message.  If a node receives a message with a timestamp satisfying <code>timestamp+W&gt;arrivalTime</code>, this condition would also be satisfied for all nodes which received the message earlier.  Thus, if a node is out of sync and is receiving messages later than everyone else, if this node likes a timestamp, all other notes will have already liked it. Therefore, nodes will not like timestamps which were previously rejected by most of the network.</p>
<h3 id="4242-future-timestamps"><a class="header" href="#4242-future-timestamps">4.2.4.2 Future Timestamps</a></h3>
<p>Note that the resync mechanism only works because we only dislike a message if it is too old.  If we disliked messages whose timestamps were in the future, then it is possible that some nodes would like it, and others disliked it.  Suppose for example at 11:00:00 a node issues a message <code>X</code> with timestamp 12:00:00, and that then all nodes rejected this timestamp for being too far in the future.  Now suppose at 12:00:00 a new node <code>N</code> joins the network at receives <code>X</code>.  According to node <code>N</code>, the timestamp of <code>X</code> is accurate, and will accept it, while other nodes will reject it.  The resynchronization mechanism fails in this case.</p>
<p>To protect against messages with a timestamp that is issued in the future, the <a href="./4.6%20Congestion%20Control.html">congestion control algorithm</a> does not schedule the message until the timestamp is less than or equal to <code>CurrentTime</code>. Thus messages from the future will not be added to the Tangle until the appropriate time. If an attacker sends too many future messages, these messages may overload the scheduler's queues. However, this is a standard type of attack that the congestion control algorithm is prepared to handle.</p>
<h2 id="425-tangle-time"><a class="header" href="#425-tangle-time">4.2.5 Tangle Time</a></h2>
<h3 id="4251-motivation"><a class="header" href="#4251-motivation">4.2.5.1 Motivation</a></h3>
<p>For a variety of reasons, a node needs to be able to determine if it is in sync with the rest of the network, including the following:
+ to signal to clients that its perception is healthy,
+ to know when to issue messages (nodes out of sync should not issue messages, lest they are added to the wrong part of the Tangle),
+ to schedule messages at the correct rate: out of sync nodes should schedule faster in order to catch up with the network,
+  and to optimize FPC: nodes should not query while syncing, but instead rely on the approval weight. </p>
<h3 id="4252-tangle-time"><a class="header" href="#4252-tangle-time">4.2.5.2 Tangle Time</a></h3>
<p>Every DLT is a clock, or more specifically a network of synchronized clocks. This clock has a natural correspondence with &quot;real time&quot;. If the DLT clock differs significantly from local time, then the we can conclude that our DLT clock is off from all the other clocks, and thus the node is out of sync.</p>
<p>For IOTA 2.0, we make precise the meaning of the DLT clock with what we dub &quot;Tangle time&quot;.</p>
<pre><code class="language-vbnet">FUNCTION Time = TangleTime
 RETURN largest timestamp of all grade 3 final messages
</code></pre>
<p>Thus Tangle time is the last timestamp in a message which was been confirmed. Tangle time cannot be attacked without controlling enough mana to accept incorrect timestamps, making it a reliable, attack-resistant quantity.</p>
<p>Typically speaking, <code>CurrentTime - TangleTime</code> is, on average, the  approximate confirmation time of messages.  Thus, if this difference is too far off, then we can conclude that we do not know which messages are confirmed and thus we are out of sync.  In this spirit, we are able to define the following two functions. </p>
<pre><code class="language-vbnet">FUNCTION Time = SyncAmount
RETURN CurrentTime - TangleTime
</code></pre>
<pre><code class="language-vbnet">FUNCTION bool = SyncStatus
IF SyncAmount &lt;= SYNCH_THRESHOLD
    RETURN TRUE
ELSE
    RETURN FALSE
</code></pre>
<p><img src="https://i.imgur.com/rndN8qc.jpg" alt="" /></p>
<h2 id="426-epochs"><a class="header" href="#426-epochs">4.2.6 Epochs</a></h2>
<p>Epochs are universal time intervals that group messages in the Tangle based on their timestamps.</p>
<ul>
<li>An epoch is identified by its unique epoch index. Epoch indices are strictly increasing with respect to time.</li>
<li>Every time interval <code>EPOCHLENGTH</code>, a new epoch is started and the previous ends.</li>
<li>A message <code>M</code> or a transaction belongs to an <code>Epoch X</code>, if its timestamp falls into the time window of 
<code>Epoch X</code> such that T(<code>M</code>) [t<sub>X-1</sub>, t<sub>X</sub>), where
<ul>
<li>T(<code>M</code>) is the timestamp of message <code>M</code>,</li>
<li>t<sub>x-1</sub> is the end of the previous epoch,</li>
<li>and t<sub>x</sub> is the end of <code>Epoch X</code>.</li>
</ul>
</li>
<li>A transaction might not be in the same epoch as the message containing it. </li>
<li>The start of the network corresponds to t<sub>1</sub>, that is the end of <code>Epoch 1</code>.</li>
<li><code>Epoch 0</code> and <code>Epoch 1</code> are special epochs, since they only contain the genesis message(s), and their content is defined before starting the network. These two epochs might be used to initialize the network and active consensus mana states to a desired values.</li>
<li>For every network, the end of <code>Epoch 0</code> is defined as an arbitrary point in time, similarly to how <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch time</a> is defined as 00:00:00 UTC on 1 January 1970.</li>
<li>Epoch interval <code>EPOCHLENGTH</code> cannot be chosen arbitrarily: it must be much larger than <code>DELTA</code>.  Furthermore, short epochs can potentially cause make certain calculations involving the approval wait more complicated.</li>
</ul>
<p>Figure 1 gives a brief overview of how the Tangle is divided into epochs:</p>
<p><img src="https://i.imgur.com/5mZYAO8.png" alt="" /></p>
<p><code>Epoch 0</code> contains the genesis message(s), that hold the genesis output(s). By allowing multiple outputs to exist before the start of the network, a desired initial state for the network can be set.
<code>Epoch 2</code> is the first epoch after the start of the network, when nodes may start issuing messages. Note, that a message can be valid with one strong parent only.</p>
<p>Upon processing a message and verifying its timestamp as described in <a href="./6.2%20Opinion%20Setting.html">Opinion Setting Specification</a>, the message is solidified and can be added to the epoch. 
<code>Epoch 2</code> ends at t<sub>2</sub>, but it can happen that a message is issued just before t<sub>2</sub>, therefore it reaches most nodes and gets solidified during <code>Epoch 3</code>. In this case, the node can still determine the correct epoch the message belongs to due to the consensus on the message timestamp. This also means, that finalizing an epoch (declaring that no more messages can be added to it) is delayed after the end of the epoch by at least <code>W</code> time.</p>
<h2 id="426-limitations"><a class="header" href="#426-limitations">4.2.6 Limitations</a></h2>
<ul>
<li>When not in sync, a different behavior is required which complicates the protocol.</li>
<li>Using NTP as clock synchronization mechanism as proposed is a single point of failure. It can only be considered as an initial implementation into GoShimmer and needs to be replaced by a decentralized alternative.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="43-tip-selection-algorithm"><a class="header" href="#43-tip-selection-algorithm">4.3 Tip Selection Algorithm</a></h1>
<h2 id="431-introduction"><a class="header" href="#431-introduction">4.3.1 Introduction</a></h2>
<p>The tip selection algorithm is the method by which messages are selected for approval by other issued messages joining the network.  This approval mechanism represents belief in the Tangle: If message \(y\) approves message \(x\), this implies that the node issuing \(y\) believes that \(x\), and possibly its past cone, are &quot;good&quot;. </p>
<p>The tip selection algorithm allows the Tangle to grow in a stable and secure way, with quick approval and finality times. </p>
<p>We call the new Tip-Section algorithm &quot;R-URTS&quot;, which means &quot;Restricted Uniform Random Tip Selection&quot;. Here we summarize the main differences that the new Tip Selection Algorithm has, compared to the legacy version:</p>
<ol>
<li><strong>Uniform Selection:</strong> Unlike the old Random Walk tip selection, we will use a much faster and simpler solution that will select uniformly among a subset of eligible tips. </li>
<li><strong>Approval Switch Mechanism:</strong> A new mechanism that will allow us to keep a clear Tangle while preventing orphanage from splits due to disliked branches. </li>
</ol>
<p>Although we will not be using here, the new message layout (more information in <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message Layout</a>) has the capabilities for a message to have a non-fixed number of messages that it approves (parents), which range from two to eight (see <a href="./4.8%20Message%20Creation.html">Section 4.8 - Message Creation</a>). This can be used to develop tip spam protection mechanisms among other purposes. We will denote the number of parents being used in the algorithm by <em>Parental Number</em>. </p>
<h2 id="432-definitions"><a class="header" href="#432-definitions">4.3.2 Definitions</a></h2>
<p>One of the main improvements of the new Tip Selection Algorithm comes from its ability to keep both a clean non-conflicting subtangle, as well as to ignore the existence of conflicts in its selection, hence emulating the ability that <a href="https://github.com/iotaledger/protocol-rfcs/blob/master/text/0005-white-flag/0005-white-flag.md">Chrysalis White Flag</a> approach has of being unsplittable. In IOTA 2.0, those properties come from the approval switch mechanism. In the rest of this subsection, we present the theory of the approval switch, which classify approvals and messages in &quot;weak&quot; and &quot;strong&quot;. This information is necessary to define the <em>tip pools</em>, i.e., the sets of (recent) messages which are selectable by the Tip Selection Algorithm (we provide a more complete description of tip pools later in this document).</p>
<h3 id="4321-approval-switch"><a class="header" href="#4321-approval-switch">4.3.2.1 Approval switch</a></h3>
<p>In order to properly define and explain the approval switch mechanism, we will need some extra defintions. We also refer to the basic concept of branches (<a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>) and validity (<a href="./4.1%20The%20Tangle.html">Section 4.1 - The Tangle</a>), as they are required to the understanding of some of the definitions below.</p>
<ul>
<li>
<p><strong>Tip</strong>: A message is considered a tip (by a node) if it is selectable by the Tip Selection Algorithm, i.e. it is an element of any <em>Tip Pool</em> (of that node). In general, it is perceived as a message that has yet to receive any direct approvers.</p>
</li>
<li>
<p><strong>Eligibility</strong>: A Message is said <em>eligible</em> if:</p>
<ul>
<li>It is weakly valid;</li>
<li>It passes the timestamp check with level of knowledge at least 2;</li>
<li>All its parents are also eligible messages.</li>
</ul>
</li>
<li>
<p><strong>Approval switch</strong>: : A binary field with values <strong>strong</strong> and <strong>weak</strong>  in the message associated with each of its parents, filled by its issuer node. </p>
<ul>
<li><strong>Strong approval</strong>:  Represents that the issuer node declares that the message and its entire past cone are liked. </li>
<li><strong>Weak approval</strong>:  Represents that the issuer node declares that the message and its payload is liked, but its past cone is not completely liked. </li>
</ul>
</li>
</ul>
<h3 id="4322-branch"><a class="header" href="#4322-branch">4.3.2.2 Branch</a></h3>
<p>Furthermore, to properly define the tip pool, additional definitions derived by the branch are required. Here we give a summarized definition for the sake of understanding. </p>
<ul>
<li>
<p><strong>Monotonically Liked Branch</strong>: A branch is monotonically liked if all of its transactions are individually liked. </p>
</li>
<li>
<p><strong>Monotonically Liked Message</strong>: A message is monotonically liked if its aggregated branch is monotonically liked.</p>
</li>
</ul>
<h3 id="4323-strong-and-weak-messages"><a class="header" href="#4323-strong-and-weak-messages">4.3.2.3 Strong and weak messages</a></h3>
<p>In a heuristic way, one can think of a monotonically liked message as a  message that has a liked payload and that all other payloads that depend on it are also liked. 
With this we can classify the messages: </p>
<ul>
<li>
<p><strong>Strong Messages</strong>: We say a message \(x\) is strong (for a node) if it is:</p>
<ul>
<li>Eligible;</li>
<li>Monotonically liked.</li>
</ul>
</li>
<li>
<p><strong>Weak Messages</strong>: We say a message \(x\) is weak (for a node) it is:</p>
<ul>
<li>Eligible;</li>
<li>Contains a liked payload;</li>
<li>It is not monotonically liked with level of knowledge at least 2. </li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/a9FTyyg.png" alt="" />
<strong>Image X.X.X:</strong> An example of strong and weak parents. Observe that although B is in the past cone of I, it is not in its strong past cone. </p>
<h2 id="433-tip-pools"><a class="header" href="#433-tip-pools">4.3.3 Tip Pools</a></h2>
<p>The tip is a product of the construction of the Tip Pools, and in general it represents messages that are yet to be directly approved by other messages. The tip pools are built by filtering the messages that arrive from the neighbors, checking which ones are proper to be selectable by the algorithm. In this subsection we will define such filters and classifications that are used to make the Tip Pools. </p>
<p>Differently from the legacy implementation, we will not have a single pool, but instead two, divided according to the new concept of the <em>Approval Switch</em> mechanism. </p>
<h3 id="4331-construction-of-the-tip-pools"><a class="header" href="#4331-construction-of-the-tip-pools">4.3.3.1 Construction of the Tip Pools</a></h3>
<p>We will define a sequence of pools, each one selected by filtering the previous one regarding one condition, until we conclude with the two elements used in the Tip Selection Algorithm: the <em>Strong Tips Pool</em> and the <em>Weak Tip Pool</em>. </p>
<ol>
<li>
<p><strong>Eligible Messages Pool:</strong> This pool consists of all messages that were also approved by the <em>Eligibility Check</em> (see <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>).</p>
</li>
<li>
<p><strong>Liked Payload Pool:</strong> This pool consists of all eligible messages that contain a payload tagged as &quot;liked&quot;, i.e. is either data or an individually liked transaction. </p>
</li>
<li>
<p><strong>Strong Tips Pool</strong>: This pool consists of all strong messages in the <em>Liked Payload Pool</em>.</p>
</li>
<li>
<p><strong>Weak Tips Pool</strong>: This pool consists of all messages from the <em>Liked Payload Pool</em> that were not included in the <em>Strong Tips Pool</em>. </p>
</li>
</ol>
<p>The two main pools to be used by the tip selection algorithm are the <em>Strong Tips Pool</em> and the <em>Weak Tips Pool</em>. Observe that from our definition, each pool in the list is always constructed by performing a filtering in the previous one, but how this filtering will be performed is considered an implementation detail and hence will not be further considered here. </p>
<h3 id="4332-update-of-the-tip-pools"><a class="header" href="#4332-update-of-the-tip-pools">4.3.3.2 Update of the tip pools</a></h3>
<p>There are two types of updates that can be done with the strong and weak tip pools:</p>
<ol>
<li><strong>Removal</strong>: Tips are removed when they are approved by other messages. This can happen in two ways:
<ul>
<li>When the node issues a message, the selected tips will be removed from the respective tip pools after the Tip Selection Algorithm is performed (we briefly explain the procedure in the <a href="4.3%20Tip%20Selection%20Algorithm.html#R-URTS">R-URTS</a> subsection, further information may be found in the <a href="./4.8%20Message%20Creation.html">Section 4.8 - Message Creation</a>).</li>
<li>When a new message is received, its parents shall be removed from the respective tip pools by the <em>Tip Manager</em> application (further information may be found in the <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>).</li>
</ul>
</li>
<li><strong>Rearrangement:</strong> Tips can be changed from the strong tip pool to the weak tip pool, or from the weak tip pool to the strong tip pool if the perception of the branches they belong to changes, this is explained in more details in Section 6.5 - Node Peception Reorganization.</li>
</ol>
<!--
## Parental Number
To attach a new transaction to the Tangle, the algorithm needs to select and approve  between two and eight previous messages among a list of tips.
This defined a new variable, represented by \\(k\\), that we will call the *Parental Number*.
The variation on the number of approvals (two to eight)  is there to counteract tip spam during low-congestion periods: A higher number of approvals can merge easier the spammer eligible messages with the tangle, keeping it growing in a healthy way. The standard parental number, \\(k_0\\), is defined as two approvals and used on periods without tips spams. 
The detection and increase in parental number is individual per node, so the whole network does not need to achieve any kind of consensus on this and even if one attacker artificially changes the perception of nodes about spam, it does not creates any harm to the node itself (aside from a low impact on performance), and hence, in the network as a whole. 
### Tip Spam Detection
As part of its standard routines, a node needs to run periodically a spam detection routine `TipSpamDetection`, that will with certain confidence detects if a tip spam is happening and give the appropriate boolean response.  
A positive response from `TipSpamDetection` updates the associated counter metadata `TipSpamAge`, that checks for how many consecutive tests the spam has persisted, while a null answer from it will set  `TipSpamAge`.  Finally, `TipSpamDetection` will update the parental number according to the current value of `TipSpamAge`.
[PLACEHOLDER FOR ROUTINE PSEUDO-ALGORITHM]
-->
<h2 id="434-r-urts"><a class="header" href="#434-r-urts">4.3.4 R-URTS</a></h2>
<p>We want to reiterate here that, ultimately, the tip selection is a free procedure not enforced by the protocol. Therefore each node may, if it sees worth, to select its approvees in a manual way or following another algorithm of its preference. What we will present here is the standard algorithm, that works both as a suggestion but also as something that the nodes will have implemented and will use by default. <!--Another discussion about this may be found in [Game Theory](#Game-Theory). --></p>
<p>The suggested standard tip selection algorithm is R-URTS (Restricted Uniform Random Tip Selection), which selects messages with uniform probability among the list of tips restricted by some condition.</p>
<p>Let us give an example for a Tip Selection Algorithm with Parental Number \(k\):</p>
<ol>
<li>Consider the <em>Strong Tips Pool</em> and the <em>Weak Tip Pools</em> updated. </li>
<li>The node shall select the first tip from the <em>Strong Tips Pool</em>.</li>
<li>The node shall select tips from numbered \(2\) to \(k\) from the union of the <em>Strong Tips Pool</em> and the <em>Weak Tips Pool</em>.</li>
<li>The node shall register in the message's <code>Parents type</code> field if each selected parent was from the strong or weak tip pools.</li>
<li>The node shall remove the selected tips from their respective pools. </li>
</ol>
<!-- #### Pseudo Algorithm -->
<!-- ### Game Theory -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="44-solidification"><a class="header" href="#44-solidification">4.4 Solidification</a></h1>
<p>A message is solid if all its parents are stored, solid and valid. This section defines how messages get solid in the Tangle.</p>
<p>The Solidification specification depends on the following specifications:</p>
<ul>
<li><a href="./4.2%20Timestamps.html">4.2 - Timestamps</a></li>
<li><a href="./5.1%20UTXO.html">5.1 - UTXO</a></li>
</ul>
<h2 id="441-motivation"><a class="header" href="#441-motivation">4.4.1 Motivation</a></h2>
<p><strong>Solidification</strong> is a process of requesting missing referenced messages. It may be recursively repeated until all of a message's past cone up to the genesis (or snapshot) becomes solid.</p>
<p>In that way, the Tangle enables all nodes to retrieve all of a message's history, even the ones joining the network at a point later in time.</p>
<h2 id="442-definitions"><a class="header" href="#442-definitions">4.4.2 Definitions</a></h2>
<ul>
<li><strong>valid</strong>: A message is considered valid if it passes the following filters from the solidifier and from the message booker:
<ul>
<li>solidifier: it checks if parents are valid,</li>
<li>booker: it check if the contained transaction is valid. Notice that only messages containing a transaction are required to perform this check, which are defined in <a href="./5.1%20UTXO.html#validation">Section 5.1 - UTXO</a></li>
</ul>
</li>
<li><strong>parents age check</strong>: A check that ensures the timestamps of parents and child are valid, following the details defined in <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>.</li>
<li><strong>solid</strong>: A message is solid if it passes parents age check and all its parents are stored in the storage, solid and valid.</li>
</ul>
<h2 id="443-parameters"><a class="header" href="#443-parameters">4.4.3 Parameters</a></h2>
<ul>
<li><code>retryInterval</code>: The time interval of resending the same solidification request.</li>
<li><code>maxRequestThreshold</code>: The maximum retry times to send a solidification request.</li>
</ul>
<h2 id="444-detailed-design"><a class="header" href="#444-detailed-design">4.4.4 Detailed Design</a></h2>
<p>During solidification, if a node is missing a referenced message, the corresponding message ID is stored in the <code>solidification buffer</code>. A node asks its neighbors for the missing message by sending a <code>solidification request</code> containing the message ID. Once the requested message is received from its neighbors, its message ID shall be removed from the <code>solidification buffer</code>. The requested message is marked as solid after it passes the standard solidification checks. If any of the checks fails, the message remains unsolid. </p>
<p>If a message gets solid, it shall walk through the rest of the data flow, then propagate the solid status its future cone by performing the solidification checks on each of the message in its future cone again.</p>
<p>Figure 4.4.1 shows the solidification process:</p>
<p><img src="https://user-images.githubusercontent.com/11289354/117009286-28333200-ad1e-11eb-8d0d-186c8d8ce373.png" alt="GoShimmer-flow-solidification_spec" /></p>
<p style="text-align: center;">
    Figure 4.4.1: solidification workflow
</p>
<h2 id="445-communication-details"><a class="header" href="#445-communication-details">4.4.5 Communication details</a></h2>
<p>Nodes send and receive <code>solidification request/response</code> via gossip layer. The <code>solidification request</code> is created and scheduled by the gossip manager, if a node does not get the requested message, the gossip manager resends it every <code>retryInterval</code>. If the requested message is not received within <code>maxRequestThreshold</code> rounds, the <code>solidification request</code> must be removed from the <code>solidification buffer</code>.</p>
<h3 id="4451-request-and-response"><a class="header" href="#4451-request-and-response">4.4.5.1 Request and response</a></h3>
<p>Below we define the form of SolidificationRequest and SolidificationResponse: </p>
<h3 id="solidificationrequest"><a class="header" href="#solidificationrequest">SolidificationRequest</a></h3>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>type</td>
         <td>uint8</td>
         <td>Indicates that the packet is SolidificationRequest.</td>
     </tr>
     <tr>
         <td>messageID</td>
         <td>ByteArray[32]</td>
         <td>Contains the message ID of the requested message.</td>
     </tr>
 </table>
<p style="text-align: center;">
    Table 4.4.2: SolidificationRequest data fields description
</p>
<h3 id="solidificationresponse"><a class="header" href="#solidificationresponse">SolidificationResponse</a></h3>
<table>
     <tr>
         <th>Name</th>
         <th>Type</th>
         <th>Description</th>
     </tr>
     <tr>
         <td>type</td>
         <td>uint8</td>
         <td>Indicates that the packet is SolidificationResponse.</td>
     </tr>
     <tr>
         <td>message</td>
         <td>ByteArray</td>
         <td>Contains the entire requested message.</td>
     </tr>
 </table>
<p style="text-align: center;">
    Table 4.4.3: SolidificationResponses data fields description
</p>
<h2 id="446-denial-of-service"><a class="header" href="#446-denial-of-service">4.4.6 Denial of Service</a></h2>
<p>All requests/responses exchanged during the solidification are sent via UDP. As such, any UDP based Denial of Service attack may harm the normal functionality of the solidification. To limit this, hardware based protection such as firewall or alternatively may be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="45-rate-control-through-adaptive-proof-of-work"><a class="header" href="#45-rate-control-through-adaptive-proof-of-work">4.5 Rate Control through Adaptive Proof of Work</a></h1>
<h2 id="451-introduction"><a class="header" href="#451-introduction">4.5.1 Introduction</a></h2>
<p>In Proof of Work-based blockchains, a built-in rate limit is enforced by the mining difficulty adjustment and the message fees. Without this filter, however, an attacker may be able to easily issue a very large number of messages to potentially harm the network. In order to enable the machine-to-machine economy, IOTA does not allow neither mining race nor fees, which makes an <em>explicit rate control mechanism necessary</em>. In order to ensure that the network traffic does not exceed the allowed throughput determined by the limited resources, it is fundamental to limit the number of messages issued at node level.</p>
<p>The mechanisms described act as an emergency break during spam attacks, by slowing down the rate of messages a node can issue.  For honest nodes, the proof of work difficulty should be small enough not to hamper performance.  Finer controls on the access are developed in <a href="./4.6%20Congestion%20Control.html">Section 4.6 - Congestion Control</a>, which regulate network traffic during normal periods of congestion.</p>
<h3 id="4511-legacy-implementation"><a class="header" href="#4511-legacy-implementation">4.5.1.1 Legacy implementation</a></h3>
<p>In the legacy IOTA implementation, a user is asked to solve a proof of work (PoW) before issuing a new message. The user can either perform that computation locally or outsource it to a third-party service.</p>
<p>In the legacy network, the difficulty of the PoW is set to some value <code>POW_DIFFICULTY</code>. Received messages are stored in a queue and processed in FIFO order. The protocol dictates that the nodes forward messages if and only if the difficulty of the PoW performed is greater or equal to <code>POW_DIFFICULTY</code>. Otherwise, messages <em>shall</em> be dropped.</p>
<h3 id="4512-proposal"><a class="header" href="#4512-proposal">4.5.1.2 Proposal</a></h3>
<p>Similar to the legacy implementation, we require the solution of a given cryptographic puzzle before a message is issued. Here, however, we impose that the difficulty of the challenge progressively increases as a node issues multiple messages in a short time interval.</p>
<p>The goal of this document is to define this rate control mechanism, called <em>Adaptive PoW</em> (APoW), which permits nodes' theoretical throughput to be independent on their hardware equipment. We believe that this mechanism is fundamental to prevent spam and denial-of-service attacks, disallowing dishonest nodes from inflating their neighbors' buffers through large number of messages in a short time. Unlike APoW, the congestion control mechanism described in <a href="./4.6%20Congestion%20Control.html">Section 4.6 - Congestion Control</a> sets the actual throughput depending on nodes' access Mana, and protects the protocol against Sybil attacks and selfish behavior.</p>
<h3 id="4513-dependencies"><a class="header" href="#4513-dependencies">4.5.1.3 Dependencies</a></h3>
<p>The Rate Control specification depends on the following specifications:</p>
<ul>
<li>
<p><a href="./3.3%20Peer%20Discovery.html">3.3 - Peer Discovery</a></p>
</li>
<li>
<p><a href="./4.2%20Timestamps.html">4.2 - Timestamps</a></p>
</li>
</ul>
<h2 id="452-adaptive-proof-of-work"><a class="header" href="#452-adaptive-proof-of-work">4.5.2 Adaptive Proof of Work</a></h2>
<p>All nodes in the network have knowledge of the following three fixed global parameters:</p>
<ul>
<li><em>Base difficulty \((d_0)\)</em>. It sets the initial difficulty of PoW.</li>
<li><em>Adaptation rate \((\gamma\in [0, 1])\)</em>. It provides the rate at which difficulty will be adjusted. Equivalently, \(1/\gamma\) indicates how many messages can be sent per time window without increasing the PoW difficulty.</li>
<li><em>APoW time window \((w&gt;0)\)</em>. It describes the width of the time interval considered by the algorithm, i.e., its granularity.</li>
</ul>
<h3 id="4521-message-generation"><a class="header" href="#4521-message-generation">4.5.2.1 Message generation</a></h3>
<p>Let \(t\) be the output of the function <code>CurrentTime()</code>. If node <code>m</code> wants to issue a new message, it <em>shall</em> perform a PoW with difficulty \(d_m(t)\) such that</p>
<p>$$d_m(t) = d_0 + \left \lfloor{\gamma\cdot r_m(t)}\right \rfloor$$</p>
<p>where \(r_m(t)\) represents the number of messages issued by node <em>m</em> with (message) timestamp in the interval \([t-w, t]\). Note that when \(\gamma = 0\), the algorithm becomes equivalent to the legacy IOTA implementation.</p>
<h3 id="4522-message-verification"><a class="header" href="#4522-message-verification">4.5.2.2 Message verification</a></h3>
<p>When a node <code>n</code> receives a message from a neighbor, it shall check that PoW with an appropriate difficulty was performed. The verification of the correctness of the PoW computation is the last step of the parser checks, right after signature verification (see <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>). Let us assume that node <code>n</code> receives a message with difficulty \(d_m\) issued by node <code>m</code>. To decide whether this message should be discarded, node <code>n</code> counts how many messages \(r_m(t)\) issued by <code>m</code> it has received in the last \(w\) time units. In accordance with the formula above, the node validates the PoW only if the following condition is satisfied:</p>
<p>$$d_m \geq d_0 + \left\lfloor{\gamma\cdot r_m(t)}\right\rfloor.$$</p>
<p>Discussions on the correctness of this procedure can be found on a <a href="https://iota.cafe/t/adaptive-pow-without-sequence-numbers/363">related article</a>.</p>
<h2 id="453-algorithm"><a class="header" href="#453-algorithm">4.5.3 Algorithm</a></h2>
<h3 id="4531-protocol-parameters"><a class="header" href="#4531-protocol-parameters">4.5.3.1 Protocol parameters</a></h3>
<p>In line with the previous section, all nodes know the constants shown by Table 4.5.1.</p>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>POW_BASE</code></td><td>integer</td><td>The base difficulty \(d_0\)</td></tr>
<tr><td><code>APOW_RATE</code></td><td>float</td><td>The adaptation rate \(\gamma\) (proposed values [0.1 - 1])</td></tr>
<tr><td><code>APOW_WINDOW</code></td><td>integer</td><td>The APoW time window \(w\) (proposed values [10 - 60s])</td></tr>
</tbody></table>
<p><em>Table 4.5.1 - Global constants.</em></p>
<p>The choice of the time window is crucial in the correct functioning of the algorithm. Our claim is that the time window must be kept small for two main reasons:</p>
<ul>
<li>Message burst can be captured;</li>
<li>Implementation is easier as it requires smaller caches.</li>
</ul>
<p>However, it is fundamental to keep this time window at least larger than the gratuitous network delay <code>DLARGE</code> (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>).</p>
<h3 id="4532-local-variables-and-metadata"><a class="header" href="#4532-local-variables-and-metadata">4.5.3.2 Local variables and metadata</a></h3>
<p>Local variables and metadata are described in Table 4.5.2.</p>
<table><thead><tr><th>Variable/Metadata</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>timestamp</code></td><td>integer</td><td>A value declared by the node representing time at which the message has been issued</td></tr>
<tr><td><code>nodeID</code></td><td>nodeID</td><td>Identity of the node issuing the message defined as the <code>blake2b</code> hash of its public key</td></tr>
<tr><td><code>targetDifficulty</code></td><td>integer</td><td>Minimum difficulty needed to pass the APoW verification</td></tr>
<tr><td><code>powCheck</code></td><td>boolean</td><td>Boolean value which indicates whether the APoW verification is successful or not</td></tr>
<tr><td><code>ownId</code></td><td>nodeID</td><td>Identity of the node running the algorithm</td></tr>
<tr><td><code>msgCache</code></td><td>list</td><td>Cache storing the timestamp of the most recent messages received by <code>ownID</code></td></tr>
<tr><td><code>nodeMap</code></td><td>list</td><td>List of nodeIDs which have issued messages recently (within 2 APoW timestamp windows)</td></tr>
</tbody></table>
<p><em>Table 4.5.2 - Local variables and metadata.</em></p>
<h3 id="4533-built-in-functions"><a class="header" href="#4533-built-in-functions">4.5.3.3 Built-in functions</a></h3>
<p>Pseudocodes introduced in the next section will use the built-in functions described in Table 4.5.3.</p>
<table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Floor(x)</code></td><td>Give the greatest integer less than or equal to <code>x</code></td></tr>
<tr><td><code>Sort(x, y)</code></td><td>Sort list <code>x</code> by metric <code>y</code></td></tr>
<tr><td><code>Append(x, y)</code></td><td>Add a new element <code>y</code> to list <code>x</code></td></tr>
<tr><td><code>Remove(x)</code></td><td>Remove the oldest element from the ordered data structure <code>x</code></td></tr>
<tr><td><code>Head(x)</code></td><td>Get (without removing) the oldest element from the ordered data structure <code>x</code></td></tr>
<tr><td><code>CurrentTime()</code></td><td>Current time computed with the local clock</td></tr>
</tbody></table>
<p><em>Table 4.5.3 - Built-in functions.</em></p>
<h3 id="4534-pseudocode"><a class="header" href="#4534-pseudocode">4.5.3.4 Pseudocode</a></h3>
<h4 id="targetpowtimestamp-nodeid"><a class="header" href="#targetpowtimestamp-nodeid"><code>TargetPoW(timestamp, nodeID)</code></a></h4>
<p>This function accesses the ledger to check the history of messages for <code>nodeId</code>.</p>
<pre><code class="language-vbnet">FUNCTION targetPoW = TargetPoW(timestamp, nodeID)
    # cache update (this is done as an optimization)
    WHILE CurrentTime() - Head(msgCache).timestamp &gt;  2 * APOW_WINDOW
        Remove(msgCache)
    Append(msgCache, &lt;nodeID, timestamp&gt;)
    Sort(msgCache, `timestamp`)
    countMsg = 0
    FOR msg IN msgCache[nodeID]
        IF msg &gt; timestamp - APOW_WINDOW AND msg &lt; timestamp
            countMsg++
    RETURN BASE_POW + Floor(APOW_RATE * countMsg)
</code></pre>
<h4 id="apowgeneration"><a class="header" href="#apowgeneration"><code>APoWGeneration()</code></a></h4>
<p>This function sets the difficulty at which the message creator should compute the PoW when generating a new message.</p>
<pre><code class="language-vbnet">### upon creation of a new message

FUNCTION targetPoW = APoWGeneration()
    RETURN TargetPoW(CurrentTime(), ownID)
</code></pre>
<h4 id="apowverificationmsg"><a class="header" href="#apowverificationmsg"><code>APoWVerification(msg)</code></a></h4>
<p>This function is triggered in the parser by new messages, see <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>. It returns <code>TRUE</code> if the PoW attached to the message is sufficient, or <code>FALSE</code> otherwise.</p>
<pre><code class="language-vbnet">#### upon arrival of a message msg

FUNCTION powCheck = APoWVerification(msg)
    targetPoW = TargetPoW(msg.timestamp, msg.nodeID)
    IF msg.pow &gt;= targetPoW
        IF nodeMap[msg.nodeID] == NULL
            Append(nodeMap, msg.nodeID)
        Append(msgCache, msg.timestamp)
        RETURN TRUE
    ELSE
        RETURN FALSE
</code></pre>
<h3 id="4535-implementation"><a class="header" href="#4535-implementation">4.5.3.5 Implementation</a></h3>
<p>The most critical part of the algorithm concerns counting the number of messages recently issued by a node. Since querying the database may be expensive, we propose to cache the most recent messages. To this end, we use two data structures (see Image 4.5.4):</p>
<ul>
<li><code>nodeMap</code>. Each entry in the hashmap corresponds to a different nodeId and points to the doubly linked list of recent messages of the same node.</li>
<li><code>msgCache</code>. A queue which removes old messages and adds new ones according to a FIFO policy.</li>
</ul>
<p><img src="https://i.imgur.com/vgbhyJO.png" alt="" /></p>
<p><em>Image 4.5.4 - Proposed data structures for the implementation of the rate control mechanism.</em></p>
<p>Both data structures point to the same locations of memory which store the timestamp of the message. These locations of memory also store the pointers to the other elements of <em>nodeMap</em> and <em>msgCache</em>.</p>
<p>The size of the cache \(C\) (in number of timestamps) must be larger of the product between the maximum network throughput and the time window \(w\). Assume that max throughput is 1000 TPS and the time window is 50 s, cache size must be larger than 50,000. Given \(N\) the number of nodes issuing recent messages, our caching scheme provides the following performance:</p>
<ul>
<li>cache update: \(\mathcal{O}(1)\);</li>
<li>msg counter: \(\mathcal{O}(C/N)\);</li>
<li>cache size: \(&lt;10\) MB.</li>
</ul>
<p>Assume that a node receives a message with PoW difficulty equal to <em>targetPoW</em>. However, the node cannot (immediately) know whether older messages have been issued before the timestamp of such message, which would make its PoW not sufficient. In this case, in order not to slow down the network, the node will forward anyway the message for scheduling.</p>
<p>An attacker may exploit the above in order to issue progressively older messages which would be accepted with easier PoW difficulty. Since the timestamp validation window is pretty large, this attack may theoretically be effective.</p>
<p>In case a node receives a new message with a timestamp that would make other messages from the same node would not have the correct PoW difficulty, the node will be blacklisted. However, no transactions which are already scheduled would be dropped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="46-congestion-control"><a class="header" href="#46-congestion-control">4.6 Congestion control</a></h1>
<p>This specification provides a solution to deal with network congestion in the IOTA network. The congestion control algorithm described in this file decides which messages should be processed and gossiped to node's neighbors and in what order to do so.</p>
<h2 id="461-introduction"><a class="header" href="#461-introduction">4.6.1 Introduction</a></h2>
<p>Every network has to deal with its intrinsic limited resources in terms of bandwidth and node capabilities (CPU and storage). In this document, we present a congestion control algorithm to regulate the influx of messages in the network with the goal of maximizing throughput (messages/bytes per second) and minimizing delays. Furthermore, the following requirements must be satisfied:</p>
<ul>
<li><em>Consistency</em>. If a message is written by one honest node, it shall be written by all honest nodes within some delay bound.</li>
<li><em>Fairness</em>. Nodes can obtain a share of the available throughput depending on their access Mana. Throughput is shared in such a way that an attempt to increase the allocation of any node necessarily results in the decrease in the allocation of some other node with an equal or smaller allocation (max-min fairness).</li>
<li><em>Security</em>. Malicious nodes shall be unable to interfere with either of the above requirements.</li>
</ul>
<p>Further information can be found in our a paper <a href="https://arxiv.org/abs/2005.07778">Access Control for Distributed Ledgers in the Internet of Things: A Networking Approach</a>.</p>
<h3 id="4612-proposal"><a class="header" href="#4612-proposal">4.6.1.2 Proposal</a></h3>
<p>In this specification, we present the congestion control algorithm that shall be implemented by all IOTA nodes. Nodes cannot take any advantage by not following the protocol. Conversely, they may eventually be considered as malicious nodes and banned. Our algorithm has three core components: </p>
<ul>
<li>A scheduling algorithm which ensures fair access for all nodes according to their access Mana.</li>
<li>A TCP-inspired algorithm for decentralized rate setting to efficiently utilize the available bandwidth while preventing large delays.</li>
<li>A blacklisting policy to ban malicious nodes.</li>
</ul>
<h3 id="4613-dependencies"><a class="header" href="#4613-dependencies">4.6.1.3 Dependencies</a></h3>
<p>The Congestion Control specification depends on the following specifications:</p>
<ul>
<li>
<p><a href="./2.4%20Data%20flow.html">2.4 - Data Flow</a></p>
</li>
<li>
<p><a href="./3.3%20Peer%20Discovery.html">3.3 - Peer discovery</a></p>
</li>
<li>
<p><a href="./4.2%20Timestamps.html">4.2 - Timestamps</a></p>
</li>
<li>
<p><a href="./5.3%20Mana.html">5.3 - Mana</a></p>
</li>
</ul>
<h2 id="462-congestion-control-algorithm"><a class="header" href="#462-congestion-control-algorithm">4.6.2 Congestion control algorithm</a></h2>
<h3 id="4621-outbox-management"><a class="header" href="#4621-outbox-management">4.6.2.1 Outbox management</a></h3>
<p>Once the message has successfully passed the message parser checks and is solid, it is enqueued into the outbox for scheduling (see <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>). The outbox is logically split into several queues, each one corresponding to a different node issuing messages. In this section, we describe the operations of message enqueuing (and dequeuing) into (from) the outbox.</p>
<p>The enqueuing mechanism includes the following components:</p>
<ul>
<li><em>Classification</em>. The mechanism identifies the queue where the message belongs to according to the node ID of the message issuer.</li>
<li><em>Message enqueuing</em>. The message is actually enqueued, queue is sorted by message timestamps in increasing order and counters are updated (e.g., counters for the total number of bytes in the queue).</li>
<li><em>Message drop</em>. In some circumstances, due to network congestion or to ongoing attacks, some messages shall be dropped to guarantee bounded delays and isolate attacker's messages. Specifically, a node shall drop messages in two situations:
<ul>
<li>since buffers are of a limited size, if the total number of bytes in all queues exceeds a certain threshold, new incoming messages are dropped;</li>
<li>to guarantee the security of the network, if a certain queue exceeds a given threshold, new incoming packets from that specific node ID will be dropped.</li>
</ul>
</li>
</ul>
<p>The dequeue mechanism includes the following components:</p>
<ul>
<li><em>Queue selection</em>. A queue is selected according to round robin scheduling algorithm. In particular, we use a modified version of the deficit round robin (DRR) algorithm, and we describe it in Section 3.4.2.2 - Scheduler.</li>
<li><em>Message dequeuing</em>. The first message of the queue is dequeued, and list of active nodes is updated.</li>
<li><em>Scheduler management</em>. Scheduler counters and pointers are updated.</li>
</ul>
<h3 id="4622-scheduler"><a class="header" href="#4622-scheduler">4.6.2.2 Scheduler</a></h3>
<p>The most critical task is the scheduling algorithm which must guarantee that, for an honest node <code>node</code>, the following requirements will be met:</p>
<ul>
<li><code>node</code>'s messages will not accumulate indefinitely at any node (i.e., starvation is avoided), so the <em>consistency</em> requirement will be ensured.</li>
<li><code>node</code>'s fair share (according to its access Mana) of the network resources are allocated to it, guaranteeing the <em>fairness</em> requirement.</li>
<li>Malicious nodes sending above their allowed rate will not interrupt <code>node</code>'s throughput, fulfilling the <em>security</em> requirement.</li>
</ul>
<p>We remind the reader that the above requirements are described in Section 3.4.1 - Summary.</p>
<p>Although nodes in our setting are capable of more complex and customised behaviour than a typical router in a packet-switched network, our scheduler must still be lightweight and scalable due to the potentially large number of nodes requiring differentiated treatment. It is estimated that over 10,000 nodes operate on the Bitcoin network, and we expect that an even greater number of nodes are likely to be present in the IoT setting. For this reason, we adopt a scheduler based on <a href="https://ieeexplore.ieee.org/document/502236">Deficit Round Robin</a> (DRR) (the Linux implementation of the <a href="https://tools.ietf.org/html/rfc8290">FQ-CoDel packet scheduler</a>, which is based on DRR, supports anywhere up to 65535 separate queues).</p>
<p>The DRR scans all non-empty queues in sequence. When a non-empty queue is selected, its priority counter (called <em>deficit</em>) is incremented by a certain value (called <em>quantum</em>). Then, the value of the deficit counter is a maximal amount of bytes that can be sent at this turn: if the deficit counter is greater than the weight of the message at the head of the queue, this message can be scheduled and the value of the counter is decremented by this weight. In our implementation, the quantum is proportional to node's access Mana and we add a cap on the maximum deficit that a node can achieve to keep the network latency low. It is also important to mention that the weight of the message can be assigned in such a way that specific messages can be prioritized (low weight) or penalized (large weight); by default, in our mechanism the weight is proportional to the message size measured in bytes. The weight of a message is set by the function <code>WorkCalculator()</code>, and additional details can be found in <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>.</p>
<p>Here a fundamental remark: <em>the network manager sets up a desired maximum (fixed) rate</em> <code>SCHEDULING_RATE</code> <em>at which messages will be scheduled</em>, computed in weight (see above) per second. This implies that every message is scheduled after a delay which is equal to the weight (size as default) of the latest scheduled message times the parameter <code>SCHEDULING_RATE</code>. This rate mostly depends on the degree of decentralization desired: e.g., a larger rate leads to higher throughput but would leave behind slower devices which will fall out of sync.</p>
<h3 id="4623-rate-setting"><a class="header" href="#4623-rate-setting">4.6.2.3 Rate setting</a></h3>
<p>If all nodes always had messages to issue, i.e., if nodes were continuously willing to issue new messages, the problem of rate setting would be very straightforward: nodes could simply operate at a fixed, assured rate, sharing the total throughput according to the percentage of access Mana owned. The scheduling algorithm would ensure that this rate is enforceable, and that increasing delays or dropped messages are only experienced by misbehaving node. However, it is unrealistic that all nodes will always have messages to issue, and we would like nodes to better utilise network resources, without causing excessive congestion and violating any requirement.</p>
<p>We propose a rate setting algorithm inspired by TCP  each node employs <a href="https://https://epubs.siam.org/doi/book/10.1137/1.9781611974225">additive increase, multiplicative decrease</a> (AIMD) rules to update their issuance rate in response to congestion events. In the case of distributed ledgers, all message traffic passes through all nodes, contrary to the case of traffic typically found in packet switched networks and other traditional network architectures. Under these conditions, local congestion at a node is all that is required to indicate congestion elsewhere in the network. This observation is crucial, as it presents an opportunity for a congestion control algorithm based entirely on local traffic.</p>
<p>Our rate setting algorithm outlines the AIMD rules employed by each node to set their issuance rate. Rate updates for a node <code>node</code> take place each time a new message is scheduled if the <code>node</code> has a non-empty set of its own messages not yet scheduled. Node <code>node</code> sets its own local additive-increase variable <code>localIncrease(node)</code> based on its access Mana and on a global increase rate parameter <code>RATE_SETTING_INCREASE</code>. An appropriate choice of <code>RATE_SETTING_INCREASE</code> ensures a conservative global increase rate which does not cause problems even when many nodes increase their rate simultaneously. Nodes wait <code>RATE_SETTING_PAUSE</code> seconds after a global multiplicative decrease parameter <code>RATE_SETTING_DECREASE</code>, during which there are no further updates made, to allow the reduced rate to take effect and prevent multiple successive decreases. At each update, <code>node</code> checks how many of its own messages are in its outbox queue, and responds with a multiplicative decrease if this number is above a threshold, <code>backoff(node)</code>, which is proportional to <code>node</code>'s access Mana. If the number of <code>node</code>'s messages in the outbox is below the threshold, <code>node</code>'s issuance rate is incremented by its local increase variable <code>localIncrease(node)</code>.</p>
<h3 id="4624-message-blocking-and-blacklisting"><a class="header" href="#4624-message-blocking-and-blacklisting">4.6.2.4 Message blocking and blacklisting</a></h3>
<p>If an incoming message made the outbox total buffer size to exceed its maximum capacity <code>MAX_BUFFER</code>, the same message would be dropped. In our analysis, we set buffers to be large enough to accommodate traffic from all honest nodes.</p>
<p>Furthermore, to mitigate spamming actions from malicious nodes, we add an additional constraint: if <code>node</code>'s access Mana-scaled queue length (i.e., queue length divided by node's access Mana) exceeds a given threshold <code>MAX_QUEUE</code>, any new incoming packet from <code>node</code> will be dropped, hence the node is blacklisted. The attacker is blacklisted for a certain time <code>BLACKLIST_TIME</code> during which no messages issued by <code>node</code> can be added to the outbox. Please note that it is still possible to receive message from the attacker through solidification requests, which is important in order to guarantee the consistency requirement. Finally, when a node is blacklisted, the blacklister does not increase its own rate for a time <code>RATE_SETTING_QUARANTINE</code>, to avoid errors in the perception of the current congestion level.</p>
<h2 id="463-algorithmic-details"><a class="header" href="#463-algorithmic-details">4.6.3 Algorithmic details</a></h2>
<h3 id="4631-protocol-parameters"><a class="header" href="#4631-protocol-parameters">4.6.3.1 Protocol parameters</a></h3>
<p>In line with the previous section, all nodes know the global variables described in Table 4.6.1.</p>
<table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>SCHEDULING_RATE</code></td><td>integer</td><td>clock time interval between subsequent executions of the function <code>Schedule()</code></td></tr>
<tr><td><code>RATE_SETTING_INCREASE</code></td><td>float</td><td>global additive increase parameter</td></tr>
<tr><td><code>RATE_SETTING_DECREASE</code></td><td>float</td><td>global multiplicative decrease parameter (larger than 1)</td></tr>
<tr><td><code>RATE_SETTING_PAUSE</code></td><td>integer</td><td>waiting time before next <code>ownID</code>'s rate update after backoff</td></tr>
<tr><td><code>RATE_SETTING_QUARANTINE</code></td><td>integer</td><td>waiting time before next <code>ownID</code>'s rate update after blacklisting</td></tr>
<tr><td><code>MAX_BUFFER</code></td><td>integer</td><td>maximum buffer size (in bytes)</td></tr>
<tr><td><code>MAX_QUEUE</code></td><td>float</td><td>maximum access Mana-scaled inbox length</td></tr>
<tr><td><code>MAX_DEFICIT</code></td><td>float</td><td>maximum cap for accumulated deficit</td></tr>
<tr><td><code>MAX_RATE</code></td><td>float</td><td>maximum rate at which a node can be allowed to issue messages</td></tr>
<tr><td><code>MIN_MANA</code></td><td>integer</td><td>minimum amount of Mana needed to issue messages</td></tr>
<tr><td><code>BLACKLIST_TIME</code></td><td>integer</td><td>time interval during which no messages from blacklisted nodes are added to the outbox</td></tr>
</tbody></table>
<p><em>Table 4.6.1 - Global constants.</em></p>
<h3 id="4632-local-variables"><a class="header" href="#4632-local-variables">4.6.3.2 Local variables</a></h3>
<p>Local variables are described in Table 4.6.2.</p>
<table><thead><tr><th>Variable</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>ownRate</code></td><td>float</td><td>issuance rate of <code>ownID</code> according to the rate setter</td></tr>
<tr><td><code>activeNode</code></td><td>list</td><td>updated list of nodes having at least one message in the outbox queue (more details in Section 4.6.3.5 - Implementation)</td></tr>
<tr><td><code>bufferQueue</code></td><td>queue</td><td>actual outbox queue where messages are ready to be scheduled (more details in Section 4.6.3.5 - Implementation)</td></tr>
<tr><td><code>nextID</code></td><td>nodeID</td><td>pointer to the specific queue where next message can be scheduled from</td></tr>
<tr><td><code>mana</code></td><td>list</td><td>contains the <em>up-to-date</em> (at the time the vector is used) value of the access Mana given a certain <code>nodeId</code>. The way in which <code>mana</code> is updated is out of the scope of this spec, and further information can be found in <a href="./5.3%20Mana.html">Section 5.3 - Mana</a></td></tr>
<tr><td><code>backoff</code></td><td>float</td><td>local threshold for rate setting's backoff</td></tr>
<tr><td><code>localIncrease</code></td><td>float</td><td>local additive increase parameter</td></tr>
<tr><td><code>blacklisted</code></td><td>list</td><td>list of timestamps indicating if a specific <code>nodeId</code> is blacklisted. If node is not blacklisted, the entry is <em>0</em></td></tr>
<tr><td><code>pauseUpdates</code></td><td>integer</td><td>time interval during which rate setter is not updated</td></tr>
<tr><td><code>messageWorker</code></td><td>list</td><td>list of messages that <code>ownNode</code> issued but are still not part of the outbox</td></tr>
</tbody></table>
<p><em>Table 4.6.2 - Local variables.</em></p>
<h3 id="4633-built-in-functions"><a class="header" href="#4633-built-in-functions">4.6.3.3 Built-in functions</a></h3>
<p>Pseudocodes introduced in the next section will use the built-in functions described in Table 4.6.3.</p>
<table><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Len(x)</code></td><td>measures the length of a data structure <code>x</code></td></tr>
<tr><td><code>Append(x, y)</code></td><td>add a new element <code>y</code> to list <code>x</code></td></tr>
<tr><td><code>WorkCalculator(x)</code></td><td>provides the weight of message <code>x</code></td></tr>
<tr><td><code>Sort(x, y)</code></td><td>sort list <code>x</code> by metric <code>y</code></td></tr>
<tr><td><code>Parents(x)</code></td><td>gives the list of parents of a message <code>x</code></td></tr>
<tr><td><code>CurrentTime()</code></td><td>current time computed with the local clock</td></tr>
<tr><td><code>Execute(x)</code></td><td>process and gossip message <code>x</code></td></tr>
<tr><td><code>Pause(x)</code></td><td>stop execution of a function for <code>x</code> time units</td></tr>
</tbody></table>
<p><em>Table 4.6.3 - Built-in functions.</em></p>
<h3 id="4634-pseudocode"><a class="header" href="#4634-pseudocode">4.6.3.4 Pseudocode</a></h3>
<p>The congestion control algorithm follows the <em>solidification</em> in the data flow: when a new message <code>msg</code> arrives to the scheduler, the function <code>Enqueue(msg)</code> will be triggered in order to properly add <code>msg</code> to the outbox. At the same time, at regular intervals (given by <code>SCHEDULING_RATE</code> times <code>WorkCalculator(x)</code> where <code>x</code> is the latest scheduled message), the function <code>Schedule()</code> picks a new message that has to be gossiped to neighbors and to be added to the local ledger. Simultaneously, <code>RateSetting()</code> adjusts the message generation rate of <code>ownID</code> according to the network congestion.</p>
<h4 id="enqueuemsg"><a class="header" href="#enqueuemsg"><code>Enqueue(msg)</code></a></h4>
<p>The function <code>Enqueue(msg)</code> adds a new message <code>msg</code> into the outbox and updates the list of active nodes accordingly. The checks on blacklisting condition (<code>blacklisted[nodeID] == FALSE</code>) and buffer size (<code>Len(bufferQueue) &lt; MAX_BUFFER</code>) may be moved to the parser checker for optimization purposes.</p>
<pre><code class="language-vbnet">### upon arrival of a new message msg (having passed solidification) ###

FUNCTION Enqueue(msg)
    nodeID = msg.nodeID
    IF mana[nodeID] &gt; MIN_MANA AND (blacklisted[nodeId] == 0 OR CurrentTime() - blacklisted[nodeID] &gt; BLACKLIST_TIME)
        blacklisted[nodeId] = 0
        IF Len(bufferQueue) &lt; MAX_BUFFER
            IF activeNode[nodeID] != NULL
                # other messages from nodeID are already in the queue
                nodeQueue = activeNode[nodeID]
                IF (Len(nodeQueue) + Len(msg))/mana[nodeID] &lt; MAX_QUEUE
                    # append msg
                    Append(bufferQueue, msg)
                    Sort(bufferQueue, timestamp)
                ELSE
                    # blacklist nodeID and pause rate setting updates
                    blacklisted[nodeID] = CurrentTime()
                    pauseUpdates = Max(pauseUpdates, RATE_SETTING_QUARANTINE)
            ELSE
                # no other messages for nodeID are present in the buffer
                Append(activeNode, nodeID)
                activeNode[nodeID].deficit = MAX_DEFICIT
                Append(bufferQueue, msg)
</code></pre>
<h4 id="ratesetting"><a class="header" href="#ratesetting"><code>RateSetting()</code></a></h4>
<p>The function <code>RateSetting()</code> updates the rate <code>ownRate</code> at which messages can be issued by the node. The maximum value that <code>ownRate</code> can reach is <code>MAX_RATE</code>. At the bootstrap, the value of <code>ownRate</code> is initialized by the proportion of access Mana owned by the node times <code>RATE_SETTING_INCREASE</code>.</p>
<pre><code class="language-vbnet">FUNCTION RateSetting()
    # update issueing rate if no recent backoff
    IF ownRate &lt; MAX_RATE
        # retrieve message queue of the same node
        IF Len(bufferQueue[ownID]) / mana[ownID] &gt; backoff
            ownRate = ownRate / RATE_SETTING_DECREASE
            pauseUpdates = Max(pauseUpdates, RATE_SETTING_PAUSE)
        ELSE
            ownRate += RATE_SETTING_INCREASE * mana[ownID] / Sum(mana)
</code></pre>
<h4 id="schedule"><a class="header" href="#schedule"><code>Schedule()</code></a></h4>
<p>At regular intervals, i.e., every <code>SCHEDULING_RATE</code> times <code>WorkCalculator(x)</code> where <code>x</code> is the latest scheduled message, the function <code>Schedule()</code> selects the next message to gossip and process, if at least one message exists in <code>bufferQueue</code>. Otherwise, it returns <code>NULL</code> and the scheduling slot is missed. The local variable <code>pauseUpdates</code> is initialized to <em>0</em>.</p>
<pre><code class="language-vbnet">FUNCTION msg = Schedule()
    WHILE TRUE
        IF Len(bufferQueue) &gt; 0
            # msg represents the message in the outbox
            msg = bufferQueue[nextID].head
            # point to a nodeId with enough deficit, having a valid message
            WHILE activeNode[nextID].deficit &lt; Weight(msg) OR msg.timestamp &gt; CurrentTime() OR Parents(msg) have not been scheduled
                activeNode[nextID].deficit += mana[nextID]
                IF activeNode[nextID].deficit &gt; MAX_DEFICIT
                    activeNode[nextID].deficit = MAX_DEFICIT
                nextID++
            activeNode[nextID].deficit -= Weight(msg)
            IF activeNode[nextID].deficit &lt; 0
                activeNode[nextID] = 0
            # remove scheduled message from queue
            Remove(bufferQueue[nextID].head)
            # update list of active nodes
            IF Len(bufferQueue[nextID]) == 0
                Remove(activeNode[nextID])
            # update own rate setting
            IF pauseUpdates &gt; 0
                pauseUpdates -= 1
            ELSE IF Len(messageWorker) &gt; 0
                RateSetting()
            Execute(msg)
        Pause(SCHEDULING_RATE * WorkCalculator(msg))
</code></pre>
<h3 id="4635-implementation"><a class="header" href="#4635-implementation">4.6.3.5 Implementation</a></h3>
<p>In this section, we describe the main architectural components used to handle the outbox queue, that is <code>activeNode</code> and <code>bufferQueue</code> (see Image 4.6.4). The scope of this section is to provide an insight on how to efficiently implement the above pseudocode.</p>
<ul>
<li><code>activeNode</code>: it is a list which includes the node IDs of the nodes having at least one message in the outbox queue. Each node ID in the list points to its oldest message in the outbox buffer.</li>
<li><code>bufferQueue</code>: it is the actual outbox queue. It is possible to build overlapping virtual queues (indicated by colors in the figure) to represent different queues per node. This data structure has a limited fixed size <code>MAX_BUFFER</code>, and messages (in each queue) are sorted by timestamp.</li>
</ul>
<p><img src="https://i.imgur.com/Ek5eGef.png" alt="" /></p>
<p>Other information about the hardware implementation of similar scheduling algorithms can be found at <a href="https://ieeexplore.ieee.org/document/642834">this link</a>.</p>
<p><em>Image 4.6.4 - Proposed data structure for the implementation of the congestion control algorithm.</em></p>
<h2 id="464-optional-and-future-optimizations"><a class="header" href="#464-optional-and-future-optimizations">4.6.4 Optional and future optimizations</a></h2>
<h3 id="4641-synchronization"><a class="header" href="#4641-synchronization">4.6.4.1 Synchronization</a></h3>
<p>When the network has a high level of congestion, it may be difficult for an out-of-sync node to synchronize as most of its scheduling rate is consumed by new messages. Hence, it is nice to have a mechanism allowing to schedule messages faster to catch up with the rest of the network under special conditions. </p>
<p>Specifically, consider the following two scenarios:</p>
<ul>
<li>Node is bootstrapping.</li>
<li>Node's <code>syncStatus</code> flag is set to <code>FALSE</code> (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamp</a>).</li>
</ul>
<p>In either of these scenarios, the node is very far behind the rest of the newtork. In this case, we suggest to bypass the DRR scheduler, and schedule <em>solid</em> old messages in FIFO order at the largest possible rate the node can process. We repeat that this feature is optional: while it reduces the time needed to synchronize, it is not strictly needed for the correct functioning of the congestion control algorithm.</p>
<h3 id="4642-adaptive-minimum-access-mana"><a class="header" href="#4642-adaptive-minimum-access-mana">4.6.4.2 Adaptive minimum access Mana</a></h3>
<p>Nodes must hold a sufficient amount of access Mana (larger than <code>MIN_MANA</code>) to be able to successfully issue new messages. We are currently investigating a way to adapt this threshold over time, depending on the current traffic congestion of the network.</p>
<h3 id="4643-dynamic-scheduling-rate"><a class="header" href="#4643-dynamic-scheduling-rate">4.6.4.3 Dynamic scheduling rate</a></h3>
<p>In the current proposal, the throughput is preset by the network manager. This value takes into account nodes hardware as well as bandwidth capacity. Hardware improvement or protocol optimizations will not result in a performance improvement if the network manager does not change the throughput parameter <code>SCHEDULING_RATE</code>. We are currently investigating a way to dynamically adapt the throughput according to the network and protocol characteristics based on neighbors health state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="47-markers"><a class="header" href="#47-markers">4.7 Markers</a></h1>
<h2 id="471-introduction"><a class="header" href="#471-introduction">4.7.1 Introduction</a></h2>
<p>This section specifies the requirements for the <em>marker</em> tool. A tool as defined here is a feature that adds functionality to the node software but is not an essential component. The marker tool improves the efficiency with which certain properties  can be checked or certain metrics calculated.</p>
<p>The potential issues addressed by the use of the marker tool are in handling potentially numerically expensive operations. Specifically, the following operations can become numerically expensive:</p>
<ul>
<li><strong>Future- or past cone inclusion</strong>. For certain applications it is necessary to know whether a certain message is in the past or future cone of another message. In the default approach the Tangle has to be walked until a given message is found.</li>
<li><strong>Approval weight</strong>. In order to compute the approval weight of a given message the node software needs to traverse the Tangle from that message to the tips and sum up the active consensus Mana of all the messages in its future cone, see also the section on <a href="./6.2%20Opinion%20Setting.html">approval weight</a>.</li>
</ul>
<p>The marker tool allows a node to efficiently determine whether certain markers are in the past or future cone of a given message, by reducing the proportion of the Tangle that needs to be traversed. </p>
<p>The marker tool achieves this by defining a parallel internal data structure, consisting of additional metadata applied to specific messages in the Tangle. Specifically, the marker tool &quot;marks&quot; certain messages, which form a subDAG which approximates the topological structure of the Tangle.  Furthermore, the markers are grouped into sequences (which themselves form yet another DAG), which allow the node to quickly determine which markers reference each other.</p>
<p>Note, that we <em>shall</em> require that markers are assigned when booking a message. Thus, for that part of the message DAG that is already booked the corresponding marker DAG does not change anymore. </p>
<h2 id="472-definitions"><a class="header" href="#472-definitions">4.7.2 Definitions</a></h2>
<p>The following terms are defined in relation to markers:</p>
<ul>
<li><strong>UTXO branch:</strong> This is a set of outputs that spawn off from a conflict transaction. Each UTXO branch by itself is conflict free. See also <a href="./5.1%20UTXO.html">Section 5.1 - UTXO</a> and <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a> for a more complete discussion on UTXO and its branches.</li>
<li><strong>Aggregated branch:</strong> The aggregation of a combination of several branches.</li>
<li><strong>Branch identifier (<code>BID</code>):</strong> The unique identifier of a branch or aggregated branch.</li>
<li><strong>Main branch:</strong> The part of the UTXO DAG, in which all outputs are considered to be good in the sense that all conflicts in their past have been resolved, either by a given conflict being accepted or rejected. </li>
<li><strong>Rank:</strong> The length of the longest directed path in DAG terminating in a given vertex/object. Specifically, if a vertex \(A\) directly references only \(B\) and \(C\) then \(rank(A)=max(rank(B),rank(C))+1\).</li>
<li><strong>Marker:</strong> A message that is assigned additional properties locally on the node, and that tracks a particular UTXO branch.</li>
<li><strong>Marker identifier (<code>MID</code>):</strong> The unique identifier of the marker.</li>
<li><strong>Marker DAG:</strong> The collection of all markers. </li>
<li><strong>Marker rank (<code>MR</code>):</strong> The rank of a marker in the marker DAG.</li>
<li><strong>Marker-sequence:</strong> A marker-sequence is a group of markers. Each marker-sequence maps to a UTXO branch; see <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>.</li>
<li><strong>Marker-sequence identifier (<code>SID</code>):</strong> A marker-sequence identifier is a number that uniquely identifies a marker-sequence.</li>
<li><strong>Marker-sequence rank (<code>SR</code>):</strong> The rank of a marker-sequence in the marker-sequence DAG.</li>
<li><strong>Future marker (<code>FM</code>):</strong> This field in the <a href="4.7%20Markers.html##%204.7.5%20Message%20Metadata">message metadata</a> is (potentially) updated when a new marker is generated in the future cone of the message, following the rules defined in Section &quot;Message Metadata&quot;. Essentially it contains the list of markers for which there is no other marker between the marker in question and the message, or in more mathematical terms, the minimal markers in the future cone.</li>
<li><strong>Past marker (<code>PM</code>):</strong> A past marker of a message is a most recent past marker of the parents (with respect to <code>MR</code>). The past marker of a marker is set to itself.</li>
</ul>
<h2 id="473-the-markers"><a class="header" href="#473-the-markers">4.7.3 The markers</a></h2>
<p>A marker consists of the following data:</p>
<h3 id="4731-marker-data"><a class="header" href="#4731-marker-data">4.7.3.1 Marker data</a></h3>
<table>
    <tr>
        <th>Variable</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>MID</code></td>
        <td>uint64</td>
        <td>Unique identifier of the marker</td>
    </tr>
    <tr>
        <td><code>SID</code></td>
        <td>uint64</td>
        <td>Unique identifier of the marker-sequence</td>
    </tr>
    <tr>
        <td><code>MR</code></td>
        <td>uint64</td>
        <td>Marker rank</td>
    </tr>
</table>
<br>
<p>A new marker <em>shall</em> be created by the marker tool when any of the following conditions are met: </p>
<ul>
<li>a new UTXO branch is created and the message that would get a marker assigned is not yet booked. This also creates a new marker-sequence.</li>
<li>more than a certain number of messages (<code>maxMsgPerMarker</code>) have been received since the last marker.  This rule must be applied per marker-sequence. I.e. for each marker-sequence with more than <code>maxMsgPerMarker</code> since the last marker in that marker-sequence, the rule <em>shall</em> be applied independently.</li>
<li>a certain time window (<code>maxTimePerMarker</code>) has passed since the last marker. </li>
</ul>
<p>A marker is created with a <code>MID</code>, an this <code>MID</code> must be unique. </p>
<p>To set a new  marker within a marker-sequence, the marker tool randomly selects from strong tips set a message whose past marker is the last marker in the sequence. The next marker will then reference that transaction. If there is no strong tip with the appropriate past marker, the selection <em>shall</em> be from message in the weak tips set. The rank of the new marker should be one greater than the rank of all the past markers of the message.</p>
<p>Since \(\texttt{MR}(x)=1+\max \limits_{y: x\text{ references }y}\texttt{MR}(y)\), marker ranks are monotonically non-decreasing such that 
\(\forall x \in fc(y) \Rightarrow \texttt{MR}_x &gt; \texttt{MR}_y\), 
where \(fc(y)\) is the future cone of \(y\).</p>
<h2 id="474-the-marker-sequence"><a class="header" href="#474-the-marker-sequence">4.7.4 The marker-sequence</a></h2>
<p>Marker-sequences are used to track the UTXO DAG branches. Each branch corresponds to a marker-sequence with a unique <code>SID</code>, and the marker-sequences form a DAG. </p>
<h3 id="4741-marker-sequence-data"><a class="header" href="#4741-marker-sequence-data">4.7.4.1 Marker-sequence data</a></h3>
<p>Each marker-sequence is associated with the following data:</p>
<table>
    <tr>
        <th>Variable</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>SID</code></td>
        <td>unit64</td>  
        <td>The marker-sequence identifier</td>
    </tr>
    <tr>
        <td><code>SR</code></td>
        <td>unit64</td>
        <td>The rank of a marker-sequence in the marker-sequence DAG</td>
    </tr>
    <tr>
        <td><code>MRMax</code></td>
        <td>unit64</td>
        <td>The highest <code>MR</code> in the marker-sequence</td>
    </tr>
    <tr>
        <td><code>MRMin</code></td>
        <td>unit64</td>
        <td>The lowest <code>MR</code> in the marker-sequence</td>
    </tr>
    <tr>
        <td><code>ParentReferences </code></td>
        <td>map[<code>Marker</code>] <code>Marker</code></td>
        <td>Relationship map from parent marker-sequences to markers (*) </td>
    </tr>
</table>
<br/>
<p>*The field <code>ParentReferences</code> models the relationship between marker-sequences. This maps which marker in this marker-sequence references which other markers from other marker-sequences. </p>
<p>Whenever a new marker is added that is a member of a given marker-sequence, <code>MR_max</code> and <code>ParentReferences</code> for that marker-sequence <em>shall</em> be updated. </p>
<h3 id="4742-creation-of-marker-sequences"><a class="header" href="#4742-creation-of-marker-sequences">4.7.4.2 Creation of marker-sequences</a></h3>
<p>A new marker-sequence <em>shall</em> be created when:</p>
<ol>
<li>there's a transaction that creates a new conflict, i.e. creates a new UTXO branch.</li>
<li>the UTXO branches are aggregated.</li>
<li>UTXO branches are merged.</li>
</ol>
<p>Each new marker-sequence <em>shall</em> start with a new marker. Hence, with the creation of a new marker-sequence also a new marker <em>must</em> be assigned to the message that caused one of the three above events.</p>
<p>Whenever a new marker-sequence is created, the marker tool <em>shall</em> assign:</p>
<ul>
<li>a new <code>SID</code>, created by the rule \(\mbox{new }\texttt{SID}=1+\mbox{last } \texttt{SID}\). A new created <code>SID</code> must be unique. </li>
<li>a new \(\texttt{SR}=1+max(\text{referenced }\texttt{SR})\). 
To prevent assigning a new <code>SID</code> when combining the same marker-sequences at different times, the marker tool <em>shall</em> build parent-child relationships in a map whenever a new marker-sequence is created. </li>
</ul>
<p>For further details about the UTXO model, please refer to the section on <a href="./5.1%20UTXO.html">UTXO</a>.</p>
<h2 id="475-message-metadata"><a class="header" href="#475-message-metadata">4.7.5 Message Metadata</a></h2>
<p>For each message in the Tangle, the marker tool <em>shall</em> maintain metadata that provides information about the markers that are closest in the past or future cone of that message, as well as whether the message itself is a marker and what rank the message has. The following message metadata <em>shall</em> be defined in the marker tool to support that requirement:</p>
<table>
    <tr>
        <th>Variable</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><code>IsMarker</code></td>
        <td>bool</td>
        <td>A flag to indicate whether a message is a marker.</td>
    </tr>
    <tr>
        <td><code>PastMarkers</code></td>
        <td>map[<code>SID</code>]<code>MID</code></td>
        <td>A list of the closest markers from different marker-sequences in the past cone of the message.</td>
    </tr>
    <tr>
        <td><code>FutureMarkers</code></td>
        <td>map[<code>SID</code>]<code>MID</code></td>
        <td>A list of the closest markers from different marker-sequences in the future cone of the message.</td>     
    </tr>
    <tr>
        <td><code>MarkerBranchID</code></td>
        <td><code>BID</code></td>
        <td>The branch ID to which the marker is mapped, or <code>nil</code> if the message is no marker.</td>     
    </tr>
    <tr>
        <td><code>PayloadBranchID</code></td>
        <td><code>BID</code></td>
        <td>The branch ID to which the Payload is mapped in case it is a conflict, or <code>nil</code> otherwise.</td>     
    </tr>
    <tr>
        <td><code>IndividualBranchID</code></td>
        <td><code>BID</code></td>
        <td>The branch ID if there is need for mapping the message individually to a branch ID, or <code>nil</code> otherwise.</td>     
    </tr>
</table>
<br>
<p>The <code>PastMarkers</code> field contains </p>
<ul>
<li>only the marker identifier of itself, if the message is marked as a marker.</li>
<li>the marker identifier of its closest past markers (PMs), i.e. from each referenced marker-sequence only the markers with the highest marker rank (<code>MR</code>). Markers which are referenced by other markers in this list <em>shall</em> be removed.</li>
</ul>
<p>The <code>FutureMarkers</code> list <em>shall</em> be empty at the start and <em>shall</em> be updated when a new marker directly or indirectly references that list. </p>
<p>The propagation of a FM to its past cone (i.e. the update of the <code>FutureMarkers</code> list in the encountered messages) <em>shall</em> not continue beyond a message if:</p>
<ol>
<li><code>FutureMarkers</code> of a message includes a previous marker of the same marker-sequence; the message that includes such a marker <em>shall</em> not get updated.</li>
<li>the message is the marker in a different marker-sequence. Then the <code>FutureMarkers</code> <em>shall</em> be updated for that marker only.</li>
</ol>
<p>Through this approach past and future markers do not cross weak parents. It also prevents the lists from growing unboundedly.</p>
<p>The fields <code>MarkerBranchID</code>, <code>PayloadBranchID</code> and <code>IndividualBranchID</code> allow for making connections between the marker DAG, the message DAG and the UTXO branch DAG. When a new Sequence is created the <code>MarkerBranchID</code> is set to the branch that creates the sequence.</p>
<h3 id="4751-update-of-already-booked-messages-on-double-spends"><a class="header" href="#4751-update-of-already-booked-messages-on-double-spends">4.7.5.1 Update of already booked messages on double spends</a></h3>
<p>If a transaction arrives that double spends an already booked transaction, a new marker-sequence <em>shall</em> be created for the newly arrived message (containing the transaction), see Section <a href="4.7%20Markers.html#%204.7.4.2%20Creation%20of%20Marker-sequences">Creation of marker-sequences</a>.</p>
<p>For the already booked conflicting transaction <strong>no</strong> new marker or marker Sequence <em>shall</em> be created. This is because the marker DAG and Sequence DAG <em>shall</em> not be changed post-booking a message. However a new UTXO branch is created.</p>
<p>First, assume the existing booked transaction is a Marker itself. Then the marker gets mapped onto the new branch by updating the field <code>MarkerBranchID</code> in the message metadata. Furthermore, the <code>PayloadBranchID</code> is updated to the new branch. For all FM in the same sequence the <code>MarkerBranchID</code> gets updated to the new branch. Furthermore, for every sequence that directly or indirectly references the sequence in which the double-spend occurs, the first marker is remapped to the new branch as well.</p>
<p>Second, assume the existing transaction is not a marker. Then all messages between the transaction and the following future markers (including the transaction itself) get mapped individually to the new branch mapping using the field <code>IndividualBranchID</code>. From the future markers onwards, the same applies as in the first scenario. </p>
<p>For an example implementation of these scenarios also visit the example <a href="https://github.com/iotaledger/goshimmer/blob/develop/packages/tangle/images/TestBookerMarkerMappings.md">here</a>.</p>
<h2 id="476-marker-application-description"><a class="header" href="#476-marker-application-description">4.7.6 Marker Application Description</a></h2>
<p>Figure 1 shows an example of how the markers and marker-sequences (here also called Sequence) would look in the Tangle from the perspective of the Message DAG, the marker DAG and the marker-sequence DAG. The purple colored messages are markers:</p>
<p><img src="https://i.imgur.com/GENej3O.png" alt="" /></p>
<p><strong>Figure 1: Markers and marker-sequences in the Tangle</strong></p>
<h3 id="4761-example-implementation"><a class="header" href="#4761-example-implementation">4.7.6.1 Example Implementation</a></h3>
<p>An illustrative example of the markers tool in action is provided <a href="https://github.com/iotaledger/goshimmer/blob/develop/packages/tangle/images/TestBookerMarkerMappings.md">here</a> for the prototype implementation. </p>
<h3 id="4762-approval-weight-approximation"><a class="header" href="#4762-approval-weight-approximation">4.7.6.2 Approval weight approximation</a></h3>
<p>To approximate the approval weight of a message, the markers tool retrieves the approval weight of <code>FutureMarkers</code>. Since a given message is in the past cone of its FMs, the approval weight and thus the finality of the message will be at least the same as the maximum weight of its FMs. This gives a lower bound (which is the safe bound), and if the markers are set frequently enough, this provides a good approximation of that bound. </p>
<h3 id="4763-past-cone-check"><a class="header" href="#4763-past-cone-check">4.7.6.3 Past cone check</a></h3>
<p>By comparing the <code>PastMarkers</code> of a message with the <code>FutureMarkers</code> of another message, the markers tool can determine if that message is in the past cone of the other. For example, consider two messages <code>X</code> and <code>Y</code> that are members in the same marker-sequence. Then if <code>PM(X)&gt;FM(Y)</code>, then <code>X</code> is in the future of <code>Y</code>.</p>
<p>One way in which this check can be carried out is by traversing the marker DAG while remaining in the bounds of the marker ranks. </p>
<p>A potential optimization is that the marker-sequence DAG can be traversed while considering the marker-sequence ranks, prior to any traversal of the marker DAG.</p>
<p>It is possible that the marker DAG does not cover certain areas of the message DAG at a given point in time. In this case, a check on this question can return one of the following three values:</p>
<ul>
<li><code>TRUE</code> </li>
<li><code>FALSE</code> </li>
<li><code>N/A</code></li>
</ul>
<p>If the check returns a <code>N/A</code>, then the Message DAG must be searched via a search algorithm.</p>
<p>For an example implementation of the algorithm for the past cone check visit <a href="https://github.com/iotaledger/goshimmer/blob/develop/docs/specification/003-markers.md">GoShimmer markers</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="51-utxo"><a class="header" href="#51-utxo">5.1 UTXO</a></h1>
<h2 id="511-introduction"><a class="header" href="#511-introduction">5.1.1 Introduction</a></h2>
<p>The unspent transaction output (UTXO) model defines a ledger state where balances are not directly associated with addresses but with the outputs of transactions. In this model, transactions specify the outputs of previous transactions as inputs, which are consumed in order to create new outputs. 
A transaction must consume the entirety of the specified inputs. The section unlocking the inputs is called an <em>unlock block</em>. An unlock block may contain a signature proving ownership of a given input's address and/or other unlock criteria.</p>
<p>The following image depicts the flow of funds using UTXO:</p>
<p><img src="https://i.imgur.com/3TdENBW.png" alt="" /></p>
<h2 id="512-transaction-layout"><a class="header" href="#512-transaction-layout">5.1.2 Transaction Layout</a></h2>
<p>A <i>Transaction</i> payload is made up of two parts:</p>
<ol>
<li>The <i>Transaction Essence</i> part contains: version, timestamp, nodeID of the <a href="./5.3%20Mana.html">aMana</a> pledge, nodeID of the <a href="./5.3%20Mana.html">cMana</a> pledge, inputs, outputs and an optional data payload.</li>
<li>The <i>Unlock Blocks</i> which unlock the <i>Transaction Essence</i>'s inputs. In case the unlock block contains a signature, it signs the entire <i>Transaction Essence</i> part.</li>
</ol>
<p>All values are serialized in little-endian encoding (it stores the most significant byte of a word at the largest address and the smallest byte at the smallest address). The serialized form of the transaction is deterministic, meaning the same logical transaction always results in the same serialized byte sequence.</p>
<p>The table describing the entirety of a <i>Transaction</i>'s serialized form is presented in the <a href="./2.3%20Standard%20Payloads%20Layout.html#2.3.5.2-transaction-payload">Section 2.3 Standard Payloads Layout</a>.</p>
<p>See <a href="./2.1%20Datatypes%20and%20Notations.html">Data Types Notation</a>
for understanding the table schema.</p>
<h3 id="5121-transaction-essence"><a class="header" href="#5121-transaction-essence">5.1.2.1 Transaction Essence</a></h3>
<p>The <i>Transaction Essence</i> of a <i>Transaction</i> carries a version, timestamp, nodeID of the <a href="./5.3%20Mana.html">aMana</a> pledge, nodeID of the <a href="./5.3%20Mana.html">cMana</a> pledge, inputs, outputs and an optional data payload.</p>
<h3 id="5122-inputs"><a class="header" href="#5122-inputs">5.1.2.2 Inputs</a></h3>
<p>The <i>Inputs</i> part holds the inputs to consume, that in turn fund the outputs of the <i>Transaction Essence</i>. There is only one supported type of input as of now, the <i>UTXO Input</i>. In the future, more types of inputs may be specified as part of protocol upgrades.</p>
<p>Each defined input must be accompanied by a corresponding <i>Unlock Block</i> at the same index in the <i>Unlock Blocks</i> part of the <i>Transaction</i>. 
If multiple inputs may be unlocked through the same <i>Unlock Block</i>, the given <i>Unlock Block</i> only needs to be specified at the index of the first input that gets unlocked by it. 
Subsequent inputs that are unlocked through the same data must have a <i>Reference Unlock Block</i> pointing to the previous <i>Unlock Block</i>. 
This ensures that no duplicate data needs to occur in the same transaction.</p>
<h4 id="utxo-input"><a class="header" href="#utxo-input">UTXO Input</a></h4>
<table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Input Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 0</strong> to denote an <i>UTXO Input</i>.
            </td>
        </tr>
        <tr>
            <td>Transaction ID</td>
            <td>ByteArray[32]</td>
            <td>The BLAKE2b-256 hash of the transaction from which the UTXO comes from.</td>
        </tr>
        <tr>
            <td>Transaction Output Index</td>
            <td>uint16</td>
            <td>The index of the output on the referenced transaction to consume.</td>
        </tr>
</table>
<p>A <i>UTXO Input</i> is an input which references an output of a previous transaction by using the given transaction's BLAKE2b-256 hash + the index of the output on that transaction. 
A <i>UTXO Input</i> must be accompanied by an <i>Unlock Block</i> for the corresponding type of output the <i>UTXO Input</i> is referencing.</p>
<p>Example: If the input references outputs to an Ed25519 address, then the corresponding unlock block must be of type <i>Signature Unlock Block</i> holding an Ed25519 signature.</p>
<h3 id="5123-outputs"><a class="header" href="#5123-outputs">5.1.2.3 Outputs</a></h3>
<p>The <i>Outputs</i> part holds the outputs to create with this <i>Transaction Payload</i>. There are different types of output: </p>
<ul>
<li><i>SigLockedSingleOutput</i></li>
<li><i>SigLockedAssetOutput</i></li>
</ul>
<h4 id="siglockedsingleoutput"><a class="header" href="#siglockedsingleoutput">SigLockedSingleOutput</a></h4>
<table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Output Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 0</strong> to denote a <i>SigLockedSingleOutput</i>.
            </td>
        </tr>
        <tr>
            <td valign="top">Address <code>oneOf</code></td>
            <td colspan="2">
                 <details>
                    <summary>Ed25519 Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                        </tr>
                    </table>
                </details>
                <details>
                    <summary>BLS Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 1</strong> to denote a <i>BLS Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[49]</td>
                              <td>The raw bytes of the BLS address which is a BLAKE2b-256 hash of the BLS public key.</td>
                        </tr>
                    </table>
                </details>
            </td>
        </tr>
        <tr>
            <td>Balance</td>
            <td>uint64</td>
            <td>The balance of IOTA tokens to deposit with this <i>SigLockedSingleOutput</i> output.</td>
        </tr>
</table>
<p>The <i>SigLockedSingleOutput</i> defines an output holding an IOTA balance linked to a single address; it is unlocked via a valid signature proving ownership over the given address. Such output may hold an address of different types.</p>
<h4 id="siglockedassetoutput"><a class="header" href="#siglockedassetoutput">SigLockedAssetOutput</a></h4>
<table>
        <tr>
            <td><b>Name</b></td>
            <td><b>Type</b></td>
            <td><b>Description</b></td>
        </tr>
        <tr>
            <td>Output Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 1</strong> to denote a <i>SigLockedAssetOutput</i>.
            </td>
        </tr>
        <tr>
            <td valign="top">Address <code>oneOf</code></td>
            <td colspan="2">
                <details>
                    <summary>Ed25519 Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 0</strong> to denote an <i>Ed25519 Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[32]</td>
                            <td>The raw bytes of the Ed25519 address which is a BLAKE2b-256 hash of the Ed25519 public key.</td>
                        </tr>
                    </table>
                </details>
                <details>
                    <summary>BLS Address</summary>
                    <table>
                        <tr>
                            <td><b>Name</b></td>
                            <td><b>Type</b></td>
                            <td><b>Description</b></td>
                        </tr>
                        <tr>
                            <td>Address Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 1</strong> to denote a <i>BLS Address</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Address</td>
                            <td>ByteArray[49]</td>
                              <td>The raw bytes of the BLS address which is a BLAKE2b-256 hash of the BLS public key.</td>
                        </tr>
                    </table>
                </details>
            </td>
        </tr>
        <tr>
            <td>Balances count</td>
            <td>uint32</td>
            <td>The number of individual balances.</td>
            <tr>
                <td valign="top">AssetBalance <code>anyOf</code></td>
                <td colspan="2">
                    <details>
                        <summary>Asset Balance</summary>
                        <blockquote>
                        The balance of the tokenized asset.
                        </blockquote>
                        <table>
                            <tr>
                                <td><b>Name</b></td>
                                <td><b>Type</b></td>
                                <td><b>Description</b></td>
                            </tr>
                            <tr>
                                <td>AssetID</td>
                                <td>ByteArray[32]</td>
                                <td>The ID of the tokenized asset</td>
                            </tr>
                            <tr>
                                <td>Balance</td>
                                <td>uint64</td>
                                <td>The balance of the tokenized asset.</td>
                            </tr>
                        </table>
                    </details>
                </td>
            </tr>
        </tr>
</table>
<p>The <i>SigLockedAssetOutput</i> defines an output holding a balance for each specified tokenized asset linked to a single address; it is unlocked via a valid signature proving ownership over the given address. Such output may hold an address of different types.
The ID of any tokenized asset is defined by the BLAKE2b-256 hash of the OutputID that created the asset.</p>
<h3 id="5124-payload"><a class="header" href="#5124-payload">5.1.2.4 Payload</a></h3>
<p>The payload part of a <i>Transaction Essence</i> may hold an optional payload. This payload does not affect the validity of the <i>Transaction Essence</i>. If the transaction is not valid, then the payload <em>shall</em> be discarded.</p>
<h3 id="5125-unlock-blocks"><a class="header" href="#5125-unlock-blocks">5.1.2.5 Unlock Blocks</a></h3>
<p>The <i>Unlock Blocks</i> part holds the unlock blocks unlocking inputs within a <i>Transaction Essence</i>.</p>
<p>There are different types of <i>Unlock Blocks</i>:</p>
<table>
    <tr>
        <td><b>Name</b></td>
        <td><b>Unlock Type</b></td>
        <td><b>Description</b></td>
    </tr>
    <tr>
        <td>Signature Unlock Block</td>
        <td>0</td>
        <td>An unlock block holding one or more signatures unlocking one or more inputs.</td>
    </tr>
<tr>
        <td>Reference Unlock Block</td>
        <td>1</td>
        <td>An unlock block which must reference a previous unlock block which unlocks also the input at the same index as this <i>Reference Unlock Block</i>.</td>
    </tr>
</table>
<h4 id="signature-unlock-block"><a class="header" href="#signature-unlock-block">Signature Unlock Block</a></h4>
<table>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 0</strong> to denote a <i>Signature Unlock Block</i>.
            </td>
        </tr>
        <tr>
            <td valign="top">Signature <code>oneOf</code></td>
            <td colspan="2">
                <details>
                    <summary>BLS Signature</summary>
                    <table>
                        <tr>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Signature Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 0</strong> to denote a <i>BLS Signature</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Signature</td>
                            <td>ByteArray</td>
                            <td>The signature signing the serialized <i>Transaction Essence</i>.</td>
                        </tr>
                    </table>
                </details>
                 <details>
                    <summary>Ed25519 Signature</summary>
                    <table>
                        <tr>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Signature Type</td>
                            <td>uint8</td>
                            <td>
                                Set to <strong>value 1</strong> to denote an <i>Ed25519 Signature</i>.
                            </td>
                        </tr>
                        <tr>
                            <td>Public key</td>
                            <td>ByteArray[32]</td>
                            <td>The public key of the Ed25519 keypair which is used to verify the signature.</td>
                        </tr>
                        <tr>
                            <td>Signature</td>
                            <td>ByteArray[64]</td>
                            <td>The signature signing the serialized <i>Transaction Essence</i>.</td>
                        </tr>
                    </table>
                </details>
            </td>
        </tr>
</table>
<p>A <i>Signature Unlock Block</i> defines an <i>Unlock Block</i> which holds one or more signatures unlocking one or more inputs.
Such a block signs the entire <i>Transaction Essence</i> part of a <i>Transaction Payload</i> including the optional payload.</p>
<h4 id="reference-unlock-block"><a class="header" href="#reference-unlock-block">Reference Unlock block</a></h4>
<table>
        <tr>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Unlock Type</td>
            <td>uint8</td>
            <td>
                Set to <strong>value 1</strong> to denote a <i>Reference Unlock Block</i>.
            </td>
        </tr>
        <tr>
            <td>Reference</td>
            <td>uint16</td>
            <td>Represents the index of a previous unlock block.</td>
        </tr>
</table>
<p>A <i>Reference Unlock Block</i> defines an <i>Unlock Block</i> that references a previous <i>Unlock Block</i> (that must not be another <i>Reference Unlock Block</i>). It must be used if multiple inputs can be unlocked through the same origin <i>Unlock Block</i>.</p>
<p>Example:
Consider a <i>Transaction Essence</i> containing <i>UTXO Inputs</i> A, B and C, where A and C are both spending the UTXOs originating from the same Ed25519 address. The <i>Unlock Block</i> part must thereby have the following structure:</p>
<table><thead><tr><th>Index</th><th>Must Contain</th></tr></thead><tbody>
<tr><td>0</td><td>A <i>Signature Unlock Block</i> holding the corresponding Ed25519 signature to unlock A and C.</td></tr>
<tr><td>1</td><td>A <i>Signature Unlock Block</i> that unlocks B.</td></tr>
<tr><td>2</td><td>A <i>Reference Unlock Block</i> that references index 0, since C also gets unlocked by the same signature as A.</td></tr>
</tbody></table>
<h2 id="513-validation"><a class="header" href="#513-validation">5.1.3 Validation</a></h2>
<p>A <i>Transaction</i> payload has different validation stages since some validation steps can only be executed at the point when certain information has (or has not) been received. We, therefore, distinguish between syntactical and semantic validation.</p>
<h3 id="5131-transaction-syntactical-validation"><a class="header" href="#5131-transaction-syntactical-validation">5.1.3.1 Transaction Syntactical Validation</a></h3>
<p>This validation can commence as soon as the transaction data has been received in its entirety. It validates the structure but not the signatures of the transaction. A transaction must be discarded right away if it does not pass this stage.</p>
<p>The following criteria define whether the transaction passes the syntactical validation:</p>
<ul>
<li>Transaction Essence:
<ul>
<li><code>Transaction Essence Version</code> value must be 0.</li>
<li>The <code>timestamp</code> of the <i>Transaction Essence</i> must be older than (or equal to) the <code>timestamp</code> of the message
containing the transaction by at most 10 minutes.</li>
<li>A <i>Transaction Essence</i> must contain at least one input and output.</li>
</ul>
</li>
<li>Inputs:
<ul>
<li><code>Inputs Count</code> must be 0 &lt; x &lt; 128.</li>
<li>At least one input must be specified.</li>
<li><code>Input Type</code> value must be 0, denoting an <code>UTXO Input</code>.</li>
<li><code>UTXO Input</code>:
<ul>
<li><code>Transaction Output Index</code> must be 0  x &lt; 128.</li>
<li>Every combination of <code>Transaction ID</code> + <code>Transaction Output Index</code> must be unique in the inputs set.</li>
</ul>
</li>
<li>Inputs must be in lexicographical order of their serialized form.<sup>1</sup></li>
</ul>
</li>
<li>Outputs:
<ul>
<li><code>Outputs Count</code> must be 0 &lt; x &lt; 128.</li>
<li>At least one output must be specified.</li>
<li><code>Output Type</code> must be 0, denoting a <code>SigLockedSingleOutput</code>.</li>
<li><code>SigLockedSingleOutput</code>:
<ul>
<li><code>Address Type</code> must either be 0 or 1, denoting an <code>Ed25519</code> - or <code>BLS</code> address .</li>
<li>The <code>Address</code> must be unique in the set of <code>SigLockedSingleOutputs</code>.</li>
<li><code>Amount</code> must be &gt; 0.</li>
</ul>
</li>
<li>Outputs must be in lexicographical order by their serialized form.<sup>1</sup></li>
<li>Accumulated output balance must not exceed the total supply of tokens <code>2,779,530,283,277,761</code>.</li>
</ul>
</li>
<li><code>Payload Length</code> must be 0 (to indicate that there's no payload) or be valid for the specified payload type.</li>
<li><code>Payload Type</code> must be one of the supported payload types if <code>Payload Length</code> is not 0.</li>
<li><code>Unlock Blocks Count</code> must match the number of inputs. Must be 0 &lt; x &lt; 128.</li>
<li><code>Unlock Block Type</code> must either be 0 or 1, denoting a <code>Signature Unlock Block</code> or <code>Reference Unlock block</code>.</li>
<li><code>Signature Unlock Blocks</code> must define either an <code>Ed25519</code>- or <code>BLS Signature</code>.</li>
<li>A <code>Signature Unlock Block</code> unlocking multiple inputs must only appear once (be unique) and be positioned at the same index of the first input it unlocks. All other inputs unlocked by the same <code>Signature Unlock Block</code> must have a companion <code>Reference Unlock Block</code> at the same index as the corresponding input that points to the origin <code>Signature Unlock Block</code>.</li>
<li><code>Reference Unlock Blocks</code> must specify a previous <code>Unlock Block</code> that is not of type <code>Reference Unlock Block</code>. The referenced index must therefore be smaller than the index of the <code>Reference Unlock Block</code>.</li>
<li>Given the type and length information, the <i>Transaction</i> must consume the entire byte array the <code>Payload Length</code> field in the <i>Message</i> defines.</li>
</ul>
<p><sup>1</sup> ensures that serialization of the transaction becomes deterministic, meaning that libraries always produce the same bytes given the logical transaction.</p>
<h3 id="5132-transaction-semantic-validation"><a class="header" href="#5132-transaction-semantic-validation">5.1.3.2 Transaction Semantic Validation</a></h3>
<p>The following criteria define whether the transaction passes the semantic validation:</p>
<ol>
<li>All the UTXOs the transaction references are known (booked) and unspent.</li>
<li>The transaction is spending the entirety of the funds of the referenced UTXOs to the outputs.</li>
<li>The address type of the referenced UTXO must match the signature type contained in the corresponding <i>Signature Unlock Block</i>.</li>
<li>The <i>Signature Unlock Blocks</i> are valid, i.e. the signatures prove ownership over the addresses of the referenced UTXOs.</li>
</ol>
<p>If a transaction passes the semantic validation, its referenced UTXOs <em>shall</em> be marked as spent and the corresponding new outputs <em>shall</em> be booked/specified in the ledger. This process is described in <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger state</a>.</p>
<p>Transactions that do not pass semantic validation <em>shall</em> be discarded. Their UTXOs are not marked as spent and neither are their outputs booked into the ledger. Moreover, their messages <em>shall</em> be considered invalid.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="52-ledger-state"><a class="header" href="#52-ledger-state">5.2 Ledger State</a></h1>
<p>The introduction of a voting-based consensus requires a fast and easy way to determine a node's initial opinion for every received transaction. This includes the ability to both detect double spends and transactions that try to spend non-existing funds. 
These conditions are fulfilled by the introduction of an Unspent Transaction Output (UTXO) model for record-keeping, which enables the validation of transactions in real time, see also the section on <a href="./5.1%20UTXO.html">UTXO</a>.</p>
<p>The concept of UTXO style transactions is directly linked to the creation of a directed acyclic graph (DAG), in which the vertices are transactions and the links between these are determined by the outputs and inputs of transactions. </p>
<p>To deal with double spends and leverage on certain properties of UTXO, we introduce the Realities Ledger State. </p>
<h2 id="521-realities-ledger-state"><a class="header" href="#521-realities-ledger-state">5.2.1 Realities Ledger State</a></h2>
<p>In the Realities Ledger State, we model the different perceptions of the ledger state that exist in the Tangle. In each reality on its own there are zero conflicting transactions. 
Each reality thus forms an in itself consistent UTXO sub-DAG, where every transaction references any other transaction correctly.</p>
<p>Since outputs of transactions can only be consumed once, a transaction that double spends outputs creates a persistent branch in a corresponding UTXO DAG. Each branch receives a unique identifier <code>branchID</code>. These branches cannot be merged by any vertices (transactions). 
A transaction that attempts to merge incompatible branches fails to pass a validity check and is marked as invalid.</p>
<p>The composition of all realities defines the Realities Ledger State. </p>
<p>From this composition nodes are able to know which possible outcomes for the Tangle exist, where they split, how they relate to each other, if they can be merged and which messages are valid tips. All of this information can be retrieved in a fast and efficient way without having to walk the Tangle. </p>
<p>Ultimately, for a set of competing realities, only one reality can survive. It is then up to the consensus protocol to determine which branch is part of the eventually accepted reality.</p>
<p>In total the ledger state thus involves three different layers:</p>
<ul>
<li>the <a href="5.2%20Ledger%20State.html#5.2.2%20The%20UTXO%20DAG">UTXO DAG</a>,</li>
<li>its extension to the corresponding <a href="5.2%20Ledger%20State.html#5.2.3%20Branches">branches</a> and the <a href="5.2%20Ledger%20State.html#5.2.3.3%20The%20branch%20DAG">branch DAG</a>,</li>
<li>the Tangle, which maps the parent relations between messages and thus also transactions.</li>
</ul>
<h2 id="522-the-utxo-dag"><a class="header" href="#522-the-utxo-dag">5.2.2 The UTXO DAG</a></h2>
<p>The UTXO DAG models the relationship between transactions, by tracking which outputs have been spent by what transaction, see also the section on <a href="./5.1%20UTXO.html">UTXO</a>. Since outputs can only be spent once, we use this property to detect double spends. </p>
<p>We allow for different versions of the ledger to coexist temporarily. 
This is enabled by extending the UTXO DAG by the introduction of branches (see the following section). We can then determine which conflicting versions of the ledger state exist in the presence of conflicts.
Thus, we allow for different versions of the ledger to coexist temporarily. </p>
<h3 id="5221-conflict-sets-and-detection-of-double-spends"><a class="header" href="#5221-conflict-sets-and-detection-of-double-spends">5.2.2.1 Conflict sets and detection of double spends</a></h3>
<p>For every output we maintain a list of consumers <code>consumerList</code>, and where the consumers have the unique identifier <code>consumerID</code>. For a given output this list keeps track of which transactions have spent that particular output. For every spending transaction we add an element with <code>consumerID=transactionID</code>.
Outputs without consumers are considered to be unspent outputs. Transactions that consume an output that have more than one consumer are considered to be double spends. </p>
<p>When there are more than one consumer in the consumer list we <em>shall</em> create a conflict set list <code>conflictSet</code>, whose elements have a unique identifier <code>conflictID</code> each. The <code>conflictSet</code> is uniquely identified by the unique identifier <code>conflictSetID</code>. Since the <code>outputID</code> is directly and uniquely linked to the conflict set, we set <code>conflictSetID=outputID</code>. For every transaction that <em>shall</em> be added to the conflict set we add an element with <code>conflictID=transactionID</code>.</p>
<h2 id="523-branches"><a class="header" href="#523-branches">5.2.3 Branches</a></h2>
<p>The UTXO model and the concept of solidification, see section <a href="./4.4%20Solidification.html">4.4 - Solidification</a>, makes all non-conflicting transactions converge to the same ledger state no matter in which order the transactions are received. Messages containing these transactions could always reference each other in the Tangle without limitations.</p>
<p>However, every double spend creates a new possible version of the ledger state that will no longer converge. Whenever a double spend is detected (see the previous section), we track the outputs created by the conflicting transactions and all of the transactions that spend these outputs, by creating a container for them in the ledger which we call a branch. </p>
<p>More specifically a container <code>branch</code> <em>shall</em> be created for each transaction that double spends one or several outputs, or if messages aggregate those branches.
Every transaction that spends directly or indirectly from a transaction that created a branch, i.e. double spent funds, is also contained in this <code>branch</code> or one of its child branches.
Note that a branch that was created by a transaction that spends multiple outputs can be part of multiple conflict sets.</p>
<p>In other words, a branch is a downward closed, conflict free collection of conflicts.</p>
<p>Every branch <em>shall</em> be identified by the unique identifier <code>branchID</code>. We consider two kinds of branches: conflict branches and aggregated branches, which are explained in the following sections.</p>
<h3 id="5231-conflict-branches"><a class="header" href="#5231-conflict-branches">5.2.3.1 Conflict branches</a></h3>
<p>A conflict branch is created by a corresponding double spend transaction. Since the transaction identifier is unique, we choose the transaction id <code>transactionID</code> of the double spending transaction as the <code>branchID</code>.</p>
<p>Outputs inside a branch can be double spent again, recursively forming sub-branches. </p>
<p>On solidification of a message, we <em>shall</em> store the corresponding <code>branchID</code> together with every output, as well as the transaction metadata to enable instant lookups of this information. Thus, on solidification, a transaction can be immediately associated with a branch. </p>
<h3 id="5232-aggregated-branches"><a class="header" href="#5232-aggregated-branches">5.2.3.2 Aggregated branches</a></h3>
<p>A transaction that does not create a double spend inherits the branches of the input's branches. In the simplest case, where there is only one input branch the transaction inherits that branch. 
If outputs from multiple non-conflicting branches are spent in the same transaction, then the transaction and its resulting outputs are part of an aggregated branch.  This type of branch is not part of any conflict set. Rather it simply combines the perception that the individual conflict branches associated to the transaction's inputs are the ones that will be accepted by the network. </p>
<p>Furthermore, since a message inherits the branches from its parents, it also can create aggregated branches.</p>
<p>Each aggregated branch <em>shall</em> have a unique identifier <code>branchID</code>, which is the same type as for conflict branches. Furthermore, the container for an aggregated branch is also of type <code>branch</code>. </p>
<p>To calculate the unique identifier of a new aggregated branch, we take the identifiers of the branches that were aggregated, sort them lexicographically and hash the concatenated identifiers once:</p>
<pre><code class="language-vbnet"># AggregatedBranchID returns the identifier for an aggregated branch.
FUNCTION aggregatedBranchID = GetAggregatedBranchID(branchIDs)
    sortedBranchIDs = Sort(branchIDs)
    RETURN Hash(sortedBranchIDs)
</code></pre>
<p>An aggregated branch can't aggregate other aggregated branches. However, it can aggregate the conflict branches that are part of the referenced aggregated branch. 
Thus aggregated branches have no further branches as their children and they remain tips in the branch DAG. Furthermore, the sortation of the <code>branchID</code>s in the function <code>AggregatedBranchID()</code> ensures that even though messages can attach at different points in the Tangle and aggregate different aggregated branches they are treated as if they are in the same aggregated branch <strong>if</strong> the referenced conflict branches are the same. </p>
<p>These properties allow for an efficient reduction of a set of branches. In the following we will require the following fields as part of the branch data: </p>
<ul>
<li><code>isConflictBranch</code> is a boolean flat that is <code>TRUE</code> if the branch is a conflict branch or <code>FALSE</code> if its an aggregated branch.</li>
<li><code>parentBranches</code> contains the list of parent conflict branches of the branch, i.e. the conflict branches that are directly referenced by this branch.</li>
</ul>
<p>Then the following function takes a list of branches (which can be either conflict or aggregated branches) and returns a unique set of conflict branches that these branches represent. This is done by replacing duplicates and extracting the parent conflict branches from aggregated branches. </p>
<pre><code class="language-vbnet">FUNCTION reducedBranches = ReduceBranches(branches)
    FOR branch IN branches
        IF branch.isConflictBranch
            IF NOT (branch IN reducedBranches)
                Append(reducedBranches,branch)
        ELSE
            FOR parentBranch IN branch.parentBranches
                IF NOT (parentBranch IN reducedBranches)
                    Append(reducedBranches,parentBranch)
    RETURN reducedBranches
</code></pre>
<h3 id="5233-the-branch-dag"><a class="header" href="#5233-the-branch-dag">5.2.3.3 The branch DAG</a></h3>
<p>A new branch is created for each transaction that is part of a conflict set, or if a transaction aggregates branches.</p>
<p>In the branch DAG, branches constitute the vertices of the DAG. A branch that is created by a transaction that is spending outputs from other branches has edges pointing to those branches.
The branch DAG maps the UTXO DAG to a simpler structure that ignores details about relations between transactions inside the branches and instead retains only details about the interrelations of conflicts.</p>
<p>The set of all non-conflicting transactions form the master branch. Thus, at its root the branch DAG has the master branch, which consists of non-conflicting transaction and resolved transactions. From this root of the branch DAG the various branches emerge. </p>
<p>In other words the conflict branches and the aggregated branches appear as the children of the master branch. </p>
<h3 id="5234-detecting-conflicting-branches"><a class="header" href="#5234-detecting-conflicting-branches">5.2.3.4 Detecting conflicting branches</a></h3>
<p>Branches are conflicting if they, or any of their ancestors, are part of the same conflict set.</p>
<p>The branch DAG can be used to check if branches are conflicting, by applying an operation called normalization, to a set of input branches.</p>
<p>From this information we can identify messages or transactions that are trying to combine branches belonging to conflicting double spends, and thus introduce an invalid perception of the ledger state.</p>
<p>Since branches represent the ledger state associated with a double spend and sub-branches implicitly share the perception of their parents, we define a function <code>NormalizeBranches()</code> to normalize a list of branches and that gets rid of all branches that are referenced by other branches in that list. The function returns <code>NULL</code> if the branches are conflicting and can not be merged.</p>
<p>In order to explain this function in pseudo code we require the following global variables </p>
<ul>
<li>seenConflictSets = map[]conflictSetID</li>
<li>traversedBranches = map[]branch</li>
<li>parentsToCheck = map[]branch</li>
</ul>
<p>as well as a function <code>BranchCheck()</code> that performs certain checks and returns <code>TRUE</code> when the branch is conflicting with a previously seen branch. However, we note that this is an implementation detail that must not match the implementation.</p>
<pre><code class="language-vbnet"># reduce list of branches to normalized branches, and return NULL when detecting conflicting branches
FUNCTION normalizedBranches = NormalizeBranches(initialBranches)
    IF Len(initialBranches) == 0
        RETURN masterBranch
    IF Len(initialBranches) == 1
        RETURN initialBranches

    # check original set of branches
    normalizedBranches = ReduceBranches(initialBranches)
    FOR branch IN normalizedBranches
        BranchCheck(branch)

    # check every ancestor
    WHILE Len(parentsToCheck) != 0
        branch = parentsToCheck[0]
        Delete(parentsToCheck,branch) # delete this branch from the list
        # remove this ancestor
        IF branch IN normalizedBranches
            Delete(normalizedBranches,branch)
        # if branch check fails, i.e. a conflict set was seen twice, return a null list
        IF BranchCheck(branch) 
            RETURN NULL

    RETURN normalizedBranches
</code></pre>
<p>The branch check function <code>BranchCheck()</code> checks if the branch was already traversed, i.e. we have handled this branch already. Then it checks if the branch's conflict set has been already seen, which proofs that the current branch conflicts with an already traversed branch. Lastly it adds new branches to the queue of branches that should be traversed.</p>
<pre><code class="language-vbnet">FUNCTION isConflicting = BranchCheck(branch)
    # abort if branch was traversed already
    IF branch IN traversedBranches 
        RETURN FALSE
    ELSE 
        Append(traversedBranches,branch.ID)
    # check if conflict set was seen twice
    IF branch.conflictSetID IN seenConflictSets
        RETURN TRUE
    ELSE 
        Append(seenConflictSets,branch.conflictSetID)

    # queue parents to be checked when traversing ancestors
    FOR parentBranch IN branch.parentBranches
        IF branch NOT IN parentsToCheck
            Append(parentsToCheck,parentBranch)
    RETURN FALSE
</code></pre>
<h3 id="5235-merging-of-branches"><a class="header" href="#5235-merging-of-branches">5.2.3.5 Merging of branches</a></h3>
<p>A branch gains approval weight when messages from (previously non-attached) <code>nodeID</code>s attach to messages in the future cone of that branch. Once the approval weight exceeds a certain threshold we consider the branch as confirmed, see also section <a href="./6.4%20Finalization.html"><strong>6.4</strong> Finality</a>.</p>
<p>However, there are two special cases of branches:</p>
<p>First the branch that is created by the genesis transaction is called master branch and has the identifier <code>masterBranchID</code>. The <code>masterBranchID</code> is confirmed on creation and thus it is the &quot;correct&quot; reality by definition.
Once a conflict branch is confirmed, it can be merged into the master branch. Since the approval weight is monotonically increasing for branches from the past to the future, branches are only merged into the master branch.</p>
<p>Second, a branch <code>rejectedBranch</code> is created that is rejected by definition, and it has the identifier <code>rejectedBranchID</code>. 
Messages that are contained in a rejected branch or in one its child branches are booked into the <code>rejectedBranch</code>.</p>
<h2 id="524-relation-to-the-tangle"><a class="header" href="#524-relation-to-the-tangle">5.2.4 Relation to the Tangle</a></h2>
<p>Since messages in the Tangle are dependent on the fate of the messages they approve, we <em>shall</em> create dependencies between payloads, messages, and branches.  The branch ID of a message or of a transaction represents all the conflicts upon which that object depends.  Specifically, we associate a branch to a payload and to a message in the following way.</p>
<ul>
<li>The branch of a non-value payload is always the master branch.</li>
<li>The branch of a transaction is assigned in one of two ways:
<ul>
<li>If the transaction is a conflict, then a new branch  is created whose branchID is that transactionID.  The transaction gets assigned to this new branch.</li>
<li>Otherwise, the transaction is assigned to the aggregated branch of all its inputs.</li>
</ul>
</li>
<li>The branch of a message is the aggregate of 
<ul>
<li>The branch of its payload</li>
<li>The branches of each strong parent</li>
<li>The branches of the payloads of the weak parents.</li>
</ul>
</li>
</ul>
<p>This assignments captures the essence of weak and strong parents, see <a href="./4.3%20Tip%20Selection%20Algorithm.html">Section 4.3 - Tip Selection Specification</a>.  Strong arrows pick up the dependencies of the whole past cone, where as the weak arrows only penetrate to the paylaod of the parent, ignoring the history of the parent.<br />
We that a message  \(M\) (resp. transaction \(X\)) belongs to a branch \(B\) if the branch \(A\) of \(M\) (resp. \(X\)) is in the branch past of \(B\).  Thus, branches, represent certain coherent sections of the Tangle which are then ordered by inclusion.<br />
After a message is solidified, it and its payload are both assigned to their branch.  During this check, the message is flagged as invalid if:</p>
<ul>
<li>The payload is a transaction, and the node cannot aggregate branchIDs of the  transaction's input into a valid branchID.</li>
<li>The branchIF of the message cannot be aggregated.
If these branchID's cannot be computed, then the message contains a pair of its history, and thus does not support a coherent view of the ledger.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="53-mana"><a class="header" href="#53-mana">5.3 Mana</a></h1>
<h2 id="531-introduction"><a class="header" href="#531-introduction">5.3.1 Introduction</a></h2>
<p>This section introduces  <em>access Mana</em> and <em>consensus Mana</em> and determines which modules use each of these two types of Mana.</p>
<p>Any permissionless system needs a Sybil protection mechanism. In Coordicide, this is done by forcing every node to create a node identity (see also <a href="./2.1%20Peer%20Discovery.html">Section 3.3 - Peer Discovery</a>). Since the creation of an arbitrarily large number of identities is not an expensive operation, two <em>Difficult-to-obtain</em> resources are linked to each node identity; we call them <em>access Mana</em>(<strong>aMana</strong>) and <em>consensus Mana</em> (<strong>cMana</strong>). Both kinds of Mana can be described as essential resources to multiple parts of the network. They are related to the IOTA token, but are not tokens by themselves <!--(????? add a good explanation here)--> and do not interfere with the token balance in any direct way. When a transaction is processed, a certain amount of aMana and cManadependent on the amount of IOTAs moved by the transactionwill be pledged to nodes specified in the transaction (their node IDs must be specified as defined in <a href="./2.2%20Standard%20Payloads%20Layout.html">Section 2.2 - Standard Payloads Layout</a>). The access and consensus Mana pledged to each node ID must be stored as an extension of the ledger state. The only way a node can obtain aMana or cMana is to convince some ken holders to pledge to it. Both kinds of Mana provides adequate Sybil protection because they are difficult and costly to be acquired in arbitrarily large amounts.</p>
<p>Access and consensus Mana are used as Sybil protection in different modules, which have different natures and requirements. For this reason, it is natural to use different formulas to calculate the appropriate Mana to each module. Consensus Mana should be seen as the Mana that is responsible for the security of the system, on the other hand, access Mana is used to distribute access to the network during congestion periods.</p>
<p>We give a short overview on how each module uses its associated kind of Mana:</p>
<ul>
<li><a href="./3.4%20Neighbor%20Selection.html">Section 3.4 - Neighbor Selection</a>:  Nodes only establish a connection with nodes of similar consensus Mana.</li>
<li><a href="./4.6%20Congestion%20Control.html">Section 4.6 - Congestion Control</a>: The throughput (in bytes per second) of each node is dependent on the access Mana held.</li>
<li><a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Section 6.3 -  Fast Probabilistic Consensus</a>: The selection probability for a node during a voting query is proportional to the consensus Mana held.</li>
<li><a href="./6.4%20Finalization.html">Section 6.4 - Finalization</a>: Finalization occurs when (among other criteria) a message is approved by nodes holding a certain fraction of the consensus Mana in the network.</li>
<li><a href="./6.6%20dRNG.html">Section 6.6 - Distributed Random Number Generator</a>: The dRNG committee members must be composed by high consensus Mana nodes.</li>
</ul>
<h2 id="532-detailed-design---general"><a class="header" href="#532-detailed-design---general">5.3.2. Detailed Design - General</a></h2>
<p>Each transaction must have an <code>accessManaNodeID</code> and a <code>consensusManaNodeID</code> field to determine which node to pledge these two types of Mana. Both of these fields consist of a node ID of the node that will receive each kind of Mana. Access Mana and consensus Mana do not have to be pledged to the same node.</p>
<p>Both kinds of Mana are <em>exponential moving averages</em> (EMA) of the <em>base Manas</em> (specifically, cMana is the EMA of base cMana, and aMana is the EMA of base aMana). An EMA is a type of moving average that places a greater weight and significance on the most recent data points. More precisely, the weighting for older data decreases exponentially in time, however, never reaching zero.  <!--For more information on this subject, see ?????LINK. --> </p>
<p>Even though the definition of an EMA should be unique (no matter to which function that you apply it), the general algorithm for the calculation of the EMAswith the flexibility needed in our caseis not easily implementable. Thus, two different algorithms already customized for each type of Mana are provided in the present document.</p>
<p>We define the following parameters:</p>
<ul>
<li>\(\gamma\)- decay factor for base aMana.</li>
<li>\(\alpha\)- moving average factor for the cMana. </li>
<li>\(\beta\)- moving average factor for the aMana. </li>
</ul>
<p>Additionally, we define four vectors that assign a real value to each node Id: the <em>aMana vector</em>, <em>base aMana vector</em>, <em>cMana vector</em> and base <em>cMana vector</em>. The base aMana vector and the base cMana vector are auxiliary vectors (meaning that they are needed to compute the aMana vector and the cMana vector, even though their values are not directly used in any of the modules). Due to the time dependance of the EMA (and also the base aMana function), the four vectors have a <em>reference time</em> to which they are associated.</p>
<p>The Mana vectors are updated in different occasions. Access Mana pledging happens when a transaction is booked on the ledger state. At the same time, entries of the nodes whose aMana is not being modified during the pledging are updated only with respect to the (possibly) newer time reference. In general, updates only due to time (without aMana pledging) happen whenever a node's aMana is being accessed by an external module (as the congestion control, for instance). </p>
<p>On the other hand, cMana is updated only relatively to the end of each epoch (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>). The reason behind this is that epochs are objective, i.e. all nodes agree on which epoch a certain message (or transaction) belongs to. Thus, since nodes agree (with high probability) about transactions with timestamps older than the end of the epoch plus <code>TIMESTAMP_CUTOFF</code> (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>), they will consequently agreeagain, with high probabilityabout the cMana vector relative to these transactions. </p>
<p>Therefore, one can assume that the nodes in sync will (with high probability) agree on values of cMana relative to the set of transactions that have timestamp older than a fixed epoch in the past. On the other hand, aMana will capture recent fluctuations, but nodes are expected to have slightly different perceptions of this quantity.</p>
<h2 id="533-detailed-design---consensus-mana"><a class="header" href="#533-detailed-design---consensus-mana">5.3.3 Detailed Design - Consensus Mana</a></h2>
<p>The base cMana of a node <code>nodeID</code> at time <code>time</code> is defined as the sum over all unspent outputs at time <code>time</code> of transactions  with  <code>consensusManaNodeID = nodeID</code>. This means that, when an output is consumed, its cMana pledge is revoked and pledged to a (possibly) different node. See the example below: </p>
<p><strong>Example 1:</strong></p>
<p>Suppose transaction \(z\) was booked and we want to update the base cMana vector accordingly. Additionally, suppose transaction \(z\), \(x\) and \(y\) pledges cMana to nodes \(N_z\),  \(N_x\) and \(N_y\), respectively.</p>
<p style="text-align: center;">
<img src="https://github.com/iotaledger/Coordicide-Specifications/blob/section/mana/images/cmana.png" />
</p>
<p>The update of the base cMana proceeds as follows: </p>
<ol>
<li>Add 300 to the base cMana state of the node \(N_z\).</li>
<li>Subtract 100 from the base cMana state of the node \(N_x\).</li>
<li>Subtract 200 from the base cMana state of the node \(N_y\).</li>
</ol>
<p>If a transaction \(T_i\) with timestamp \(t_i\) pledges \(M_i\) cMana to a node \(Z\), then the cMana evolution over time relative to this transaction will be given by:</p>
<p>$$
\text{cMana}_Z^{T_i}(t) = \begin{cases}
0, \text{ if } t&lt; t_i \\
M_i\left(1-e^{-\alpha (t-t_i)}\right), \text{ if } t\geq t_i  \
\end{cases}
$$</p>
<p>The total cMana of a node \(Z\) will be, then, given by the sum of \(\text{cMana}_Z^{T_i}(t)\) among all the transactions \(T_i\) that pledge cMana to node \(Z\). Nevertheless, computing the mana using this equation may be excessively demanding in the case where a node has multiples pledges at different times. For that reason, the cMana shall be computed recursively, updating it based on its last value. This update is customized for three different situations (here, \(t_0\) is the reference time of the previous cMana value):</p>
<ol>
<li>pledging of the cMana relative to a transaction with timestamp smaller than \(t_0\).</li>
<li>pledging of the cMana relative to a transaction with timestamp larger than \(t_0\).</li>
<li>updating the cMana to a time \(t_1&gt;t_0\) without any new cMana pledging.</li>
</ol>
<p>In the first case, the reference time of the cMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the cMana to a point in the past (relatively to the last cMana calculated). The exact update procedure for each of the cases defined above are defined next.</p>
<h3 id="5331-consensus-mana-update-procedure"><a class="header" href="#5331-consensus-mana-update-procedure">5.3.3.1 Consensus Mana update procedure</a></h3>
<h4 id="pledging-the-cmana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time"><a class="header" href="#pledging-the-cmana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time">Pledging the cMana relative to a transaction with timestamp smaller than the last reference time</a></h4>
<p>Suppose that the last reference time is \(t\) and the transaction timestamp is \(t-s\). The update must be done in two steps, always in the order specified below:</p>
<ul>
<li>
<p><em>a</em>) <strong>Base cMana update</strong>. Just before updating the base cMana vector we must store it, since the last base cMana state (that we call \(\text{Old_Base_cMana}\)) and the time relative to the last update are used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector is updated.</p>
<p>The update of the base cMana state goes as follows: if a new transaction with \(n\) inputs of values \(x_1, x_2, \ldots, x_n\) pledges cMana to a node \(N\), then</p>
<ol>
<li>we add \(\sum_{j=1}^{n}x_j\) to the base cMana of the node \(N\).</li>
<li>Each input \(I_j\) corresponds to some UTXO (and, consequently, to some transaction) stored in the ledger state. Then, we locate the node Id (let us say, \(\text{Node}_j\)) to whom the cMana relative to this output was pledged to in the past. Then, we subtract \(x_j\) from the base cMana state of the node \(\text{Node}_j\), for each \(I_j\), \(j=1,\dots,n\).</li>
</ol>
</li>
<li>
<p><em>b</em>) <strong>Pledging and revoking cMana</strong>. If the base cMana balance of node \(i\) (before we added this transaction) was \(\text{Old_Base_cMana}(\text{Node}_i)\) and the new base cMana balance (after the addition of this transaction) is \(\text{Base_cMana}(\text{Node}_i)\), then we update the cMana vector adding to all nodes' entry the term:</p>
<p>$$
(1-e^{-\alpha s})[\text{Base_cMana}(\text{Node}_i)-\text{Old_Base_cMana}(\text{Node}_i)]
$$</p>
<p>The term above can be negativesince some nodes have their base cMana revokedbut the resulting cMana must not be. Notice that for most nodes (specifically, for all nodes that did not have their base cMana value changed) the value above is zero.</p>
</li>
</ul>
<h4 id="pledging-the-cmana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time"><a class="header" href="#pledging-the-cmana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time">Pledging the cMana relative to a transaction with timestamp larger than the last reference time</a></h4>
<p>Suppose that the last reference time is \t-s\ and the transaction timestamp is \t\. The update must be done in two steps, always in the order specified below:</p>
<ul>
<li>
<p><em>a</em>) <strong>Base cMana update</strong>. Just before updating the base cMana vector we must store it, since the last base cMana state (that we call \(\text{Old_Base_cMana}\)) and the time relative to the last update are used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector is updated.</p>
<p>The update of the base cMana state goes as follows: if a new transaction with \(n\) inputs of respective values \(x_1, x_2, \ldots, x_n\) pledges cMana to a node \N\, then</p>
<ol>
<li>we add \(\sum_{j=1}^{n}x_j\) to the base cMana of the node \(N\).</li>
<li>Each input \(I_j\) corresponds to some UTXO (and, consequently, to some transaction) stored in the ledger state. Then, we locate the node Id (let us say, \(\text{Node}_j\)) to whom the cMana relative to this output was pledged to in the past. Then, we subtract \(x_j\) from the base cMana state of the node \(\text{Node}_j\), for each \(I_j\), \(j=1,\dots,n\).</li>
</ol>
</li>
<li>
<p><em>b</em>) <strong>Updating the cMana with respect to time</strong>. Suppose that the outdated cMana is \(\text{Old_cMana}\). We update all cMana entries as follows:</p>
<p>$$
\text{cMana}(\text{Node}_i)=e^{-\alpha s} \text{Old_cMana}(\text{Node}_i)+(1-e^{-\alpha s})\text{Old_Base_cMana}(\text{Node}_i)
$$
where \(\alpha\) is the moving average parameter for the cMana. </p>
</li>
</ul>
<h4 id="updating-the-cmana-to-a-time-larger-than-the-last-reference-time-without-any-new-cmana-pledging"><a class="header" href="#updating-the-cmana-to-a-time-larger-than-the-last-reference-time-without-any-new-cmana-pledging">Updating the cMana to a time larger than the last reference time without any new cMana pledging</a></h4>
<p>Suppose that the last reference time is \(t-s\), the new one is \(t\) and the last cMana vector is \(\text{Old_cMana}\). We update all cMana entries as follows:</p>
<p>$$ \text{cMana}(\text{Node}_i)=e^{-\alpha s} \text{Old_cMana}(\text{Node}_i)+(1-e^{-\alpha s})\text{Old_Base_cMana}(\text{Node}_i)$$
where \(\alpha\) is the moving average parameter for the cMana. </p>
<h3 id="5332-active-consensus-mana-and-epochs"><a class="header" href="#5332-active-consensus-mana-and-epochs">5.3.3.2 Active Consensus Mana and Epochs</a></h3>
<p>The consensus Mana of a node is only calculated and stored relatively to the end of each epoch (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>). Only the values of the last <code>MAX_STORED_EPOCHS</code> epochs are stored. Thus, if \(t_E\) is the time of the end of epoch \(E\), to update the cMana vector from epoch \(E-1\) to \(E\), a node must perform the following algorithm:</p>
<ol>
<li>
<p>Update the cMana with respect to time, as described in section 4.3.3.1.3, from time \(t_{E-1}\) to \(t_{E}\)</p>
</li>
<li>
<p>For each transaction with timestamp in the interval \([t_{E-1},t_{E})\), perform (as described in section 4.3.3.1.1) the base cMana update and the pledge and revoking of cMana, while the reference time \(t_{E}\) remains constant.</p>
</li>
</ol>
<p>Additionally, we define the <em>active consensus Mana</em> of a node A in epoch \(E\) (i.e., relatively to time \(t_{E}\)) as (here, \(\text{cMana}\) is also relative to time \(t_{E}\)):</p>
<p>$$
\text{Active_cMana}(\text{Node A})=
\begin{cases}
\text{cMana}(\text{Node A}), \text{ if there is at least one message from ``node'' with timestamp in }[t_{E-1},t_{E}) \\
0, \text{ otherwise}
\end{cases}
$$</p>
<p>Therefore, even if node <code>node</code> has consensus Mana greater than zero at a certain epoch \(E\), it can be considered dormant in case it did not issue any message during the same epoch. All nodes that have active consensus Mana in epoch \(E\) will form what we call the active consensus Mana set of that epoch, or <code>ACMS(E)</code>.</p>
<p>Both calculations defined above (cMana and active cMana on an epoch \(E\)) can only be carried out when epoch \(E\) is finalizedthat is, at least <code>TIMESTAMP_CUTOFF</code> (see <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>) units of time after \(t_E\)to make sure that no more messages belonging to the epoch will appear in the network.</p>
<p>The following data structures and functions must be defined:</p>
<ul>
<li>
<p><code>UpdatecMana(epoch)</code>: updates the base cMana and cMana vectors from the end of <code>epoch-1</code> to <code>epoch</code>, pledging and revoking the base cMana and cMana relative to all the relevant transactions. </p>
</li>
<li>
<p><code>GetActiveConsensusMana(time)</code>: returns a mapping between all known nodes and their active cMana, calculated at the end of the epoch that contains <code>time</code>.</p>
</li>
<li>
<p><code>ManaRank(lowerMana, upperMana, epoch)</code>: returns the node ID of the nodes with active cMana in the interval <code>[lowerMana, upperMana]</code>, relative to <code>epoch</code>. Notice that <code>epoch</code> must be, at least, the current epoch minus <code>MAX_STORED_EPOCHS</code> and, at most, the last epoch.</p>
</li>
</ul>
<h2 id="534-detailed-design---access-mana"><a class="header" href="#534-detailed-design---access-mana">5.3.4 Detailed Design - Access Mana</a></h2>
<p>When an output is consumed and funds are consequently transferred, a certain amount of base aManadependent on the amount of funds and the age of the outputwill be pledged to a node. This pledge is never revoked, as opposed to base cMana. Nevertheless, the base aMana of all nodes will <em>decay</em> over time, which means that all the calculations for aMana will be slightly different than for cMana. The base aMana at time \(t\), relative to an output \(T_i\) (of amount \(M_i\)) consumed by a transaction with timestamp \(t-s\) and generated by a transaction with timestamp \(t-s-\delta\) is, for \(s,\delta&gt;0\)</p>
<p>$$
\text{Base_aMana}^{T_i}(t)= M (1-e^{-\gamma \delta}) e^{-\gamma s}, \text{ if } t\geq t-s
$$</p>
<p>If this same output pledges aMana to a node \(Z\), then the aMana evolution over time (again, for \(s,\delta&gt;0\)) relative to it will be given by:</p>
<p>$$
\text{aMana}_Z^{T_i}(t) = \begin{cases}
M_i(1-e^{-\gamma\delta})\dfrac{\beta e^{-\beta s}}{\beta-\gamma}\left(e^{(\beta-\gamma)s}-1\right), \text{ if }\beta\neq \gamma\\
M_i(1-e^{-\gamma\delta})\gamma s e^{-\gamma s}, \text{ if } \beta= \gamma\
\end{cases}
$$</p>
<p>The base aMana of a node <code>nodeID</code> at time <code>time</code> is defined as the sum of the individual base aMana generated by all already consumed outputs \(T_i\) of transactions  with  <code>accessManaNodeID = nodeID</code> and timestamp smaller or equal than <code>time</code>. Nevertheless, as in the cMana case, computing the aMana using this equation can be excessively demanding. For that reason, the aMana shall computed recursively, updating it based on its last value. This update is customized for three different situations (here, \(t_0\) is the reference time of the last aMana value):</p>
<ol>
<li>pledging of the aMana relative to a transaction with timestamp smaller than \(t_0\);</li>
<li>pledging of the aMana relative to a transaction with timestamp larger than \(t_0\);</li>
<li>updating the aMana to a time \(t_1&gt;t_0\) without any new aMana pledging.</li>
</ol>
<p>In the first case, the reference time of the aMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the aMana to a point in the past (relatively to the last aMana calculated). The exact update procedure for each of the cases defined above are defined next.</p>
<h3 id="5341-access-mana-update-procedure"><a class="header" href="#5341-access-mana-update-procedure">5.3.4.1 Access Mana update procedure</a></h3>
<h4 id="pledging-the-amana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time"><a class="header" href="#pledging-the-amana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time">Pledging the aMana relative to a transaction with timestamp smaller than the last reference time</a></h4>
<p>Suppose that the last reference time is \(t\) and the transaction timestamp is \(t-s\). The update must be done in two steps, always in the order specified below:</p>
<ul>
<li>
<p><strong>Base aMana pledging</strong>. Suppose that the new transaction consists of \(m\) inputs \(I_1, I_2, \ldots, I_m\) of value \(x_1, x_2, \ldots, x_m\)respectivelyand pledges aMana to a node \(N\). We update the base aMana of node \(N\) by adding to its base aMana the value</p>
<p>$$
d=e^{-\gamma s} \sum_{j=1}^{m}x_j(1-e^{-\gamma \delta_{j}})
$$
where \(\delta_{j}&gt;0\) is the difference between \(t\) and the timestamps of the transaction that generated \(I_j\) and \(\gamma\) is the decay factor. This value \(d\) has to be temporarily stored, since it will be used in the aMana update.</p>
</li>
<li>
<p><strong>Pledging aMana</strong>. We update the aMana vector adding to node \(N\)'s entry the term:</p>
<p>$$
\begin{cases}<br />
\frac{e^{-\gamma s}-e^{-\beta s}}{(\beta-\gamma)e^{-\gamma s}}\beta d,\text{ if }\beta\neq\gamma;\\
s \beta d,\text{ if }\beta=\gamma,\
\end{cases}
$$
where the term \(d\) is the same it was added when updating the base aMana vector. </p>
</li>
</ul>
<h4 id="pledging-the-amana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time"><a class="header" href="#pledging-the-amana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time">Pledging the aMana relative to a transaction with timestamp larger than the last reference time</a></h4>
<p>Suppose that the last reference time is \(t-s\) and the transaction timestamp is \(t\). The update must be done in three steps, always in the order specified below:</p>
<ul>
<li>
<p><strong>Base aMana update with respect to time</strong>. Suppose that the last base aMana is \(\text{Old_Base_aMana}\). We update all base aMana entries as follows:</p>
<p>$$
\text{Base_aMana}(\text{Node}_i) = e^{-\gamma s}\text{Old_Base_aMana}(\text{Node}_i)
$$</p>
</li>
<li>
<p><strong>Base aMana pledging</strong>. Suppose that the new transaction consists of \(m\) inputs \(I_1, I_2, \ldots, I_m\) of value \(x_1, x_2, \ldots, x_m\), respectively, and pledges aMana to a node \(N\). We update the base aMana of node \(N\) by adding to its base aMana the value</p>
<p>$$
d=\sum_{j=1}^{m}x_j(1-e^{-\gamma \delta_{j}})
$$
where \(\delta_{j}&gt;0\) is the difference between \(t\) and the timestamps of the transaction that generated \(I_j\) and \(\gamma\) is the decay factor. This value \(d\) has to be temporarily stored, since it will be used in the aMana update.</p>
</li>
<li>
<p><strong>Updating the aMana with respect to time</strong>.  We update all aMana entries as follows:</p>
<p>$$
\text{ aMana}(\text{Node}_i)=\begin{cases}<br />
e^{-\beta s} \text{Old_aMana}(\text{Node}_i)+\frac{e^{-\gamma s}-e^{-\beta s}}{(\beta-\gamma)e^{-\gamma s}}    \beta\text{Base_aMana}(\text{Node}_i),\text{ if }\beta\neq\gamma;\\
e^{-\beta s} \text{Old_aMana}(\text{Node}_i)+s\beta\text{Base_aMana}(\text{Node}_i),\text{ if }\beta=\gamma,\
\end{cases}
$$</p>
<p>where \(\beta\) is the moving average parameter for the aMana and \(\gamma\) is the base aMana decay factor. Notice that, here, the value of \(\text{Base_aMana(Node}_i)\) used is the one already updated. </p>
</li>
</ul>
<h4 id="updating-the-amana-to-a-time-larger-than-the-last-reference-time-without-any-new-amana-pledging"><a class="header" href="#updating-the-amana-to-a-time-larger-than-the-last-reference-time-without-any-new-amana-pledging">Updating the aMana to a time larger than the last reference time without any new aMana pledging.</a></h4>
<p>Suppose that the last reference time is \(t-s\) and new one is \(t\). The update must be done in two steps, always in the order specified below:</p>
<ul>
<li>
<p><strong>Base aMana update with respect to time</strong>. Suppose that the outdated base aMana is \(\text{Old_Base_aMana}\). We update the base aMana entries as follows:</p>
<p>$$
\text{Base_aMana}(\text{Node}_i) = e^{-\gamma s}\text{Old_Base_aMana}(\text{Node}_i)
$$</p>
</li>
<li>
<p><strong>Updating the aMana with respect to time</strong>. We update all the aMana entries as follows:</p>
<p>$$
\text{aMana}(\text{Node}_i)=\begin{cases}<br />
e^{-\beta s} \text{Old_aMana}(\text{Node}_i)+\frac{e^{-\gamma s}-e^{-\beta s}}{(\beta-\gamma)e^{-\gamma s}}    \beta\text{Base_aMana}(\text{Node}_i),\text{ if }\beta\neq\gamma;\\
e^{-\beta s} \text{Old_aMana}(\text{Node}_i)+s\beta\text{Base_aMana}(\text{Node}_i),\text{ if }\beta=\gamma,\
\end{cases}
$$</p>
<p>where \(\beta\) is the moving average parameter for the aMana and \(\gamma\) is the base aMana decay factor. Notice that, here, the value of \(\text{Base_aMana(Node}_i)\) used is the one already updated. </p>
</li>
</ul>
<p>The following data structures and functions must be defined:</p>
<ul>
<li>
<p><code>GetAccessMana()</code>: returns a mapping between all known nodes and their access Mana, calculated at <code>currentTime</code> (which means that the aMana is updated to <code>currentTime</code> when this function is called).</p>
</li>
<li>
<p><code>UpdateaMana(transaction)</code>: whenever a transaction <code>transaction</code> is added to the ledger state, it updates the aMana vector in order to add the aMana relative to <code>transaction</code> and to the (possibly) new reference time.</p>
</li>
</ul>
<h2 id="535-initialization"><a class="header" href="#535-initialization">5.3.5. Initialization</a></h2>
<p>The Mana is an extension of the ledger state, hence its calculation depends on the ledger state perception of the node. Snapshotting is the mechanism that stores older ledger states and prunes unnecessary messages. Together with the ledger state, aMana and cMana vectors (and the reference time relative to them) are also saved, since a certain ledger state reflects a certain aMana and cMana distribution in the network. Thus, when a node joins the network, it will query other nodes to get their snapshot file, containing a <code>aMana Snapshot Vector</code>, a <code>cMana Snapshot Vector</code>, and two <code>ACMS</code> (one for each of the last two snapshotted epochs) that will be used as initialization data. </p>
<h2 id="536-algorithm"><a class="header" href="#536-algorithm">5.3.6. Algorithm</a></h2>
<h3 id="5361-parameter-values"><a class="header" href="#5361-parameter-values">5.3.6.1. Parameter Values</a></h3>
<p>The following parameters will be used by default, and all nodes must know them. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana vectors of a certain node are significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like congestion control), a node with a significantly different perception of Mana will be blacklisted and will not harm the network. Thus, the nodes have plenty of incentives to follow the rules.</p>
<p><strong>Table 5.3.1 List of Parameters</strong></p>
<table><thead><tr><th>Name</th><th align="center">Type</th><th>Description</th><th>Observation</th></tr></thead><tbody>
<tr><td><code>DECAY</code></td><td align="center">float</td><td>decay factor for base aMana</td><td>Called \(\gamma\) in the last sections. For a half life of ~6 hours we need \(\gamma=0.00192541 \frac{1}{\text{min}}\).</td></tr>
<tr><td><code>C_MANA_EMA_COEFF</code></td><td align="center">float</td><td>moving average factor for the cMana</td><td>Called \(\alpha\) in the last sections. Set as the same value as \(\gamma\).</td></tr>
<tr><td><code>A_MANA_EMA_COEFF</code></td><td align="center">float</td><td>moving average factor for the aMana</td><td>Called \(\beta\) in the last sections. Set as the same value as \(\gamma\).</td></tr>
</tbody></table>
<h3 id="5362-local-variables-and-built-in-functions"><a class="header" href="#5362-local-variables-and-built-in-functions">5.3.6.2. Local Variables and Built-in Functions</a></h3>
<p><strong>Table 5.3.2 Local Variables and Built-in Functions</strong></p>
<table><thead><tr><th>Name</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>object.cManaNode</code></td><td align="center">nodeID</td><td>Id of the node to which <code>object</code>'s cMana was pledged</td></tr>
<tr><td><code>object.amount</code></td><td align="center">double</td><td>Amount moved by <code>object</code></td></tr>
<tr><td><code>object.aManaNode</code></td><td align="center">nodeID</td><td>Id of the node to which <code>object</code>'s aMana was pledged</td></tr>
<tr><td><code>transaction.inputs</code></td><td align="center">list of inputs IDs</td><td>List of inputs consumed by <code>transaction</code></td></tr>
<tr><td><code>transaction.time</code></td><td align="center">time</td><td>Timestamp of <code>transaction</code></td></tr>
<tr><td><code>nodes</code></td><td align="center">list of nodeIDs</td><td>List of known nodes.</td></tr>
<tr><td><code>epoch.finalTime</code></td><td align="center">time</td><td>Final time of <code>epoch</code></td></tr>
<tr><td><code>epoch.initialTime</code></td><td align="center">time</td><td>Initial time of <code>epoch</code></td></tr>
<tr><td><code>epoch.transactions</code></td><td align="center">list of TxIds</td><td>Set of transactions with timestamps in the interval <code>[epoch.initialTime,epoch.finalTime)</code></td></tr>
<tr><td><code>input.time</code></td><td align="center">time</td><td>Timestamp of the transaction that generated the output relative to <code>input</code></td></tr>
</tbody></table>
<h2 id="5363-pseudocode---cmana-update"><a class="header" href="#5363-pseudocode---cmana-update">5.3.6.3. Pseudocode - cMana Update</a></h2>
<p>In this section, for the sake of clarity, we introduce an example of code of the functions defined above. </p>
<h4 id="updatebasecmanatrtransaction"><a class="header" href="#updatebasecmanatrtransaction"><code>UpdateBasecManaTr(transaction)</code></a></h4>
<p>The function <code>UpdateBasecManaTr(transaction)</code> updates the vector <code>basecMana</code>, pledging and revoking the base cMana relative to a transaction <code>transaction</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdateBasecManaTr(transaction)
    basecMana[transaction.cManaNode] = basecMana[transaction.cManaNode]+transaction.amount 
    FOR input in transaction.inputs
        basecMana[input.cManaNode] = basecMana[input.cManaNode]-input.amount
</code></pre>
<h4 id="updatecmanatimeepoch"><a class="header" href="#updatecmanatimeepoch"><code>UpdatecManaTime(epoch)</code></a></h4>
<p>The function <code>UpdatecManaTime(epoch)</code> updates the vector <code>cMana</code>, changing its reference time from the end of <code>epoch-1</code> to the end of <code>epoch</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdatecManaTime(epoch)
    n = epoch.finalTime-epoch.initialTime
    FOR node in nodes
        cMana[node] = exp(-C_MANA_EMA_COEFF*n)*cMana[node]
                        +(1-exp(-C_MANA_EMA_COEFF*n))*basecMana[node]
</code></pre>
<h4 id="updatecmanatrepochtransaction"><a class="header" href="#updatecmanatrepochtransaction"><code>UpdatecManaTr(epoch,transaction)</code></a></h4>
<p>The function <code>UpdatecManaTr(epoch,transaction)</code> updates the vector <code>cMana</code>, pledging and revoking the cMana relative to a transaction <code>transaction</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdatecManaTr(epoch,transaction)
    n = epoch.finalTime - transaction.time
    FOR node in nodes
        IF basecMana[node] != basecManaOld[node]
            cMana[node] = cMana[node]+(1-(1-C_MANA_EMA_COEFF)**n)*(basecMana[node]-basecManaOld[node])
</code></pre>
<h4 id="updatecmanaepoch"><a class="header" href="#updatecmanaepoch"><code>UpdatecMana(epoch)</code></a></h4>
<p>The function <code>UpdatecMana(epoch)</code> updates the vectors <code>cMana</code> and <code>basecMana</code>, from the end of <code>epoch-1</code> to <code>epoch</code>, pledging and revoking the base cMana and cMana relative to all the relevant transactions. </p>
<pre><code class="language-vbnet">FUNCTION UpdatecMana(epoch):
    UpdatecManaTime(epoch)
    IF epoch.transactions != NULL:
        FOR transaction in epoch.transactions:
            basecManaOld = basecMana
            UpdateBasecManaTr(transaction)
            UpdatecManaTr(epoch,transaction)
</code></pre>
<h3 id="5364-pseudocode---amana-update"><a class="header" href="#5364-pseudocode---amana-update">5.3.6.4. Pseudocode - aMana Update</a></h3>
<p>In this section, for the sake of clarity, we introduce an example of code of the functions defined above. </p>
<h4 id="updatebaseamanatimet"><a class="header" href="#updatebaseamanatimet"><code>UpdateBaseaManaTime(t)</code></a></h4>
<p>The function <code>UpdateBaseaManaTime(t)</code> updates the vector <code>baseaMana</code>, changing its reference time from <code>lastUpdateTime</code> to <code>t</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdateBaseaManaTime(t)
    n = t-lastUpdateTime
    FOR each node i
        baseaMana[i] = baseaMana[i]*exp(-DECAY*n)  
</code></pre>
<h4 id="updateamanatimet"><a class="header" href="#updateamanatimet"><code>UpdateaManaTime(t)</code></a></h4>
<p>The function <code>UpdateaManaTime(t)</code> updates the vector <code>aMana</code>, changing its reference time from <code>lastUpdateTime</code> to <code>t</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdateaManaTime(t)
    n = t-lastUpdateTime
    IF DECAY != A_MANA_EMA_COEFF
        FOR each node i
            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+(1-exp((DECAY-A_MANA_EMA_COEFF)*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*baseaMana[i]
    ELSE       
        FOR each node i
            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+ DECAY*A_MANA_EMA_COEFF*baseaMana[i]            
</code></pre>
<h4 id="updatebaseamanatrtransaction"><a class="header" href="#updatebaseamanatrtransaction"><code>UpdateBaseaManaTr(transaction)</code></a></h4>
<p>The function <code>UpdateBaseaManaTr(t,transaction)</code> updates the vector <code>baseaMana</code>, pledging the base aMana relative to a transaction <code>transaction</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdateBaseaManaTr(transaction)
    FOR input in transaction.inputs
        baseaMana[transaction.aManaNode] = baseaMana[transaction.aManaNode]+exp(-DECAY*(MAX(transaction.time,lastUpdateTime)-transaction.time))*input.amount*(1-exp(-DECAY*(transaction.time-input.time))) 
</code></pre>
<h4 id="updateamanatrtransaction"><a class="header" href="#updateamanatrtransaction"><code>UpdateaManaTr(transaction)</code></a></h4>
<p>The function <code>UpdateaManaTr(transaction)</code> updates the vector <code>aMana</code>, pledging the aMana relative to a transaction <code>transaction</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdateaManaTr(transaction):
    n = lastUpdateTime-transaction.time
    IF DECAY != A_MANA_EMA_COEFF
        aMana[transaction.aManaNode] = aMana[transaction.aManaNode]+(exp(-DECAY*n)-exp(-A_MANA_EMA_COEFF*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])
    ELSE
        aMana[aManaNode(transaction)] = aMana[transaction.aManaNode]+exp(-DECAY*n)*DECAY*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])

</code></pre>
<h4 id="updateamanatransaction"><a class="header" href="#updateamanatransaction"><code>UpdateaMana(transaction)</code></a></h4>
<p>The function <code>UpdateaMana(transaction)</code> updates the vectors <code>aMana</code> and <code>baseaMana</code>, from <code>lastUpdateTime</code> to <code>MAX(lastUpdateTime, transaction.time)</code>, pledging the base aMana and aMana relative to <code>transaction</code>. </p>
<pre><code class="language-vbnet">FUNCTION UpdateaMana(transaction):
    # if the tx is not old, add it and update the vector to t   
    IF transaction.time &gt; lastUpdateTime:
        UpdateBaseaManaTime(transaction.time)
        UpdateaManaTime(transaction.time)
        UpdateBaseaManaTr(transaction)
        lastUpdateTime  = transaction.time        
    # add a transaction in the past    
    IF transaction.time &lt; lastUpdateTime:
        baseaManaOld = baseaMana
        UpdateBaseaManaTr(transaction)
        UpdateaManaTr(transaction)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="61-objects-of-consensus"><a class="header" href="#61-objects-of-consensus">6.1 Objects of Consensus</a></h1>
<h2 id="611-preliminaries"><a class="header" href="#611-preliminaries">6.1.1 Preliminaries</a></h2>
<h3 id="6111-motivation"><a class="header" href="#6111-motivation">6.1.1.1 Motivation</a></h3>
<p>FPC is a binary voting protocol where each node starts with an initial opinion (a nulled boolean) on an object.  Nodes then exchange queries and responses about their opinions during several rounds, until each node terminates with a final boolean value.</p>
<p>FPC votes on two specific objects types: messages, in order to enforce timestamps, and transactions, in order to decide double spends. Additionally, applications can use FPC to query opinions about their opinion on other object types, although there is no guarantee that they will get a response.</p>
<p>The FPC is agnostic about the rest of the protocol, particularly the questions being decided voting and how the initial opinions are set.  We require a generic way for FPC to interact with data structures in other applications. Specifically, an application needs a way to trigger FPC run. </p>
<p>Deciding when FPC should run is a delicate question for two reasons.</p>
<ol>
<li>It is inefficient for FPC to vote on every single transaction.</li>
<li>If only a sub set of nodes participate in FPC, they are more vulnerable to attack since the consensus mana held by this collection of nodes is potentially much smaller.
Thus, since it cannot vote on everything, it must use subjective criterion to trigger voting which does not leave any group vulnerable to attack.</li>
</ol>
<p>Voting is a two-part process: querying and answering queries.  The function <code>QueryStatus</code> determines if a node should query about a particular object, and the function <code>AnswerStatus</code> determines if the node should respond.</p>
<h3 id="6112-summary"><a class="header" href="#6112-summary">6.1.1.2 Summary</a></h3>
<p>This specification describes how this binary voting protocol interacts with the rest of the IOTA protocol.  Specifically, we define two functions, <code>QueryStatus</code> and <code>AnswerStatus</code> which govern when an object should be included in a query or response respectively. These functions depend on the metatdata <code>opinionField</code> which is also defined in this specification.</p>
<p>This specification only includes the format on how applications requiring FPC should interact with it, not how to set initial opinions or, more specifically, <code>opinionField</code>.  For this information.</p>
<h3 id="6113-parameters-and-lists"><a class="header" href="#6113-parameters-and-lists">6.1.1.3 Parameters and lists</a></h3>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>DSMALL</code></td><td>duration</td><td>small estimated network delay, set to 5 seconds</td></tr>
<tr><td><code>votingEnabledObjectTypes</code></td><td>list</td><td>object types which will be voted upon</td></tr>
</tbody></table>
<h2 id="612-detailed-design"><a class="header" href="#612-detailed-design">6.1.2 Detailed design</a></h2>
<h2 id="6121-voting-objects-list"><a class="header" href="#6121-voting-objects-list">6.1.2.1 Voting Objects list</a></h2>
<p>FPC can potentially vote on a variety of matters.  The <code>votingEnabledObjectTypes</code> effectively lists which things will be voted upon by listing the object types which must be queried by FPC.  Specifically, when FPC prepares a query, it iterates through each object type, and then finds which objects of that type it must include in the query.</p>
<p>By default, the object types <code>message</code> and <code>transaction</code> are in the list <code>votingEnabledObjectTypes</code>.  However, a second layer application can add other object types to this list, allowing other applications to use FPC. These applications will have no guarantee that they will receive responses with about custom object types, particularly if the application is not widely used.</p>
<h3 id="6122-how-opinions-on-objects-are-stored"><a class="header" href="#6122-how-opinions-on-objects-are-stored">6.1.2.2 How opinions on objects are stored</a></h3>
<p>For every object whose type is in <code>votingEnabledObjectTypes</code>, that the local meta data stored with the object must include an <code>opinionField</code> which is either <code>NULL</code>  or the triplet <code>(opinion,level,timeFormed)</code>.  The field <code>opinion</code> is a nullable boolean value,  <code>level</code> is a number in the list \({1,2,3}\), and <code>timeFormed</code> is the time the field was changed from <code>NULL</code>.</p>
<p>As will be discussed in a different specification, an opinion field will be  <code>NULL</code> until the node has received information allowing it to form an opinion, e.g. detect a conflict.  For example,  a transaction should have opinion field  <code>NULL</code> until a conflict is detected.  Such transactions should be considered &quot;good&quot;, and, in the honest setting, most transactions will have a <code>NULL</code> opinion. </p>
<h3 id="6123-query-status"><a class="header" href="#6123-query-status">6.1.2.3 Query Status</a></h3>
<p>When FPC prepares a query, see the <a href="link">FPC</a> specification, it <em>shall</em> determine which objects to include.  Conceptually, for each type in <code>votingEnabledObjectTypes</code>, the node <em>shall</em> iterate through all objects of that type and individually decide if that object is to be included in the query. Clearly, this iteration would be inefficient expensive, and a node can use some method to speed up the process.  However, this is an implementation detail and thus beyond the scope of this document.</p>
<p>To determine whether or not each object should be included into a query, a node shall apply the following <code>QueryStatus</code> function.  If the function returns true, then the object should be included into the query.</p>
<pre><code class="language-vbnet">FUNCTION Bool = QueryStatus(type,objectID)
IF type not in VotingEnabledObjectTypes
    RETURN FALSE
ELSE IF opinionField != NULL AND level =1 and currentTime &gt; timeFormed+DSMALL
    RETURN TRUE
ELSE RETURN FALSE      
IF the object does not exist
    RETURN `FALSE`.
</code></pre>
<p>When FPC succesfully stops voting on an object, it sets in the <code>opinionField</code> the <code>opinion</code> to the final opinion and modifies <code>level</code>  to <code>2</code> so that <code>QueryStatus</code> returns false.</p>
<h3 id="6124-answer-status"><a class="header" href="#6124-answer-status">6.1.2.4 Answer Status</a></h3>
<p>Every time FPC receives a query request, it checks whether or not it should reply; see <a href="Link">FPC</a>.  To do so, it applies the following  <code>AnswerStatus</code> function to object in the query request to determine if a response should be made.  If <code>AnswerStatus</code> returns <code>FALSE</code> for any object in the query request, a query response will not be prepared.</p>
<pre><code class="language-vbnet">FUNCTION Bool=AnswerStatus(type,objectID)
If type not in VotingEnabledObjectTypes
    RETURN FALSE
ELSE IF opinionField not = NULL AND (level = 1 OR level = 2) 
    RETURN TRUE
ELSE RETURN FALSE 
</code></pre>
<p>Lastly, if the object does not exist, the function should return <code>FALSE</code>.</p>
<h1 id="613-rationale-and-alternatives"><a class="header" href="#613-rationale-and-alternatives">6.1.3 Rationale and Alternatives</a></h1>
<p>The <code>level</code> field indicates the level of knowledge. It tells us information about what other nodes know.</p>
<ul>
<li>Level 1 means that the node only knows that it holds this opinion.</li>
<li>Level 2 means that the node knows that all nodes have this opinion too (with high probability).</li>
<li>Level 3 means that the node knows that all nodes have level 2 knowledge (with high probability).</li>
</ul>
<p>If a node node only has level 1 knowledge, it needs to vote.  However, if it has level 2 knowledge, it does not need to query as it knows that all nodes have the same opinion. With level 3 knowledge, it knows that no other nodes have level 2 knowledge and thus should not send its node queries.  Thus, with level 3 knowledge, the node does not need to respond. The level of knowledge is the primary criterion in these functions.</p>
<p>Moreover, we should not query about objects whose opinion is <code>NULL</code>. In a similar vein, we need should not query about an object until <code>d</code> time after the opinion was set, so we can be sure that all other nodes have set their opinion too. </p>
<p>Alternatively, we can attempt to manage the same system with a series of finality flags.  However, this has two problems.  First,  we either mark objects which we have never voted upon as final, or some objects will never get a finality flag.  This leads to some complicated, unintuitive logic. 
Second, if an attacker can cause only small portions of the network to vote on an object, that vote would be susceptible to an attack.  Thus we need consensus about what to vote on. However, if voting is a binary &quot;yes&quot; or &quot;no&quot;, we would need a consensus algorithm to determine when to vote.  The levels of knowledge does not treat voting in a binary way, bypassing this problem.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="62-opinion-setting"><a class="header" href="#62-opinion-setting">6.2 Opinion Setting</a></h1>
<h2 id="621-preliminaries"><a class="header" href="#621-preliminaries">6.2.1 Preliminaries</a></h2>
<h3 id="6212-motivation"><a class="header" href="#6212-motivation">6.2.1.2 Motivation</a></h3>
<p>FPC is a binary voting protocol which takes a series of initial boolean values, and outputs a final value: see <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Section 6.3 - Fast Probabilistic Consensus</a>.  This specification describes how to set this initial Boolean value. Specification <a href="./6.1%20Objects%20of%20Consensus.html">6.1 - Object of Consensus</a> describes how FPC interacts with other modules in the protocol, specifically how the functions <code>QueryStatus</code> and <code>AnswerStatus</code> react to the metadata <code>opinionField</code>. Moreover, the FPC specification, <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Section 6.3 - Fast Probabilistic Consensus</a>, describes how the <code>opinionField</code> is updated when FPC terminates.</p>
<p>We need to describe how to set the initial opinion and how to trigger FPC voting. Specifically, we need to describe how the metadata <code>opinionField</code> is initially set.  Since the outcome of FPC respects a supermajority of initial opinions, it is important that the initial opinion is set correctly.  For example, if 90% of nodes (weighted by active consensus mana) initially want to accept a transaction, the transaction is accepted with very high probablity.</p>
<p>Recall from specification <a href="./6.1%20Objects%20of%20Consensus.html">Section 6.1 - Object of Consensus</a>, that <code>opinionField</code> consists of fields, <code>opinion</code> which is a boolean, <code>level</code> which is either 1,2, or 3, and <code>timeFormed</code> which is a time.  In this specification, we describe how these three fields are set for both messages and transactions.</p>
<h3 id="6213-summary"><a class="header" href="#6213-summary">6.2.1.3 Summary</a></h3>
<p>In this specification, we describe how the Opinion Setter, see <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>, initially sets <code>opinionField</code> metadata for every object being voted upon. Specifically, the opinion setter writes:
+ The initial opinion, i.e. the initial boolean value.
+ The level of knowledge which dictates when FPC will be triggered.
+ The time the opinion was formed. </p>
<p>See <a href="./6.1%20Objects%20of%20Consensus.html">Section 6.1 - Object of Consensus</a> for a detailed explanation of these fields. </p>
<p>As discussed in <a href="./6.1%20Objects%20of%20Consensus.html">Section 6.1 - Object of Consensus</a>, FPC can potentially vote on two main object types:
+ transactions in order to resolve conflicts
+ timestamps in order to judge timestamps</p>
<p>We split this specification into two main sections: the first dealing with setting the opinion on messages and their timestamps, and the second on setting the opinion on transactions.</p>
<p>With regards to timestamps, we vote on whether or not the timestamp is &quot;too old&quot; when the message arrives to the node. As with voting on transactions, we can reset this opinion using the approval weight even if the node is out of sync.</p>
<p>We judge transactions based on the FCoB rule, which stands for Fast Consensus of Barcelona, in honor of the research summit where the rule was first defined.  A transaction <code>X</code> satisfied the FCoB rule if the node has not received any transactions conflicting with <code>X</code> before <code>arrivalTime(X)+C</code> where <code>C</code> is the FCoB parameter.  Recall from <a href="./6.4%20Finalization.html">Section 6.4 - Finalization</a> that two transactions conflict if they consume the same UTXO outputs. </p>
<p>Intuitively, the FCoB rule only accepts a transaction if it has arrived significantly before any other conflict.  The FCoB rule guarantees that if one transaction is liked by a significant number of nodes (weighted by consensus mana), that all other conflicting transactions will be initially disliked by a supermajority of nodes, and thus rejected by FPC, guaranteeing that no two conflicting messages will be approved by FPC. </p>
<h3 id="6214-dependencies"><a class="header" href="#6214-dependencies">6.2.1.4 Dependencies</a></h3>
<p>This part of the specification depends on the following specifications:
+ <a href="./4.2%20Timestamps.html">Section 4.2 - Timestamps</a>
+ <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>
+ <a href="./6.1%20Objects%20of%20Consensus.html">Section 6.1 - Object of Consensus</a>
+ <a href="./6.4%20Finalization.html">Section 6.4 - Finalization</a></p>
<h3 id="6214-parameters-and-lists"><a class="header" href="#6214-parameters-and-lists">6.2.1.4 Parameters and Lists</a></h3>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>DLARGE</code></td><td>duration</td><td>Gratuitous network delay estimate; set to 15 seconds</td></tr>
<tr><td><code>W</code></td><td>duration</td><td>Time window, set to 1 minute. Require W&gt;2DLARGE</td></tr>
<tr><td><code>DSMALL</code></td><td>duration</td><td>Small estimated network delay, set to 5 seconds</td></tr>
<tr><td><code>C</code></td><td>duration</td><td>FCoB parameter=DSMALL</td></tr>
</tbody></table>
<h2 id="622-timestamps"><a class="header" href="#622-timestamps">6.2.2 Timestamps</a></h2>
<p>The timestamp defines the time when the message was created. Voting on timestamps ensures that nodes are issuing messages with correct timestamps, where correct means that the offset with current time is lower than a certain parameter <code>W</code>.  This time window is large to account for the network delay. In order to have consensus on the accuracy of the timestamp, and hence the eligibility of the message, we use <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">FPC</a> voting, along with the levels of knowledge.</p>
<p>Clearly, in order to have a correct perception of the timestamp quality, <strong>we assume the node is in sync</strong> (see section <a href="6.2%20Opinion%20Setting.html#Not_in_Sync">Not in Sync</a> otherwise).
Voting on timestamps should not occur for every message. Specifically, only for those that arrive with an offset close to <code>W</code>, i.e. within <code>DLARGE</code>.</p>
<h3 id="6221-setting-the-initial-opinion"><a class="header" href="#6221-setting-the-initial-opinion">6.2.2.1 Setting the initial opinion</a></h3>
<p>In this section, we describe how the <code>opinionField</code> is set for messages, and how we achieve consensus on the correctness of timestamps. </p>
<p>The opinion of timestamp is stored according to the rules laid out in the <a href="./6.1%20Objects%20of%20Consensus.html">Object of Consensus</a> specification.  The opinion is set by the module called the <code>OpinionManager</code>: see <a href="./2.4%20Data%20flow.html">Section 2.4 - Data Flow</a>.  Refer to the <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">FPC</a> specification to see how the voting actually takes place.</p>
<p>The node shall set <code>messageID.opinionField=timestampOpinion(messageID)</code>, using the function defined below.</p>
<p>The initial opinion and level of knowledge are set according to the following rule:</p>
<pre><code class="language-vbnet">FUNCTION (bool,level,time) = timestampOpinion(messageID)
time = CurrentTime()
IF messageID.arrivalTime+w &gt;= CurrentTime()  
    opinion = TRUE
ELSE 
    opinion = DISLIKE
IF |messageID.arrivalTime +W - CurrentTime() | &gt;= DLARGE
    level = 2
ELSE IF |messageID.arrivalTime +W - CurrentTime() | &gt;= 2*DLARGE
    level = 3
ELSE 
    level = 1
</code></pre>
<p>Recall that the <code>arrivalTime.messageID</code> is the time that the message was received by the node: see <a href="./2.2%20Message%20Layout.html">Section 2.2 - Message Layout</a>.
The initial opinion is set based on the question &quot;did the transaction arrive before <code>currentTime - W</code>?&quot;.  The level of knowledge is then set by the margin as a factor of the delay time.  Specifically, under the assumption that all messages are delivered to all nodes within time <code>DLARGE</code> after the arrive (with high probability), then: 
+ If <code>|arrivalTime +W - currentTime | &lt; DLARGE</code>, then the node can make any conclusions about the arrival times of the message, and hence it has only level of knowledge 1.
+ If one node has <code>|arrivalTime +W - currentTime | &gt;= DLARGE </code>, then all nodes must have the same opinion, and hence that node has level of knowledge at least 2.
+ If one node has <code>|arrivalTime +W - currentTime | &gt;= 2*DLARGE</code>, then all nodes must have <code>|arrivalTime +W - currentTime | =&gt; DLARGE</code> guaranteeing level of knowledge 3.
<img src="https://i.imgur.com/a5or78c.png" alt="" /></p>
<p>For example, let us set <code>w</code> and <code>D</code> to 1 minute and 15 seconds respectively. Let's assume that the current time is 12:00:00 and we have to evaluate a new message with timestamp set at 11:59:45. Since 11:59:45 +1 minute&gt;12:00:00, the node will set the opinion to <code>LIKE</code>. Moreover, since |11:59:45+1 minute-12:00:00| is greater than 15 seconds, and also grater than 2*15 seconds, the node will set the level of knowledge for this opinion to 3 (i.e., the supermajority of the network should already have the same opinion).</p>
<p>Consider now a new message with timestamp 11:59:10. Since 11:59:10+1 minute&gt;12:00:00, the node will set the opinion to <code>TRUE</code>. However, since |11:59:10+1 minute-12:00:00| is lower than 15 seconds, the node will set the level of knowledge for to 1, meaning that this message  will be voted upon by FPC. </p>
<p>In general, timestamps with level of knowledge 1 will be input into FPC, that will eventually trigger the <code>finalized</code> event, after which we may set a message as eligible or as discarded, depending on the outcome. If instead, the timestamp the node is considering has already level of knowledge larger or equal than 2, the node does not need to vote, but has to reply to queries. Either it is eligible (marked as liked) or it is marked as disliked. If the timestamp has level of knowledge 3, the node does not reply to FPC queries.</p>
<p>With high probability, we can be sure that for any time <code>t</code>, no node can issue a message with timestamp <code>t</code> after <code>t + W + 2*DLARGE</code>, because after this time, the message would be considered to be bad with level of knowledge 3.  Thus, assuming the node is in sync, see <a href="./6.5%20Node%20Perception%20Reorganization.html">Section 6.5 - Node Perception Reorganization</a>, after approximately 1.5 minutes, the number of messages of a particular timestamp cannot be altered. </p>
<h2 id="623-transactions-and-fcob"><a class="header" href="#623-transactions-and-fcob">6.2.3 Transactions and FCoB</a></h2>
<p>In this section, we discuss how to set the <code>opinionField</code> on transactions through the so-called FCoB rule.  Recall that a transaction <code>X</code> satisfies the FCoB rule if the node has not received any transactions conflicting with <code>X</code> before <code>arrivalTime(X)+C</code>.</p>
<h3 id="6231-fcob-function"><a class="header" href="#6231-fcob-function">6.2.3.1 FCoB function</a></h3>
<p>We now define the function <code>FCOB</code> which decides the opinion of the transaction.  When setting the opinion, the node simply sets <code>opinionField=FCOB(transactionID)</code>.</p>
<pre><code class="language-vbnet">FUNCTION (bool,level,time) = FCOB(transactionID)
time = currentTime
IF transactionID IS NOT a conflict
    bool = TRUE
    IF currentTime &lt;= transactionID.arrivalTime + C + DSMALL
        level = 1
    ELSE IF currentTime &lt;= transactionID.arrivalTime + C + 2 * DSMALL
        level = 2
    ELSE 
        level = 3
ELSE
    FOR x IN conflict with transactionID
        IF x.arrivalTime &gt;= transactionID.arrivalTime + C OR ( x.opinionField.opinion == FALSE AND x.opinionField.level == 2 OR 3)
        bool = TRUE
        level = 1
ELSE 
    conflictTime= MIN(x.arrivalTime FORALL x conflicting with transactionID)
    IF transaction.arrivalTime + C &lt;= conflictTime 
        bool = TRUE
    ELSE
        bool = FALSE
    If |transaction.arrivalTime + C - conflictTime| &lt;= DSMALL
        level = 1
    ELSE IF |transaction.arrivalTime + C - conflictTime| &lt;= 2DSMALL
        level = 2
    ELSE
        level = 3
RETURN (bool,level,timeFormed)
</code></pre>
<p>We now will explain the logical behind this function.  There are three cases which are treated:</p>
<ol>
<li>No conflicts have been detected</li>
<li>Conflicts have been detected but have been rejected</li>
<li>Conflicts have been detected are either pending or have been confirmed</li>
</ol>
<p>Case 3 is the simplest case: since conflicts have been detected, we set the opinion according to the FCOB rule.  Then level is set according to the difference of <code>transaction.arrivalTime + C</code> and  <code>conflictTime</code>, the oldest arrival time of a conflicting transaction.  Essentially, the level measures how many network delays there are between these two values.</p>
<p>In Case 1 is the most common because conflicts will never arrive for most transactions. Without conflicts, the opinion can be only set provisionally since it might change if a conflict arrives later. The opinion is set to true, but the level is set as if a conflict arrived at that time.   For example, after  <code>C + DSMALL</code> time has elapsed since arrival time, if a conflict does arrive the opinion will remain true with level at least 2.</p>
<p>Lastly, Case 2 is an important special case of the FCoB rule. To see the need for this modification consider the following example.  Suppose someone issues a pair of conflicting transactions where both transactions are rejected by FPC.  Then, if someone ever issues a new transaction consuming those funds, FCoB, strictly speaking would reject the new transaction, since it would conflict with a previous transaction.  Thus, if a pair of double spends are rejected, the funds would be locked.  This is undesirable and impractical behavior: an honest but malfunctioning wallet can issue double spends.  Moreover, tracking the locked funds would be onerous. </p>
<p>To prevent the FCoB rule from locking funds, we modify it to the following: a transaction <code>X</code> satisfied the FCoB rule if all transactions <code>Y</code> conflicting with <code>X</code>  before <code>arrivalTime(X)+C</code> has been rejected, i.e. has has opinion false and level 2 or 3.  With this rule, any conflicts which are rejected will not affect the opinion on future conflicts.  For simplicity case, all transactions falling under this case are treated as level 1.</p>
<h3 id="6232-when-to-set-the-opinion"><a class="header" href="#6232-when-to-set-the-opinion">6.2.3.2 When to set the opinion</a></h3>
<p>The protocol is actually flexible on when the opinion field of a transaction is set.  However, the node must do the following. 
+ The opinion of a transaction must be set after it is booked.  When the transaction is booked, the node searches for conflicts, and if a conflict exists the node either creates a new conflict set or else it adds the transaction to an old conflict sets.  If the <code>FCoB</code> function is called before the transaction is booked, it will be impossible to tell what conflicts exist.
+ The opinion field is <code>NULL</code> only if no conflicts have been detected
+ Fore very valid <code>transactionID</code>, the <code>transactionID.opinionField</code> is either NULL or &quot;correct&quot; at the  times <code>transactionID.arrivalTime + C + DSMALL</code> and <code>transactionID.arrivalTime + C + 2DSMALL</code>, i.e. the opinion field would be unchanged if reset at that those two times. </p>
<p>There are a plethora of ways this could be implemented. We give two examples.</p>
<p>First, after a message is booked, its transaction, say <code>transactionID</code> is added to a timed queue.  At <code>transactionID.arrivalTime + C + DSMall</code> the opinion is set, and then either the transaction is rejected (i.e. bad with level 2 or 3), voted upon (level 1), or goes to tip selection (good level 2). If no conflict has been detected, the transaction (i.e. the transaction is good level 2), the transaction is put in another timed queue.  At time <code>transactionID.arrivalTime + C + 2DSMall</code> the opinion is reset.  Note, once a conflict is detected the opinion field would not change, and so only transactions which are not part of conflict sets need to enter the second timed queue.</p>
<p>Second, while a transaction is being booked, conflict detection can immediately trigger setting the opinion field for all the new conflicts. This would include the transaction itself and any members of its conflict set which previously had a <code>NULL</code> opinion field. This implementation has a few caveats:
+ Any transaction with a <code>NULL</code> opinion field must be treated as a &quot;good&quot; transaction.  At any time, the appropriate level of knowledge could be computed by looking at the arrival time.
+ Before the monotonically liked flag is set, the transaction must be at least <code>transactionID.arrivalTime + C + DSMall</code> and have either opinion field <code>NULL</code> or (good, level 2 or 3). </p>
<p>Although this is an implementation detail, we remark that after a transaction is booked, it is easy to see if a message is a conflict or not. Indeed, when a conflict is detected, a new branch is created, and the ID of that new branch is the same as the <code>transactionID</code>. Thus a transaction is a conflict if and only if <code>transactionID = transactionID.branchID</code>.  See <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="63-fast-probabilistic-consensus"><a class="header" href="#63-fast-probabilistic-consensus">6.3 Fast Probabilistic Consensus</a></h1>
<h2 id="631-introduction"><a class="header" href="#631-introduction">6.3.1 Introduction</a></h2>
<p>The functionality defined in this part of the specification allows nodes to find consensus on whether a given object is elgible or not. This protocol, called Fast Probabilistic Consensus (FPC), is triggered if the eligibility of an object is uncertain. These objects can be messages or transactions. Please refer to <a href="./6.1%20Objects%20of%20Consensus.html">Section 6.1 - Object of Consensus</a> for details on the object of consensus and to <a href="./6.2%20Opinion%20Setting.html">Section 6.2 - Opinion Setting</a> for more details how initial opinions on the objects are formed.</p>
<p>Once FPC is triggered every node must establish an initial opinion on the eligibility of the object, as described in Section 6.1. The node must then start to query other nodes about their opinions on the given object and must update its opinion according to the rules specified in this section. </p>
<p>This procedure shall terminate locally if a node has not changed its opinion over a specified period of time or if some maximal amount of rounds is reached. </p>
<p>Unlike other voting-based consensus protocols, FPC uses a sequence of global random thresholds. This randomness makes FPC robust even in Byzantine environments. We refer to <a href="https://arxiv.org/abs/1905.10895">FPC-BI: Fast Probabilistic Consensus within Byzantine Infrastructures</a>, <a href="https://arxiv.org/abs/1911.08787">Robustness and efficiency of leaderless probabilistic consensus protocols within Byzantine infrastructures</a>, and <a href="https://link.springer.com/chapter/10.1007/978-3-030-63089-8_24">Fast Probabilistic Consensus with Weighted Votes</a> for more details on FPC.</p>
<h2 id="632-fpc-protocol"><a class="header" href="#632-fpc-protocol">6.3.2 FPC Protocol</a></h2>
<p>The FPC protocol attempts to determine consensus on the eligibility of an object <code>objectID</code>. Every node has an initial opinion <code>opinion</code> on this object. These opinions are updated in rounds until the protocol terminates using a local stopping rule. </p>
<h3 id="6321-fpc-parameters"><a class="header" href="#6321-fpc-parameters">6.3.2.1 FPC parameters</a></h3>
<p>Table 5.1.1 gives a list of all parameters required for FPC.</p>
<p><strong>Table 6.3.1 Parameters Required for FPC</strong></p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>TOTAL_ROUNDS_FINALIZATION</code></td><td>integer</td><td>Number of consecutive rounds before FPC auto-terminates</td></tr>
<tr><td><code>TOTAL_ROUNDS_ENDING_THRESHOLD</code></td><td>integer</td><td>Number of consecutive rounds with non-random threshold</td></tr>
<tr><td><code>FIRST_ROUND_THRESHOLD</code></td><td>double</td><td>Threshold of the proportion of opinions in the first round</td></tr>
<tr><td><code>SUBSEQUENT_LOWER_THRESHOLD</code></td><td>double</td><td>Lower random threshold bound in subsequent rounds</td></tr>
<tr><td><code>SUBSEQUENT_UPPER_THRESHOLD</code></td><td>double</td><td>Upper random threshold bound in subsequent rounds</td></tr>
<tr><td><code>ENDING_THRESHOLD</code></td><td>double</td><td>Threshold for termination phase</td></tr>
<tr><td><code>DRNG_WAITING_TIME</code></td><td>duration</td><td>Maximal waiting time (in seconds) to receive dRNG number</td></tr>
<tr><td><code>MAX_ROUND</code></td><td>integer</td><td>Maximum number of rounds before querying stops</td></tr>
<tr><td><code>QUERY_SIZE</code></td><td>integer</td><td>Quorum size, number of nodes that are queried</td></tr>
<tr><td><code>ROUND_LENGTH</code></td><td>double</td><td>Duration (in seconds) of a round</td></tr>
<tr><td><code>TIME_OUT</code></td><td>duration</td><td>Maximal waiting time (in seconds) to receive answers for FPC queries</td></tr>
<tr><td><code>MIN_MANA_PROPORTION</code></td><td>double</td><td>Minimal amount of mana of received answers that allow to update opinion. If this amount is not reached the current round is not counted.</td></tr>
<tr><td><code>MAX_SAMPLE_SIZE</code></td><td>integer</td><td>Maximal size of sample.</td></tr>
</tbody></table>
<p>The proposed values of the parameters are (Table 5.1.2):</p>
<p><strong>Table 6.3.2 FPC Parameter Default Values</strong></p>
<table><thead><tr><th>Parameter</th><th align="center">Value</th></tr></thead><tbody>
<tr><td><code>TOTAL_ROUNDS_FINALIZATION</code></td><td align="center">10</td></tr>
<tr><td><code>TOTAL_ROUNDS_ENDING_THRESHOLD</code></td><td align="center">3</td></tr>
<tr><td><code>FIRST_ROUND_THRESHOLD</code></td><td align="center">0.67</td></tr>
<tr><td><code>SUBSEQUENT_LOWER_THRESHOLD</code></td><td align="center">0.50</td></tr>
<tr><td><code>SUBSEQUENT_UPPER_THRESHOLD</code></td><td align="center">0.67</td></tr>
<tr><td><code>ENDING_THRESHOLD</code></td><td align="center">0.50</td></tr>
<tr><td><code>DRNG_WAITING_TIME</code></td><td align="center">0.20</td></tr>
<tr><td><code>MAX_ROUND</code></td><td align="center">100</td></tr>
<tr><td><code> QUERY_SIZE</code></td><td align="center">21</td></tr>
<tr><td><code>ROUND_LENGTH</code></td><td align="center">10</td></tr>
<tr><td><code>TIME_OUT</code></td><td align="center">6.5</td></tr>
<tr><td><code>MIN_MANA_PROPORTION</code></td><td align="center">0.50</td></tr>
<tr><td><code>MAX_SAMPLE_SIZE</code></td><td align="center">100</td></tr>
</tbody></table>
<h3 id="6322-local-variables"><a class="header" href="#6322-local-variables">6.3.2.2 Local variables</a></h3>
<p>Local variables are those which may be defined at the application developer's discretion and do not form a mandatory part of the protocol. They are included here to assist in understanding the protocol defined in this section. The kind of information described for these variables must be handled by the node application in some form.</p>
<p>Every node shall keep the following variables (Table 5.1.3):</p>
<p><strong>Table 6.3.3 Required Node Variables</strong></p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>nodeList</code></td><td>list of nodeIDs</td><td>List of known nodes</td></tr>
<tr><td><code>consensusManaList</code></td><td>list of nodeIDs</td><td>List of active consensus mana of known nodes</td></tr>
<tr><td><code>ownMana</code></td><td>double</td><td>Active consensus mana of <code>ownNode</code></td></tr>
<tr><td><code>rn</code></td><td>double</td><td>Random number provided by dRNG module</td></tr>
<tr><td><code>rnCycle</code></td><td>double</td><td>Random number instance</td></tr>
<tr><td><code>queryList</code></td><td>list of nodeIDs</td><td>List of nodes to query</td></tr>
<tr><td><code>queryMax</code></td><td>integer</td><td>Maximal number of queries per round</td></tr>
<tr><td><code>opinionQuery</code></td><td>list of Opinions</td><td>List of opinions of nodes in <code>queryList</code>, non-replies are encoded with <code>NA</code></td></tr>
<tr><td><code>objectIDs</code></td><td>list of objectIDs</td><td>List of objectIDs that are under vote</td></tr>
</tbody></table>
<p>Note that <code>consensusManaList</code> is a list of active consensus Mana of all known nodes. As this Mana changes over time this list has to be updated over time. Such an update is expressed with the function <code>GetActiveConsensusMana(time)</code> that returns the list of active consensus Mana at time <code>time</code>.</p>
<p>For each <code>objectID</code> that is under vote a node shall keep the following variables (Table 5.1.4):</p>
<p><strong>Table 6.3.4 Variables Required for objectID Under Vote</strong></p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>opinion</code></td><td>nulled boolean</td><td>Opinion of the eligibility the <code>objectID</code>; <code>TRUE</code> corresponds to <code>LIKE</code> and <code>FALSE</code> to <code>DISLIKE</code></td></tr>
<tr><td><code>cnt</code></td><td>integer</td><td>Counter of the number of consecutive rounds with unchanged opinion</td></tr>
<tr><td><code>queryStatus</code></td><td>boolean</td><td>Status if actively querying</td></tr>
<tr><td><code>answerStatus</code></td><td>boolean</td><td><code>TRUE</code> if answering queries, otherwise <code>FALSE</code></td></tr>
<tr><td><code>round</code></td><td>integer</td><td>Counter for the number of rounds in FPC</td></tr>
<tr><td><code>reachedMaxRound</code></td><td>boolean</td><td>Indicator whether protocol reached <code>MAX_ROUND</code> before auto-termination, default value <code>FALSE</code></td></tr>
</tbody></table>
<h3 id="6323-fpc-protocol-description"><a class="header" href="#6323-fpc-protocol-description">6.3.2.3 FPC protocol description</a></h3>
<h4 id="fpc-protocol-operation-for-one-object-id"><a class="header" href="#fpc-protocol-operation-for-one-object-id">FPC Protocol Operation for One Object ID</a></h4>
<p>This section describes how FPC works for one <code>objectID</code>. Once FPC is triggered on the eligibility of the object <code>objectID</code> a node establishes an initial opinion <code>opinion</code> on <code>objectID</code>, see <a href="./6.2%20Opinion%20Setting.html">Section 6.2 Opinion Setting</a>. In particular, the variables <code>queryStatus</code> and <code>answerStatus</code> must be affected using the functions  <code>QueryStatus</code> and <code>AnswerStatus</code>.
The exchange and update of opinions must be done in rounds of length <code>ROUND_LENGTH</code>. Rounds end and start at times (in seconds) that are multiple of <code>ROUND_LENGTH</code>. </p>
<ol>
<li>At the beginning of each round a node must select a random sample of the other nodes and either send a query request or check if the sampled nodes published their opinions on the Tangle. </li>
<li>After <code>TIME_OUT</code> the node must calculate the proportion of the <code>LIKE</code>s in the received opinions. </li>
<li>At the end of the round it must set a threshold to confirm or modify its own opinion. In the first round this threshold is <code>FIRST_ROUND_THRESHOLD</code> while in the subsequent rounds a node must retrieve a random threshold from the dRNG. If the random threshold from the dRNG is not available a node must use 
(<code>SUBSEQUENT_LOWER_THRESHOLD</code>+ <code>SUBSEQUENT_UPPER_THRESHOLD</code>)/2 as threshold.
If the proportion is below this obtained threshold it must set its opinion to <code>DISLIKE</code>, otherwise it must set its opinion to <code>LIKE</code>. In the case that the opinion did not change, the variable <code>cnt</code> must be incremented by 1, otherwise it must be set to 0. If a node did not receive enough answers, i.e., the proportion of mana of the received opinions is less than <code>MIN_MANA_PROPORTION</code> of the total mana of the queried nodes, the round is not counted, i.e., neither opinion nor <code>cnt</code> are changed. </li>
<li>This continues until <code>cnt</code>=<code>TOTAL_ROUNDS_FINALIZATION</code>-<code>TOTAL_ROUNDS_ENDING_THRESHOLD</code>. FPC then enters in the &quot;termination phase&quot; and continues for <code>TOTAL_ROUNDS_ENDING_THRESHOLD</code> rounds using the <code>ENDING_THRESHOLD</code> instead of the random threshold. If during this phase a node changes its opinion it must set <code>cnt</code>=0 and use the random threshold again. The node shall stop querying if <code>cnt</code>=<code>TOTAL_ROUNDS_ENDING_THRESHOLD</code> or <code>cnt</code>=<code>reachedMaxRound</code>. In case that <code>cnt</code>=<code>reachedMaxRound</code> a node must set the final opinion to <code>DISLIKE</code>. </li>
<li>Once FPC terminates (for the given <code>objectID</code>) a node must update the metadata <code>opinionField</code> of <code>objectID</code> with the outcome of FPC as <code>opinion</code> and <code>level=2</code>.</li>
<li>A node must continue to respond to queries as long as <code>AnswerStatus(type, objectID)=TRUE</code>, where <code>type</code> is the type of the <code>objectID</code>. If <code>AnswerStatus(type, objectID)=FALSE</code> the variable <code>answerStatus</code> must be updated accordingly.</li>
</ol>
<p>High consensus Mana nodes will be queried more often than nodes with low consensus Mana, since the sampling using consensus Mana as weights. Every node is given the possibility to publish their opinions in a statement on the Tangle. These messages are called FPC statements. Nodes who decide to issue FPC statements may close the port reserved for FPC queries. A close port can therefore be an indication that a node decided to disseminate its opinions through statements. Every node shall keep a list of nodes that are not answering direct queries but publish their opinions on the Tangle. If a node issues two or more conflicting FPC statements in a round, every other node shall not take these messages into account, i.e., they do not count for the Mana of received opinions neither are used for the calculation of the proportion.</p>
<h4 id="fpc-protocol-operation-for-multiple-object-ids"><a class="header" href="#fpc-protocol-operation-for-multiple-object-ids">FPC Protocol Operation for Multiple Object IDs</a></h4>
<p>It is possible that there are more than one object to vote on. In this case, a node shall sample once per round and obtain the opinions for all objects from this one sample. Malicious or faulty nodes may not respond in a consistent way. In particular, in the case of a double-spending, a malicious node may respond <code>LIKE</code> for two or more conflicting objects. These malicious messages shall be filtered after having received the responses of the queries. Therefore, upon receival of the opinions, a node shall check for every sampled node if its answers are consistent, i.e., all liked objects must form a valid ledger state. Nodes that replied inconsistently shall be filtered out and their answer shall be considered as not received, i.e., they do not count for the Mana of received opinions neither are used for the calculation of the proportion. </p>
<p>Note that since consensus Mana changes over time, FPC may use different consensus Mana values for different <code>objectID</code>s that are voted on at the same time. For an <code>objectID</code>, FPC must use the active consensus Mana of epoch <code>Epoch X-2</code>, where <code>Epoch X</code> contains the timestamp of the <code>objectID</code>. We refer to <a href="./5.3%20Mana.html">Section 5.3 -  Mana</a> for the specification of active consensus Mana. We use a generic function <code>GetActiveConsensusMana(time)</code> that retrieves the active consensus Mana with respect to a given timestamp <code>time</code>.</p>
<h3 id="6324-fpc-pseudocode-description"><a class="header" href="#6324-fpc-pseudocode-description">6.3.2.4 FPC Pseudocode Description</a></h3>
<p>The following presents some pseudo-code for a better understanding of the details of the FPC protocol. </p>
<p>The function <code>GetRN(a, b, time)</code> retrieves a uniform random number between a and b from the dRNG module of a given time <code>time</code>.
If the  dRNG is not retrieved in time a node must use (<code>SUBSEQUENT_LOWER_THRESHOLD</code> <code>SUBSEQUENT_UPPER_THRESHOLD</code>)/2 instead.</p>
<p>In each round a node must query a random sample of other nodes. The random sample is obtained using weighted (by active consensus Mana) sampling with replacement until <code>QUERY_SIZE</code> distinct elements are chosen, or until a maximum sample size of <code>MAX_SAMPLE_SIZE</code> is reached.</p>
<h4 id="getsample"><a class="header" href="#getsample"><code>GetSample</code></a></h4>
<p>This function chooses a sample of nodeIDs for FPC queries.</p>
<pre><code class="language-vbnet">FUNCTION queryList = GetSample(nodeList, manaList)
queryList = []
WHILE (queryList does not contain QUERY_SIZE different elements)
    newSample = SAMPLE(nodeList, weight=manaList)
    queryList = APPEND(queryList, newSample)
RETURN queryList
</code></pre>
<p>The function <code>SAMPLE(nodeList, weight=manaList)</code> chooses a random element from <code>nodeList</code> with weights corresponding to their Mana, i.e., the probability that a <code>nodeID</code> is chosen is proportional to <code>manaList[nodeID]</code>. </p>
<p>Once the list <code>queryList</code> of nodes to query is chosen a node must obtain their opinions about the objects under voting. As there are two possibilities for nodes to communicate their opinions, via direct answers or via FPC statements, a node shall keep information on this behavior up to date. The message layout of the FPC statements is specified in <a href="./2.3%20Standard%20Payloads%20Layout.html#2.3.5.3-fpc-statement">Section 2.3 - Standard Payloads Layout</a>.</p>
<p>At the beginning of each round every node must prepare a query and send it to those nodes in <code>queryList</code> that replies directly (i.e., do not publish FPC statements). </p>
<p>The queries must follow the layout that follows. </p>
<h4 id="queryrequest"><a class="header" href="#queryrequest">QueryRequest</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The message version. The schema specified in this RFC is for version <strong>1</strong> only. </td>
    </tr>
    <tr>
        <td>Tx count</td>
        <td>uint8</td>
        <td>The number of TransactionIDs.</td>
    </tr>
    <tr>
        <td colspan="1">
            TransactionIDs <code>Tx count</code>
        </td>
        <td colspan="2">
            <details open="true">
                <summary>TransactionID, ordered by hash ASC</summary>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>TransactionID</td>
                        <td>ByteArray[32]</td>
                        <td>The ID of the transaction</i>.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
    <tr>
        <td>Msg count</td>
        <td>uint8</td>
        <td>The number of MessageIDs.</td>
    </tr>
    <tr>
        <td colspan="1">
            MessageIDs <code>Msg count</code>
        </td>
        <td colspan="2">
            <details open="true">
                <summary>MessageID, ordered by hash ASC</summary>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>MessageID</td>
                        <td>ByteArray[32]</td>
                        <td>The ID of the message</i>.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>The respond to a QueryRequest must take follow the following form </p>
<h4 id="queryresponse"><a class="header" href="#queryresponse">QueryResponse</a></h4>
<table>
    <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>Version</td>
        <td>uint8</td>
        <td>The message version. The schema specified in this RFC is for version <strong>1</strong> only. </td>
    </tr>
    <tr>
        <td>Obj count</td>
        <td>uint8</td>
        <td>The number of objectIDs. Must equal to <code> Tx count + Msg count</code> of the received QueryRequest</td>
    </tr>
    <tr>
        <td colspan="1">
            Opinions <code>Obj count</code>
        </td>
        <td colspan="2">
            <details open="true">
                <summary>ObjectIDs, in the same order as in received QueryRequest</summary>
                <table>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                    <tr>
                        <td>Opinion</td>
                        <td>Byte    </td>
                        <td>The opinion on objectID</i>.</td>
                    </tr>
                </table>
            </details>
        </td>
    </tr>
</table>
<p>In the case that a certain <code>objectID</code> is unknwon to the node, it must respond with <code>NULL</code>. If the <code>objectID</code> is currently treated by FPC a node must respond with the current opinion, otherwise, retrieve the <code>opinion</code> from the <code>opinionField</code> of the <code>objectID</code>. If the <code>opinionField</code> is <code>NULL</code> the node must respond with <code>NULL</code>.</p>
<p>Note that since the order of the opinions in <code>QueryResponse</code> is important a node may have to produce different messages QueryResponse for different querying nodes.   QueryRequest and QueryResponse must be signed by the sending node. The communication channel for these messages is specified in the field &quot;services&quot; in the DiscoveryRequest, see <a href="./3.1%20Communication%20Models.html">Section 3.1 - Communication Models</a>. We write <code>respond[node, objectIDs]</code> for the respond, per direct QueryResponse or FPC statement, of the <code>node</code> on the <code>objectID</code>s.
A node shall only respond to queries if all included <code>objectsID</code> have status <code>answerQuery=TRUE</code>.</p>
<h4 id="getopinion"><a class="header" href="#getopinion"><code>GetOpinion</code></a></h4>
<p>This function sends queries to all nodes of <code>queryList</code> and obtains their opinion either through QueryResponse messages of from FPC statements on the Tangle. </p>
<pre><code class="language-vbnet">FUNCTION opinionQuery = GetOpinion(objectIDs, queryList)
SEND QueryRequest messages
WAIT UNTIL TIME_OUT  
FOR (node IN queryList)
    IF (node replied) 
        opinionQuery[node, objectIDs] = respond[node, objectIDs]
    ELSE IF (node publishes on Tangle)
        opinionQuery[node, objectIDs] = GetOpinionFromTangle[node, objectID]
    ELSE opinionQuery[node, objectIDs] = NA
RETURN (opinionQuery)
</code></pre>
<p>A node must receive a sufficient amount of replies to validate a given round; otherwise the ongoing FPC round is skipped. More precisely, the consensus Mana of the received opinions must be larger than <code>MIN_MANA_PROPORTION</code> times the sum of the consensus Mana of the sampled nodes. </p>
<p>Once a node receives a FPC query it must prepare a response message as specified above, and shall sent the response as soon as possible. If a node decides to publish its opinions on the Tangle, it must create a so-called FPC statement message and issue it on the Tangle at the beginning of each round. </p>
<p>At the end of each round, i.e., after the <code>TIME_OUT</code> expires, a node must update its opinion if <code>CheckQuerySuccessful</code> is TRUE. The node must calculate the proportion of the <code>LIKE</code>s in the obtained opinions and compare it to a certain threshold. The value of the threshold depends on the phase FPC is in. In the first round, a node must use <code>FIRST_ROUND_THRESHOLD</code> as a threshold, while in the subsequent rounds the node must use a random threshold obtained by <code>GetRN()</code>. Moreover, if <code>cnt</code> &gt; <code>TOTAL_ROUNDS_FINALIZATION</code>-<code>TOTAL_ROUNDS_ENDING_THRESHOLD</code> the node must use <code>ENDING_THRESHOLD</code> for the threshold. 
The following pseudo-code describes the update of the opinion of one given <code>objectID</code>. It uses <code>queryList</code> and <code>opinionQuery</code> obtained by the functions <code>GetSample</code> and <code>GetOpinion</code>. The variable <code>opinion</code> describes the current opinion on <code>objectID</code>.</p>
<h4 id="opinionupdate"><a class="header" href="#opinionupdate"><code>OpinionUpdate</code></a></h4>
<p>This function updates the opinion of a node on <code>objectID</code>.</p>
<pre><code class="language-vbnet">FUNCTION opinion = OpinionUpdate(objectID, opinion, queryList, opinionQuery, round)
manaList = GetActiveConsensusMana(timeObjectID)
answerMana = ownMana
queriedMana
etaStar = 0
FOR node in queryList
    queriedMana += manaList[node]
    IF opinionQuery[node, objectID] != NA
        answerMana += manaList[node]
    IF  opinionQuery[node, objectID] = LIKE
            etaStar++
IF answerMana &lt;= MIN_MANA_PROPORTION * queriedMana
    opinionNew = opinion # 
ELSE 
    eta = etaStar / LENGTH(queryList)
    IF opinion = LIKE
        eta = (ownMana + etaStar*(answerMana-ownMana))/answerMana    
    ELSE IF opinion = DISLIKE
         eta = (etaStar*(answerMana-ownMana))/answerMana 
    WAIT UNTIL CurrentTime/ROUND_LENGTH IS INTEGER
    IF round = 1  
        threshold = FIRST_ROUND_THRESHOLD
    ELSE IF round &lt;= TOTAL_ROUNDS_FINALIZATION-TOTAL_ROUNDS_ENDING_THRESHOLD 
        WAIT DRNG_WAITING_TIME
        threshold = getRN(SUBSEQUENT_LOWER_THRESHOLD, SUBSEQUENT_UPPER_THRESHOLD, CurrentTime)  
        IF threshold = NIL
            threshold = (SUBSEQUENT_LOWER_THRESHOLD + SUBSEQUENT_UPPER_THRESHOLD)/2
    ELSE 
        threshold = ENDING_THRESHOLD
    IF eta &lt; threshold
        opinionNew = DISLIKE
    ELSE
        opinionNew = LIKE
RETURN opinioNew
</code></pre>
<h4 id="mainfpc"><a class="header" href="#mainfpc"><code>MainFPC</code></a></h4>
<p>This function describes the FPC for one <code>objectID</code>. It is triggered once  <code>queryStatus</code> of an object is set to <code>TRUE</code>.</p>
<pre><code class="language-vbnet">FUNCTION opinion = MainFPC(objectId, queryStatus)
IF queryStatus = TRUE  
    opinion = GetInitialOpinion(objectID)
    cnt = 0
}
WAIT UNTIL CurrentTime/ROUND_LENGTH IS INTEGER
round = 1 
WHILE queryStatus = TRUE
    queryList = GetSample(nodeList, manaList)
    opinionQuery = GetOpinion(objectID, queryList) 
    opinionNew = OpinionUpdate(objectID, opinion, queryList, opinionQuery, round)
    IF opinion = opinionNew 
        cnt++
    ELSE 
        cnt=1
    opinion = opinionNew
    round++
    IF cnt = TOTAL_ROUNDS_FINALIZATION 
        queryStatus = FALSE
    IF round &gt;= MAX_ROUND 
        queryStatus = FALSE
        opinion = 1
RETURN opinion
</code></pre>
<h1 id="633-optimizations-suggestions"><a class="header" href="#633-optimizations-suggestions">6.3.3 Optimizations Suggestions</a></h1>
<p>The design given above exemplifies all the mandatory elements of the FPC protocol.</p>
<p>There are several possible ways to optimize the performance of FPC. For example:</p>
<ul>
<li>FPC possibly exposes the public IP adresses of all the IOTA nodes. This can be limited by publishing statements on Tangle. However, if all nodes decide to publish their statements this may have a negative effect on the scalability of the protocol. Please refer to <a href="https://link.springer.com/chapter/10.1007/978-3-030-63089-8_24">Fast Probabilistic Consensus with Weighted Votes</a> for more discussions on how to optimize the message overhead.</li>
<li>Monotonicity and  consistency rules may be applied to reduce the sizes of the messages.</li>
<li>The choice of the FPC parameters could be optimized. The optimal choice depends on the actual mana distribution and network latency. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="64-approval-weight-and-finality"><a class="header" href="#64-approval-weight-and-finality">6.4 Approval Weight and Finality</a></h1>
<h2 id="641-introduction"><a class="header" href="#641-introduction">6.4.1 Introduction</a></h2>
<p>This part of the specifications defines the <em>Approval Weight</em> tool, which allows the notion of <em>Finality</em>.  As every node might have slightly different perceptions of the Tangle at a given time, such a notion is necessary to guarantee consensus on the Tangle and its ledger state. </p>
<p>The intuition behind the approval weight of a given message is that the more influential messages are approving a given message, the more trustworthy such a message will be for the other nodes, and thus the higher the probability that this message branch will be included in the main branch, i.e., will update the ledger state permanently. More details on branches and ledger state may be found in <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>.</p>
<p>The approval weight tool is inspired by the confirmation confidence tool, initially defined in the legacy <a href="https://assets.ctfassets.net/r1dr6vzfxhev/2t4uxvsIqk0EUau6g2sw0g/45eae33637ca92f85dd9f4a3a218e1ec/iota1_4_3.pdf">Tangle whitepaper</a>. However, unlike confirmation confidence which only considered the weight of the future cone of a message to decide if it was final, the approval weight now considers the proportion of approving active consensus Mana, making the protocol more robust against spam and Sybil attacks. </p>
<h2 id="642-definitions"><a class="header" href="#642-definitions">6.4.2 Definitions</a></h2>
<p>To define approval weight, we first need to understand what it means to support a message, we require some concepts of branches from <a href="./5.2%20Ledger%20State.html">Section 5.2 - Ledger State</a>.</p>
<ul>
<li><strong>Conflict:</strong> Two transactions conflict if they consume the same output. A conflict is a transaction that conflicts with another transaction. A transaction \(x\) conflicts with a branch \(B\) if the set of conflicts in \(x\)'s UTXO past cone and the set of conflicts in \(B\) conflict.</li>
<li><strong>Node Approval:</strong> We say that a node approves a given message \(x\) if it has issued a message \(y\) in the strong future cone of \(x\).  A node approves a transaction if it approves some message containing that transaction.</li>
<li><strong>Conflict Supporter:</strong> A node supports a conflict if:
<ul>
<li>It issued a message approving a message containing that transaction.</li>
<li>It has not issued a message on a conflicting branch with a more recent timestamp or with the same timestamp but greater message ID.</li>
</ul>
</li>
<li><strong>Branch Supporter:</strong> A node supports a branch if it supports all of its conflicts.  Equivalently, the supporters of a branch are the intersection of all the supporters of its conflicts.</li>
<li><strong>Message Supporter:</strong> The supporters of a message is the intersection of the approvers of the message, and the supporter of its branch. </li>
<li><strong>Active Consensus Mana:</strong>  The active consensus Mana is defined as the sum of the consensus Mana of all nodes that issued messages during the second last complete epoch <code>cepoch-2</code>, before the current epoch <code>cepoch</code>.  We say that a node that has not issued a message within that epoch has 0 active consensus mana. See <a href="./5.3%20Mana.html">Section 5.3 - Mana</a>.</li>
</ul>
<p>To be clear a node cannot be a  supporter of two conflicting transactions.  If it approves two messages with conflicting transactions,  it supports the one it more recently references (with respect to the timestamp). In the case where the node more recently supported an incompatible message in a different conflict set, then it doesn't support any of the messages.  When a new message is booked, the node goes to the message's branch in the branch DAG and walks through the branch's history giving support to all the conflicts in its past cone and revoking support from conflicting branches.</p>
<p>Here's an example of how the propagation will look like:
<img src="https://user-images.githubusercontent.com/11289354/112409357-518e9480-8d54-11eb-8a40-19f4ab33ea35.png" alt="ApprovalWeight" /></p>
<p>The green node issued <strong>message 1</strong> and attached it to <code>Branch 1.1 + Branch 4.1.1</code>. Thus, green node is a supporter of <code>Branch 1.1 + Branch 4.1.1</code>, and it's also a supporter of the parent branches, which are (from top to bottom) <code>Branch 4.1.1</code>, <code>Branch 1.1</code>, <code>Branch 4.1</code>, <code>Branch 1</code>, and <code>Branch 4</code>.</p>
<p>Later, the green node issued <strong>message 2</strong> and attached it to <code>Branch 4.1.2</code>. This makes the green node a supporter of <code>Branch 4.1.2</code>, however, <code>Branch 4.1.1</code> is conflicting with <code>Branch 4.1.2</code>, which makes green node not a supporter of <code>Branch 4.1.1</code>, and therefore the support to <code>Branch 1.1 + Branch 4.1.1</code> is removed as well. </p>
<p>Finally, green nodes issued <strong>message 3</strong>, which is in <code>Branch 2</code>. Now the green node is a supporter of <code>Branch 2</code>, and no longer a supporter of <code>Branch 1</code>, since <code>Branch 1</code> is conflicting with <code>Branch 2</code>. Note that, this supporter removal will propagate to child branches. Thus, green node is removed from <code>Branch 1.1</code>. </p>
<p>Since <code>Branch 3</code>, <code>4</code>, and both of their child branches have nothing to do with this attachment, the supporter status remains. </p>
<h2 id="642-approval-weight"><a class="header" href="#642-approval-weight">6.4.2 Approval Weight</a></h2>
<p>The approval weight of a conflict (resp. branch or message) is the dot product of the vectors of supporters and the normalized consensus Mana vector (see <a href="./5.3%20Mana.html">Section 5.3 - Mana</a>). Equivalently, the approval weight is the proportion of active consensus Mana that belongs to the supporters of the conflict (resp. branch or message).</p>
<p>We will use \(\text{AW}(x)\) to represent the approval weight of a message or branch \(x\). There are several important facts to state about approval weight:</p>
<ul>
<li><strong>Approval weight range</strong>: The approval weight is always between \(0\) and \(1\), and thus can be expressed as a percentage.</li>
<li><strong>Approval weight equivalency</strong>: For a conflict \(x\) attached once in a message \(m\), the following are the same: the approval weight of \(x\), the approval weight of the conflict branch defined by \(x\), and the approval weight of the message \(m\). </li>
<li><strong>Tangle Monotonicity:</strong> The approval weight of a message is smaller than its past cone, i.e. if message \(x\) approves message \(y\), then \(\text{AW}(y)\geq \text{AW}(x)\).</li>
<li><strong>Branch Monotonicity:</strong> The approval weight of a branch is greater than the branches in pastcone on the branch DAG, i.e., if branch \(B\) contains branch \(C\), then \(\text{AW}(C)\geq \text{AW}(B)\).</li>
<li><strong>No Time Monotonicity:</strong> The approval weight of a fixed message or branch \(x\) does not necessarily grow with time because of the nodes' active consensus Mana fluctuates and support can be revoked.</li>
<li><strong>Approval weight inequalities:</strong>  For any message \(m\) and its branch \(B\), we have \(\text{AW}(B)\geq \text{AW}(m)\). Similarly, for any conflict \(x\) within a branch, \(\text{AW}(x)\geq \text{AW}(B)\), since any supporter of the branch \(B\) is a supporter of \(x\).</li>
</ul>
<p>Observe that the non-monotonicity on time is actually desirable, as otherwise it would not be possible to orphan malicious or non-preferred conflicting messages.</p>
<h2 id="643-finality"><a class="header" href="#643-finality">6.4.3 Finality</a></h2>
<p>Finality in IOTA 2.0 must always be considered as probabilistic, in the sense that a final message is included in the ledger with a very high probability. Two desired properties in a finality criterion are a fast confirmation rate and a high probability of non-reversibility. We use interchangeably the terms &quot;finality&quot; and &quot;confirmation&quot;. We now present the proposed criterion for finality. </p>
<ul>
<li><strong>Branch Finality/Confirmation:</strong> A branch \(B\) is considered finalized (or confirmed) if its approval weight is at least \(0.5\) higher than any conflicting branch.  The master branch is always finalized.</li>
<li><strong>Message Finality/Confirmation:</strong> A message \(m\) is considered finalized (or confirmed) if \(\text{AW}(m)&gt;0.5\) and its branch is finalized. </li>
<li><strong>Transaction Finality/Confirmation:</strong> A transaction is considered finalized (or confirmed) if both its message and its branch are final (confirmed). </li>
</ul>
<p>Because of the Tangle monotonicity property, if a message is finalised, its entire past cone is finalised as well.</p>
<h2 id="644-markers-application-to-finality"><a class="header" href="#644-markers-application-to-finality">6.4.4 Markers Application to Finality</a></h2>
<p>The approval weight of the branch is updated whenever the supporters are updated.  However, it is impractical to store the supporters of every message, and even calculating it on demand is unfeasible, since the computational cost of doing a future cone search to determine its approvers is immense.  To ease this calculation, we make use of the markers tool, see <a href="./4.7%20Markers.html">Section 4.7 - Markers</a>, to approximate the approval of a message weight in an efficient way. </p>
<p>Markers are basically chains of indexed messages, and each message is associated with the most recent marker it approves and the oldest marker that approves it. When a new message arrives, the approvers of each marker can be updated by traversing the much smaller marker DAG and, from the Tangle monotonicity property, we know that if the marker achieve a certain value of approval weight, the message it approves will have a higher value.</p>
<p>Using those properties, we can define a lightweight criterion which we call <strong>Markers Application to Finality:</strong></p>
<ul>
<li>The supporters of any mark are tracked, which is made easier by the metadata associated to each marker, see <a href="./4.7%20Markers.html">Section 4.7 - Markers</a>.</li>
<li>If any marker reaches message confirmation, we give the &quot;confirmed&quot; status to all messages in its past cone, and hence transaction confirmation to all transactions it may contain.</li>
<li>If a tracked marker reaches age <code>FinalityMaxAge</code> without achieving confirmation, it will receive the status &quot;Orphaned&quot;.</li>
</ul>
<h2 id="645-liked-and-monotonically-liked"><a class="header" href="#645-liked-and-monotonically-liked">6.4.5 Liked and monotonically liked</a></h2>
<p>Via finality, the approval weight is also used in conjunction with FPC and to determine which branches should be considered for tip selection.  To do this we have the concept  of branches and conflicts being &quot;liked&quot;.</p>
<ul>
<li><strong>Liked conflict:</strong> A conflict is liked (or individually liked) if either:
<ul>
<li>The opinion of the transaction is <code>true</code> and the <code>level</code> is either 2 or 3 (i.e. FPC has terminated with <code>liked</code> status, see <a href="./6.1%20Objects%20of%20Consensus.html">Section 6.1 - Objects of Consensus</a>) AND it does not conflict with a finalized transaction.</li>
<li>The conflict is finalized.</li>
</ul>
</li>
<li><strong>Individually liked conflict branch:</strong> A conflict branch is individually liked if the conflict defining it is liked.</li>
<li><strong>Monotonically liked branch:</strong> A branch is monotonically liked if all of its conflicts are liked.  Equivalently, a branch is monotonically liked if all of its conflict branches in its branch past cone are individually liked.</li>
</ul>
<p>FPC initially determines which conflicts are liked.  However, nodes that are syncing and missed the FPC voting will default to the conflicts which are finalised.  Decisions about each conflict set are carried out by FPC individually and so we separate between &quot;individually liked&quot; and &quot;monotonically liked&quot;. 
Branches that are monotonically liked have their entire history liked and can be included in the strong past cone of messages.  Monotonically like branch IDs will thus receive more supporters and thus eventually become finalised.</p>
<p><strong>Note</strong>: Once a branch gets confirmed, the conflicting ones receive the status &quot;Rejected&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="65-distributed-random-number-generator"><a class="header" href="#65-distributed-random-number-generator">6.5 Distributed Random Number Generator</a></h1>
<h2 id="651-introduction"><a class="header" href="#651-introduction">6.5.1 Introduction</a></h2>
<p>The module presented in this specification allows for the distributed generation of randomness for the post-Coordicide IOTA network. The distributed random number generator (dRNG) protocol is divided into three phases:</p>
<ol>
<li>
<p>COMMITTEE SELECTION: In the first phase, a committee of high Consensus Mana nodes is selected. The procedure is objective i.e., all of the nodes in the network reach a consensus on which nodes should be in the committee.
In order for a node to be considered as a candidate to the committee, it needs to declare its willingness to participate, with a special <em>application message</em>. When all of the required application messages are recorded in the Tangle, the <code>committeeNodes</code> top consensus Mana holders among the candidates are selected as the committee. In the case where some of the required messages fail to be produced, the committee selection will consequently fail as well.</p>
</li>
<li>
<p>DKG PHASE: In the second setup phase, the committee members create a collective private key which will be used later to generate the random number, using the \((t,n)\) Distributed Key Generation (DKG), that does not rely on centralized, trusted third parties. The participation of the nodes in this phase can be publicly verified since the messages exchange takes place in the Tangle. </p>
</li>
<li>
<p>PUBLICATION PHASE: This last phase consists of the periodical publication of the beacon messages in the Tangle. A single individual beacon message should not be sufficient to reveal the random number; instead, the beacon messages from at least \(t\) out of \(n\) committee members are needed for the next random number being revealed. Additionally, the committee members publish a collective beacon message, which would contain the random number. </p>
</li>
</ol>
<p>A large part of the procedures in this specification is based on the article <a href="https://arxiv.org/abs/2102.03139">Committee selection in DAG distributed ledgers and applications</a>, where authors discuss multiple methods of the committee selection and applications.</p>
<h2 id="652-dependencies"><a class="header" href="#652-dependencies">6.5.2 Dependencies</a></h2>
<p>The dRNG module depends on the <a href="./5.3%20Mana.html">Section 5.3 - Mana</a> since it uses the Consensus Mana (cMana) vector as a measure of trustworthiness. Specifically, it uses the list of the top cMana holders to select a committee to produce the random numbers. During the committee selection, we do not assume a perfect agreement on the cMana values, i.e., different nodes can have slightly different perceptions of the cMana values of other nodes (due to the different local clocks). Obtaining consensus on the cMana values is the central part of this documentation. </p>
<p>The random numbers produced by dRNG are used in <a href="./6.3%20Fast%20Probabilistic%20Consensus.html">Section 6.3 - Fast Probabilistic Consensus</a>.</p>
<h2 id="653-parameters"><a class="header" href="#653-parameters">6.5.3 Parameters</a></h2>
<p><strong>Table 6.5.1  dRNG parameters</strong></p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th><th>Value</th></tr></thead><tbody>
<tr><td><code>rnPeriod</code></td><td>duration</td><td>Random number is produced every<code>rnPeriod</code> seconds</td><td>20 [sec]</td></tr>
<tr><td><code>committeeNodes</code></td><td>integer</td><td>Number of nodes in the committee</td><td>10 [nodes]</td></tr>
<tr><td><code>committeeSeats</code></td><td>integer</td><td>The number of identities (seats) in the top Mana holders committee equals <code>committeeSeats</code>. It is different from <code>committeeNodes</code> because some of the nodes receive double seats in the committee.</td><td>15   [seats]</td></tr>
<tr><td><code>sigThreshold</code></td><td>integer</td><td>Signature threshold parameter (number of beacon messages needed to obtain randomness)</td><td>8 [messages] ([seats])</td></tr>
<tr><td><code>committeeUpdate</code></td><td>duration</td><td>Period of committee update</td><td>1 [day] = 86400 [sec]</td></tr>
<tr><td><code>applicationWindow</code></td><td>duration</td><td>Time window of the ''application'' message submission</td><td>120 [sec]</td></tr>
<tr><td><code>TIMESTAMP_CUTOFF</code></td><td>duration</td><td>Message timestamp cutoff (Assuming the node is in sync, the time after which point the node will receive no new messages with a particular timestamp which will be finalized)</td><td>2<code>DLARGE</code> +<code>W</code>= 90[sec]</td></tr>
</tbody></table>
<p>For more information on the <code>TIMESTAMP_CUTOFF</code>  see section <a href="./4.2%20Timestamps.html">Section 4.2 -  Timestamps</a></p>
<h2 id="654--committee-selection"><a class="header" href="#654--committee-selection">6.5.4  Committee selection</a></h2>
<p>To select the committee based on the cMana, we need to achieve consensus on these values. To solve this problem, we use epochs a reference point which can be used to calculate the cMana values in an objective manner. </p>
<p>The willingness to participate in the committee is announced with a special application message, which like any other transactions in the Tangle are equipped with timestamps. Since the nodes following the protocol judge and invalidate messages which timestamps are too off, we can assume that the application messages can reliably give us a list of nodes interested in joining the committee. </p>
<p>The committee selection process starts at the time \(t_S\) and should be done (assuming no problems occur) at the time \(t_F\). The time \(t_F\) is determined by the committee update time, \(t_S\) depends also on the <code>applicationWindow</code> and <code>TIMESTAMP_CUTOFF</code>.</p>
<p>Only nodes that are in synch with the network should participate in the committee selection. If a node is out of synch (<code>SyncStatus = FALSE</code>) it should skip this committee selection. </p>
<h3 id="6541-application-messages"><a class="header" href="#6541-application-messages">6.5.4.1 Application messages</a></h3>
<p>Any node can issue an application message. Such a message would be processed by the nodes (assuming it passes the congestion control, along with other checks). However, for a low mana node, there is no incentive to apply for the committee, as the probability of being selected is very low; hence, they can decide to not take part in sending application messages. Although it is allowed, sending multiple application messages is pointless and costly due to the congestion control mechanism.</p>
<p>For brevity denote <code>TIMESTAMP_CUTOFF</code> by \(\Delta_C\) and <code>applicationWindow</code> by \(\Delta_A\). Assume that a committee should be formed at the time \(t_F\) (which is known to all interested nodes; it is defined on the protocol level). Assume further that the time \(t_F\) is in the epoch \(E\) i.e., \(t_F\) \(\in\) \([t_{E-1}, t_E]\). Then the active consensus Mana vector from the time \(t_{E-2}\) is calculated,  which is the balance from two epochs before \(t_F\). The committee selection process starts with the opening of the application message window at the time \(t_S\), where \(t_S = t_F-\Delta_A -2\Delta_C\). For as long as the application window is open, nodes can issue application messages. See the subsection &quot;6.5.3.1 Application message sending - default algorithm&quot; for the proposed algorithm of issuing application messages (which is not enforceable). </p>
<h3 id="6542-application-message-sending---default-algorithm"><a class="header" href="#6542-application-message-sending---default-algorithm">6.5.4.2 Application message sending - default algorithm</a></h3>
<p>A node is said to be \(M_\ell\) if its consensus Mana rank is less or equal to \(\ell\) (node is among \(\ell\) top Mana nodes). Computation of node's Mana rank is taking place with respect to the time from two epochs ago i.e., with respect to \(t_{E-2}\) under the assumption that \(t_S \in [t_{E-1},t_E]\).</p>
<p>For brevity denote <code>committeeNodes</code> by \(m\). If an interested node \(x\) is \(M_{2m}\) then it issues an application at the time \(t_S\). Notice that, in general, not all of the \(2m\) application messages will be sent (due to for example nodes going offline or malfunction). If less than \(m\) strongly valid application messages are sent at \(T_S\), the nodes that are \(M_{3m}\) (but not \(M_{2m}\)) issue their application messages at the time  \(T_S- \Delta_A \frac{1}{2}\) and so on. In general, for \(k&gt;2\), if a node \(x\) which is \(M_{m k}\) but not \(M_{m (k-1)}\), it submits a committee application whenever before the time \(T_S- \Delta_A \frac{k-2}{k-1}\) there are less than \(m\) strongly valid application messages with cMana greater than the cMana of node \(x\).</p>
<p>See subsection <strong>6.5.9 Pseudocodes</strong> for the pseudocodes of the default application message sending procedure.</p>
<p>If at least \(m\) of the nodes sent an application message within the time interval, the committee is formed from the top \(m\) Mana nodes who applied. Due to the network delay, this can be confirmed only at the time \(t_S+\Delta_A+\Delta_C\).</p>
<p>If less than \(m\) nodes send application messages, then the committee selection will fail. This is confirmed at the time \(t_S+\Delta_A+\Delta_C\). In this case, the procedure should be repeated immediately, with new starting time \(t'_S\) and finish time \(t'_F\) such \(t'_S =t_S+\Delta_A+\Delta_C\) and \(t'_F=t_F+\Delta_A+\Delta_C\). </p>
<h2 id="655-dkg-phase"><a class="header" href="#655-dkg-phase">6.5.5 DKG phase</a></h2>
<p>After a successful committee selection, confirmed at the time \(t_S+\Delta_C+\Delta_A\) with respect to the node's local clock, the DKG phase starts. In this phase, the committee nodes exchange the <em>Deal messages</em> to produce a public/private collective key. There is no time window for the DKG phase and nodes should proceed with the corresponding  DKG message exchange as soon as the committee selection is confirmed (time \(t_S+\Delta_C+\Delta_A\)). Only DKG messages with this timestamp are accepted. </p>
<p>If any of the committee nodes refuse to create a collective key pair by not exchanging the  Deal DKG messages, the DKG phase fails. This can be confirmed at the time \(t_F= t_S+2\Delta_C+\Delta_A\). Moreover, since the message exchange occurs on the Tangle, everybody can identify the nodes that caused the failure. In the case of DKG phase failure, the entire committee selection is repeated (including the application phase). New start and finish time are \(t'_S = t_F= t_S+2\Delta_C+\Delta_A\) and \(t'_F= t_F+2\Delta_C+\Delta_A\). The malicious node is then excluded from the new committee selection - all application messages issued by a malicious node are ignored. Ban on the committee application is lifted after a successful committee selection i.e., the committee produces its first beacon messages. In other words, if a node failed to produce a DKG message (either due to malfunction or maliciousness) it cannot apply to be in the current committee, however, it can apply in the next committee selection process. </p>
<h2 id="656-double-seats"><a class="header" href="#656-double-seats">6.5.6 Double seats</a></h2>
<p>We can increase the security of the dRNG beacon by granting double seats to half of the committee members that have the highest committee Mana. Those nodes would receive two private keys (identities) with which they sign beacon messages in the Tangle. From the technical point of view, the two seats are completely separate, and issued Beacon messages can not be combined (even though they were signed by the same node). This modification increases the amount of Mana required to &quot;overtake&quot; the committee, which is understood as gaining <code>sigThreshold</code> of seats in the committee. </p>
<p>The number of nodes in the committee with double seats equals \(\lfloor m/2 \rfloor\) (top half of the committee nodes). The total number of identities in the committee equals \(m + \lfloor m/2 \rfloor\).</p>
<h2 id="657-publication-of-the-random-number"><a class="header" href="#657-publication-of-the-random-number">6.5.7 Publication of the random number</a></h2>
<p>The committee will collectively generate a random number based on the set of beacon messages that each node will individually produce. A single beacon message is not sufficient to reveal the random number; instead,  <code>sigThreshold</code> or more beacon messages are needed for the next random number to be revealed. </p>
<h3 id="6571-collective-beacon-message"><a class="header" href="#6571-collective-beacon-message">6.5.7.1 Collective beacon message</a></h3>
<p>To recover the random number from the individual beacon messages, all nodes in the network would need to perform Lagrange interpolation. To avoid that, we propose that the committee nodes produce a <em>collective beacon message</em>, which contains a pre-computed random number (meaning that the committee nodes perform the Lagrange interpolation on their own). Since the committee size is small and the expected throughput of the network is large, we require all committee members to produce this collective beacon message as soon as they receive <code>sigThreshold</code> individual beacon messages. </p>
<p>The cost of getting randomness from the collective beacon would be reduced as only (additionally to the default message checks) the signature verification would be required.</p>
<h2 id="658-duties-of-the-old-committee"><a class="header" href="#658-duties-of-the-old-committee">6.5.8 Duties of the old committee</a></h2>
<p>An old committee should only stop producing randomness if another committee was successfully selected and started producing random numbers, which will be confirmed when the first collective beacon message is produced by the new committee and can be read directly from the Tangle.</p>
<h2 id="659-alternative-drng-and-backup-options"><a class="header" href="#659-alternative-drng-and-backup-options">6.5.9 Alternative dRNG and backup options</a></h2>
<p>To increase the liveness of the random number production multiple dRNGs may be deployed. Secondary dRNGs can be used if the primary one is not available; it is also possible that users alternate between random numbers from multiple dRNGs. </p>
<p>However, this discussion is out of the scope of this specification document. </p>
<h2 id="6510-pseudocodes"><a class="header" href="#6510-pseudocodes">6.5.10 Pseudocodes</a></h2>
<p>Actions after receiving incoming transaction which is an application message:</p>
<pre><code class="language-vbnet">IF (NOT IsBlacklisted(IssuingNode(tx)))
   IF (Mana(IssuingNode(tx),E-2) &gt; Mana(My_node,E-2))
      numberValidApplicationMessagesWithManaHigherThanMine ++ 
</code></pre>
<p>Actions of a node interested in committee participation:</p>
<pre><code class="language-vbnet">IF (thisNodeWantsToParticipateInDRNG)
   WaitUntil (tS)  
        ell = GetManaRank(myNode,Epoch-2)  
        ApplicationMessageSend(ell)  
</code></pre>
<pre><code class="language-vbnet">FUNCTION ApplicationMessageSend(ell)  
    IF (ell &lt;= 2m)  
        SendApplicationMessage()
    ELSE  
        WaitUntil(T_S- applicationWindow *[1-(floor(ell/m)-2)/(floor(ell/m)-1)])  
        IF (numberValidApplicationMessagesWithManaHigherThanMine &lt; m)
            SendApplicationMessage()
</code></pre>
<h2 id="6511-payload-layout"><a class="header" href="#6511-payload-layout">6.5.11 Payload layout</a></h2>
<p>DRNG payload layout is discussed in <a href="./2.3%20Standard%20Payloads%20Layout.html#2.3.5.5-drng-application-message">Section 2.3 - Standard Payloads Layout</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
