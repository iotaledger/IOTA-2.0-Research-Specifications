+ Feature name:  FPC specifications
+ Start date: 2020-03-16
+ Start revision: 2021-03-03

# 5.1 FPC specification


The module presented in this specification, FPC, allows nodes to find consensus on whether a transaction is valid or not. 

FPC is a voting based consensus protocol. If the validity of a transaction is uncertain, see section 5.2, nodes query each other to find consensus. FPC is divided into rounds. At every round each node queries a random sample of other nodes and updates it opinion according to the rules specified below. This procedure stops locally if a node did not change its opinion over a certain period of time or if some maximal amount of rounds is reached. 

FPC is different from existing voting based consensus protocols, since it uses a sequence of common random thresholds. This randomness makes FPC robust in Byzantine environment. We refer to ALL THE RESEARCH PAPERS WE WROTE. HTML.

The initial opinions on the validity of transactions are based on "time".  At various parts local clocks, REFER TO LEVEL OF KNOWLEDGE, will be used and compared to the timestamps of messages. There are general standing assumption on network latency and clock synchronisations.  In a nutshell, we consider that the differences in clocks are at least one order of magnitude lower than the network latency. 


# 5.1.1 FPC

The protocol tries to find consensus on the validity of an object `objectID`. Every node has an initial opinion `Opinion`(boolean) on this transaction. These opinions are updated in rounds until the protocol terminates using a local stopping rule. We have two types of consensus objects: messages (REF) and transactions (REF). 

>[Seb] Where do we talk about the different kinds of possible reasons  for conflicts? In 5.2?


## 5.1.1.1 FPC parameters
We give a list of all parameters needed for FPC.

* `TotalRoundsFinalization` integer - Number of consecutive rounds before FPC auto-terminates;
* `TotalRoundsFixedThreshold` integer - Number of consecutive rounds with non-random threshold;
* `FirstRoundThreshold`  double - Threshold of the proportion of opinions in the first round;
* `SubsequentRoundsLowerBoundThreshold` double -  Lower random threshold bound in subsequent rounds;
*  `SubsequentRoundsUpperBoundThreshold` double -  Upper random threshold bound in subsequent rounds;
* `maxRound` integer - Maximum number of rounds before querying stops;
* `querySize` integer - Quorum size, number of nodes that are queried;
* `roundLength` double - Duration (in seconds) of a round;
* `timeOut` - maximal waiting time to receive answers dor FPC queries`;
*  `MinManaProportionOfOpinionsReceived` - minimal amount of received answers that allow to update opinion. If this amount is not reached the current round is not counted. 


The default values for value objects of the parameters are: 

| Parameter  |      Value     | 
|----------|:-------------:|
| `TotalRoundsFinalization` | 10  |
| `TotalRoundsFixedThreshold` |  3     |
| `FirstRoundThreshold` | 0.67|
| `SubsequentRoundsLowerBoundThreshold` | 0.50 |
| `SubsequentRoundsLowerBoundThreshold`| 0.67|
| `maxRound`|100 |
|` querySize` | 21|
| `roundLength`| 10 * time.Seconds |
|`timeOut` | 6500 * time.Millisecond |
| `MinManaProportionOfOpinionsReceived`| 50% |



## 5.1.1.2 Local variables

The opinion  `Opinion` of a node on an object is described by the following type. 

```
Opinion: {
    DISLIKE: 0,
    LIKE: 1,
    NULL: NULL  #The node does not know about the object,
    NA : NA # a node does not receive an answer of the opinion of another node
}
```



Every node has the following variables
* `nodeList` - list of all nodes;
* `manaList` - list of mana values of nodes;
* `mana` double - mana of node;
* `cnt` integer - counter of the the number of consecutive rounds with unchanged opinion;
* `queryStatus` boolean - status if actively querying;
* `answerStatus` boolean - `TRUE` if answering queries, otherwise `FALSE`;
* `round` integer - counter for the number of rounds in FPC;
* `rn` double - random number provided by from dRNG module;
* `rnCycle` double - random number instance (see X.X.X.X);
* `queryList`- list of nodes to query;
* `queryMax`- maximal number of queries per round;
* `opinionQuery` - list of opinion of nodes in `queryList`, non-replies are encoded with `NA`;
* `reachedMaxRound` boolean - indicating whether protocol reached `maxRound` before auto-termination, default value `FALSE`;


## 5.1.1.3 Function list
* `getIninitialOpinion` input: `objectID` output: `Opinion`;
* `getRN` input: `rnCycle` output: `rn`;
* `getNodes` input:   output: `nodeList`;
* `getConsensusMana` input: `nodeList` output: `manaList`;
* `getSample` input: `querySize` `nodeList` `manaList` : output `queryList`;
* `getOpinion` input: `objectID` `queryList` output: `opinionQuery`;
* `checkQuerySuccessful` input: `queryList` `opinionQuery` `MinManaProportionOfOpinionsReceived`  output: `querySuccessful`: checks whether `opinionQuery` from `getOpinion` contains enough answers; 
*  `opinionUpdate` input: queryStatus output: `opinion` 


## 5.1.1.4 Pseudocode 
 
Note: In the pseudocode at various places global variables are again used as input for the functions. 

### `getInitialOpinion`

>[Seb] Link to Level of Knowledge

### `getRN(layer, a, b, time)`
gets a uniform random number between (a,b),

>[Seb] to be discussed/related with DRNG, Be more precise on the source of randomness


OUTPUT: randomThreshold, source of randomness

### `getNodes` 

>[Seb] This function should be defined somewhere in autopeering module. But it seems that we need a proper list, since some high mana nodes may not be participating in autopeering

### `getConsensusMana(time)`

This function gets the consensus mana vector of the epoch containing `time`.
>[Seb] to be updated once mana section is updated


### `getSample(querySize, nodeList, manaList)`
This function chooses the sample for FPC queries.
```
queryList = empty
while (queryList does not contain querySize different elements){
    newSample:=Sample(nodeList, weight=mana, replacement=TRUE)
    queryList = concat(queryList, newSample)
}
return queryList
```

### `getOpinion(queryList, timeOut)`
This function sends queries to all nodes of `queryList`.
```
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionQuery
```

### `checkQuerySuccessful(queryList, opinionQuery,MinManaProportionOfOpinionsReceived )`
This functions checks is a node received sufficiently many answers such that the ongoing round can be considered.
```
queriedMana := sum(manaList[queryList])
answerMana :=  sum(manaList[queryList[replied==TRUE]])/queriedMana
querySuccessful := ifElse( answerMana>= MinManaProportionOfOpinionsReceived * queriedMana , TRUE, False)
return querySuccessful
```

### `sendOpinion(timeOut)`
This function answers queries that arrive before lastRoundTime+timeOut
```
send replies to all node that querried as soon as possible and before lastRoundTime+timeOut
```


### `opinionUpdate(layer, opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)`
This function updates the opinion of a node during a FPC round.
```
Sample :=getSample(querySize, nodeList, manaList)
opinionQuery := getOpinion(queryList, timeOut)
if (!checkQuerySuccessful(queryList, opinionQuery)){ #check if sufficiently many nodes replied in time
    newOpinion := opinion # if not keep old opinion 
}
else{ # otherwise update according to FPC rule
    etaStar := mean(opinionQuery, NA.remove=TRUE)
    totalMana := sum(listMana, NA.remove=TRUE) # remove nodes that did not answer
    eta := opinion*mana + etaStar*(totalMana-mana)/totalMana
    if (round == 1){ #first FPC round uses different threshold
        if (eta < FirstRoundThreshold){
            newOpinion <-0
        }
        else newOpinion <-1
    }
    else #the subsequent rounds (before the TotalRoundsFixedThreshold confirming) use random threshold
        rn := getRN(layer, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, time)  # here we have to synchronize/wait for random number
        if (eta < rn){
            newOpinion <-0
        }
        else newOpinion <-1       
}
return newOpinion 
```


### `mainFPC(objectId, queryStatus)`
This function describes (locally) the FPC protocol for a node. 
```
if (queryStatus turns TRUE ){ 
    opinion := getInitialOpinion(objectID)
    listMana := getMana()
    listNode := getNodes()
    cnt := 1
}
wait for new FPC round # next random number from dRNG
#start the first FPC round
round := 1 
opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, ubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
if (opinion==opinionNew) cnt++
else cnt:=0
opinion := opinionNew
round++

#continue FPC, subsequent rounds 
while queryStatus {
    if (cnt <= TotalRoundsFinalization-TotalRoundsFixedThreshold) # we use random threshold{
        opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, FirstRoundThreshold, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, round, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew
    }
    else {  # we use deterministic threshold for TotalRoundsFixedThreshold "confirming" rounds
    opinionNew <- opinionUpdate(opinion, querySize, nodeList, manaList, 0.5, SubsequentRoundsLowerBoundThreshold, SubsequentRoundsUpperBoundThreshold, 1, time)
        if (opinion==opinionNew) cnt++
        else cnt:=0
        opinion := opinionNew      
    }
    round++
    if (cnt==TotalRoundsFinalization) queryStatus:=FALSE
    if (round>=MaxRound) {
        queryStatus:=FALSE
        reachedMaxRound:=TRUE
    }
}
return(opinion)
```

## 5.1.1.5 Message/ layout

>[seb] reference to 2.2 or 2.3

### Querying message

### Answering message


# 5.1.2  Adadption of FPC for multiple ongoing votings

At every round FPC decides on possibly several opinions. However, the every node will only query other nodes once. This is done for scalability. 

The local variable `opinions` records the vector of all opinions under vote. 

### `getInitialOpinions`

This function uses `getInitialOpinions` in a straightforward way.
>[Seb] Refer to level of Knowledge, in particular if initial opinions are formed independently and using some consistency/monotonicty rule.


### `getOpinions(queryList, timeOut)`
This function sends queries to all nodes of queryList and stores the result in `opinionsQuery`.
```
sends queries to all nodes of queryList
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
return opinionsQuery
```

>[Seb] FPC is now applied for each opinion separately. However, to increase the performance of FPC make opinions after each round consistent; if the parent is disliked then opinions of all children are disliked. Also the voting of a child can not be finalized before its parent.

>[Seb] This has to be aligned with level of knowledge

In FPC on multiple objects, it may be that malicious node reply `like` for two or more conflicting objects. These malicous messages have to be filtered after having received the reposonses of the queries 

### `checkConsistencyRule(opinionsQuery)`
```
check if node did not follow consistency rule
return updated opinionsQuer
```

# 5.1.4 Gossiping
High mana nodes will be queried too often. Every node has the possibility to publish their opinion in a statement on the tangle.  
Nodes who decide to gossip may close the port corresponding to queries. A close port can therefore be an indication that a node decided to disseminate its opinins through statements.

This option make the following of the function `getOpinions` necessary. 
### `getOpinions(queryList, timeOut)`
```
send queries to all nodes of queryList that do not gossip
wait until time out  #like half of length of rn cycle
for (node in queryList){
    if (replied[node]){
        opinionQuery[node]=reply[node]
    } else opinionQuery[node]:=NA
} 
read opinions from tangle of all to all nodes of queryList that do gossip

return opinionsQuery
```

# 5.1.5 Drawbacks

+ The base FPC exposes the public IP of all the IOTA nodes. This can be limited by publishing statements on tangle. However, if all nodes decide ti publish their statement this may have a nagative effect on the scalability if the protocol.

# 5.1.6 Rationale and alternatives

- The design is the simplest design that encorporates all necessary ingredients of FPC.
- There are several possible ways to possible optimize the performance. For instance, use monotonicty and consistency to reduce the sizes of the messages. These optimizations may be implemented at a later stay if it turns out that they could improve the performances.
- In the case that FPC is used on validity of messages we can use a symmetric range of the random threshold, `SubsequentRoundsLowerBoundThreshold=beta, SubsequentRoundsLowerBoundThreshold=1-beta` for some `beta`. This may allow to increase the support of the random threshold (and hence robustness against an attacker) without endangering the liveness of honest messages. 

# 5.1.7 Unresolved questions

- The choice of the parameters could be optimized. In particular, an optimal choice depend on the actual mana distribution and network latency. 
- In case `checkConsistencyRule()` finds inconsistent behavior a node, this node could be blacklisted.