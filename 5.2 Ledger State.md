# 5.2 Ledger State

The introduction of a voting-based consensus requires a fast and easy way to determine a node's initial opinion for every received transaction. This includes the ability to both detect double spends and transactions that try to spend non-existing funds. 
These conditions are fulfilled by the introduction of an Unspent Transaction Output (UTXO) model for record-keeping, which enables the validation of transactions in real time, see also the section on [UTXO](5.1%20UTXO.md).

The concept of UTXO style transactions is directly linked to the creation of a directed acyclic graph (DAG), in which the vertices are transactions and the links between these are determined by the outputs and inputs of transactions. 

To deal with double spends and leverage on certain properties of UTXO, we introduce the Realities Ledger State. 

## 5.2.1 Realities Ledger State 

In the Realities Ledger State, we model the different perceptions of the ledger state that exist in the Tangle. In each “reality” on its own there are zero conflicting transactions. 
Each reality thus forms an in itself consistent UTXO sub-DAG, where every transaction references any other transaction correctly.

Since outputs of transactions can only be consumed once, a transaction that double spends outputs creates a persistent branch in a corresponding UTXO DAG, and each branch receives a unique identifier `branchID`. These branches cannot be merged by any vertices (transactions). A transaction that attempts to merge incompatible branches fails to pass a validity check and is rejected. 

The composition of all realities defines the Realities Ledger State. 

From this composition nodes are able to know which possible outcomes for the Tangle exist, where they split, how they relate to each other, if they can be merged and which messages are valid tips. All of this information can be retrieved in a fast and efficient way without having to walk the Tangle. 

??? Above it is mentioned that branches can be merged, but a few lines above the opposite is said. ?

Ultimately, for a set of competing realities, only one reality can survive. It is then up to the consensus protocol to determine which branch is part of the correct or final reality.

??? what happens to the conflicting realities when this is determined. Are they discarded?

In total the ledger state thus involves three different layers:
* the UTXO DAG,
* its extension to the corresponding branch DAG,
* the Tangle which projects the information from the UTXO layer onto the messages.

## 5.2.2 The UTXO DAG

The UTXO DAG models the relationship between transactions, by tracking which outputs have been spent by what transaction, see also the section on [UTXO](5.1%20UTXO.md). Since outputs can only be spent once, we use this property to detect double spends. 

Instead of permitting immediately only one transaction into to the ledger state, we allow for different versions of the ledger to coexist temporarily. 
This is enabled by extending the UTXO DAG by the introduction of branches, see the following section. We can then determine which conflicting versions of the ledger state exist in the presence of conflicts.

### 5.2.2.1 Conflict sets and detection of double spends

We maintain a list of consumers `consumerList` associated with every output, that keeps track of which transactions have spent that particular output. Outputs without consumers are considered to be unspent outputs. Transactions that consume an output that have more than one consumer are considered to be double spends. 

If there is more than one consumer in the consumer list we *shall* create a conflict set list `conflictSet`, which is identical to the consumer list. The `conflictSet` is uniquely identified by the unique identifier `conflictSetID`. Since the `outputID` is directly and uniquely linked to the conflict set, we set `conflictSetID=outputID`.

## 5.2.3 Branches

The UTXO model and the concept of solidification of messages, see section [solidification ????](), makes all non-conflicting transactions converge to the same ledger state no matter in which order the transactions are received. Messages containing these transactions could always reference each other in the Tangle without limitations.

However, every double spend creates a new possible version of the ledger state that will no longer converge. Whenever a double spend is detected, see the previous section, we track the outputs created by the conflicting transactions and all of the transactions that spend these outputs, by creating a container for them in the ledger which we call a branch. 

More specifically a container `branch` *shall* be created for each transaction that double spends one or several outputs. Every transaction that spends from a transaction in a given `branch`, i.e. is in the future cone in the UTXO DAG of the double-spending transaction that created `branch`, is also contained in this `branch`.
A branch that was created by a transaction that spends multiple outputs can be part of multiple conflict sets.


### 5.2.3.1 Creation, inheritance and merging of branches 

Every conflict branch *shall* be identified by the unique identifier `branchID`. Since a given branch is created by a corresponding double spend transaction and since the transaction identifier is unique, we choose the transaction id `transactionID` of the double spending transaction as the `branchID`.

Outputs inside a branch can be double spent again, recursively forming sub-branches. 

??? how is the inheritance done ?

??? how can be merged ?

??? how to clean up ?

??? approval switch related interdependencies ?

On solidification of a message, we *shall* store the corresponding branch identifier together with every output, as well as the transaction metadata to enable instant lookups of this information. Thus, on solidification, a transaction can be immediately associated with a branch. 

### 5.2.3.2 The branch DAG

A new branch is created for each transaction that is part of a conflict set. 

In the branch DAG, branches constitute the vertices of the DAG. A branch that is created by a transaction that is spending outputs from other branches has edges pointing to those branches.
The branch DAG maps the UTXO DAG to a simpler structure that ignores details about correlations of transactions inside the branches, and instead retains only details about the interrelations of conflicts.

The set of all non-conflicting transactions form the master branch. Thus, at its root the branch DAG has the master branch, which consists of non-conflicting transaction and resolved transactions. From this root of the branch DAG the various branches emerge. 


??? is the statement about resolved transactions true ?

In other words the conflict branches and the aggregated branches appear as the children of the master branch. 

??? Are branches that are confirmed by consensus merged back into Master or into their parent branches ? Are the conflicting branches now deleted?
---> We haven't implemented that yet but yes every confirmed branch should be merged back into master.

? non-conflicting and confirmed, or how are they merged back into master ? 

??? How are Branches merged back into the master branch. ?

### 5.2.3.4 Aggregation of branches

A transaction that does not create a double spend inherits the branches of the input's branches. In the simplest case, where there is only one input branch the transaction inherits that branch. 

If outputs from multiple non-conflicting branches are spent in the same transaction, then the transaction and its resulting outputs are part of an aggregated branch. This type of branch is not part of any conflict set. Rather it simply combines the perception that the individual conflict branches associated to the transaction's inputs are the ones that will be accepted by the network.

To calculate the unique identifier of a new aggregated branch `aggregatedBranchID`, we take the identifiers of the branches that were aggregated, sort them lexicographically and hash the concatenated identifiers once:

```golang
// AggregatedBranchID returns the identifier for an aggregated branch.
func AggregatedBranchID(branchIDs ...BranchID) BranchID {
    return Hash(SortBranchIDS(branchIDS...)...)
}
```

<!-- Aggregated branches have no further branches as their children and are simply an entity that allows us to encapsulate the opinion about multiple pending conflicts at the same time (as expressed by the corresponding transaction).  -->

Note that an `aggregatedBranchID` is always created from the original referenced `branchID`, rather than any direct referenced `aggregatedBranchID`. Thus aggregated branches have no further branches as their children and they remain tips in the branch DAG.

This property allows for an efficient reduction of a set of branches. The following function takes a list of conflict and aggregated branches and returns a unique set of conflict branches that these branches represent. This is done by replacing duplicates and extracting the parent conflict branches from aggregated branches.

```golang
func ConflictBranches(branches ...*Branch) map[BranchID]*Branch {
    result := make(map[BranchID]*Branch)
    for _, branch := range branches {
        if branch.IsConflictBranch() {
            result[branch.ID()] = branch

            continue
        }

        for _, parentBranch := range branch.ParentBranches() {
            result[parentBranch.ID()] = parentBranch
        }
    }

    return result
}
```


<!-- A conflicting transaction that spends funds from aggregated branches will create again an aggregated branch. However, the new `aggregatedBranchID` is created from the `branchID`s rather than from the `aggregatedBranchID`, that directly references the conflict branches it relies on.  -->

### 5.2.3.3 Detecting conflicting branches

Branches are conflicting if they, or any of their ancestors, are part of the same conflict set.

The branch DAG can be used to check if branches are conflicting, by applying an operation called normalization, to a set of input branches.

??? How is this done in detail ?

From this information we can identify messages or transactions that are trying to combine branches belonging to conflicting double spends, and thus introduce an invalid perception of the ledger state.


Since branches represent the ledger state associated with a double spend and sub-branches implicitly share the perception of their parents, we define an operation to normalize a list of branches that gets rid of all superfluous ancestors from a given list of branches. The function returns an error if the branches are conflicting and can not be merged.

```golang
traversedBranches := set.New()
seenConflictSets := set.New()
parentsToCheck := stack.New()


func checkConflictsAndQueueParents(currentBranch *Branch) problemconflictSetID {
        if !traversedBranches.Add(currentBranch.ID()) {
            return nil
            }
        
        // each branch is linked to a set of conflictSetIDs
        for conflictSetID := range currentBranch.Conflicts() {
            // if the conflictSetID is not yet seen the branch is not directly conflicting
            if !seenConflictSets.Add(conflictSetID) {
                return conflictSetID // branches conflicting
            }
        }

        for parentBranch := range currentBranch.ParentBranches() {
            parentsToCheck.Push(parentBranch)
        }

        return nil
    }


// NormalizeBranches checks if the branches are conflicting and removes superfluous ancestors.
func NormalizeBranches(branches ...*Branch) (map[BranchID]*Branch, problemconflictSetID) {
    // get unique set of conflict branches
    conflictBranches := ConflictBranches(branches...)
    if len(conflictBranches) == 1 {
        return conflictBranches, nil
    } else if len(conflictBranches) == 0 {
        return map[BranchID]*Branch{MasterBranchID: MasterBranch}, nil
    }

    // loop through initial conflict branch list and push parent branches to normalizedBranches
    normalizedBranches := make(map[BranchID]*Branch)
    for conflictBranchID, conflictBranch := range conflictBranches {
        normalizedBranches[conflictBranchID] = conflictBranch

        if err := checkConflictsAndQueueParents(conflictBranch); err != nil {
            return nil, err
        }
    }

    // 
    for !parentsToCheck.IsEmpty() {
        parentBranch := parentsToCheck.Pop().(*Branch)

        delete(normalizedBranches, parentBranch.ID())

        problemconflictSetID := checkConflictsAndQueueParents(parentBranch)
        if problemconflictSetID != nil {
            return nil,problemconflictSetID
        }
    }

    return normalizedBranches, nil
}
```



## 5.2.4 Approval weight propagation

A message inherits the branches of its parents. Thus, every message references every branch in its past cone.

Thus, by attaching to certain messages the node issuing node is effectively also attaching to certain branches. This can be utilized to efficiently make their opinions public about which parts of the Tangle they consider to be valid, see also [tip selection ???](). 

We build on this by associating the latest issued message of a given node with some approval weight that is tied to the consensus mana of that node. Furthermore, this allows for certain properties, such that the [approval weight???]() of a message can be propagated monotonically towards its indirectly referenced messages. 

Individual nodes can only add their approval weight to branches which they consider to be the correct branch. However, it would then be possible that messages cannot gain approval weight if they attach to the wrong part of the Tangle. To overcome this limitation, we introduce the concept of weak reference, with which the approval weight is only assigned to the referenced message and thus the branch of that message itself, see section [approval switch???]().


# 5.2.5 Example 1

The following diagram shows an example of a UTXO DAG with several conflicts and their corresponding branches:


<!-- This DAG looks pretty complex, but it is an emergent complexity and the rules that create it are relatively simple. -->


# 5.2.6 Example 2

The branch DAG of the previous example looks like this:


*Note: We only need to keep information about branches that are still pending or not too old. If a branch has been confirmed then all of its outputs and transactions can be merged back into the master branch and the rejected branches can be discarded. This mechanism will keep the branch DAG relatively shallow and the algorithms efficient.*

# Algorithms

In the following section we will introduce some of the most important algorithms that are required to maintain the UTXO DAG, the branch DAG and the Tangle.



## Inheriting branches of transactions

To be able to associate transactions and their outputs to a particular branch on solidification we introduce a method that allows them to inherit the branches of their consumed inputs according to the previously described rules. 

```golang
func InheritBranchOfTransaction(tx *Transaction) *Branch, error) {
    consumedBranches := make([]*Branch, 0)
    for _, outputID := range tx.Inputs() {
        consumedBranches = append(consumedBranches, utxoDAG.Output(outputID).Branch())
    }

    normalizedBranches, err := NormalizeBranches(consumedBranches...)
    if err != nil {
        return
    }
    normalizedBranchIDs := make([]BranchID, 0)
    for branchID := range normalizedBranches {
        normalizedBranchIDs = append(normalizedBranchIDs, branchID)
    }

    conflictingInputs := tx.ConflictingInputs()
    if len(conflictingInputs) != 0 {
        return CreateConflictBranch(tx.ID(), normalizedBranchIDs..., conflictingInputs...), nil
    }

    if len(normalizedBranchIDs) == 1 {
        return GetBranch(normalizedBranchIDs[0]), nil
    }

    aggregatedBranchID := AggregatedBranchID(normalizedBranchIDs...)
    if aggregatedBranch := GetBranch(aggregatedBranchID); aggregatedBranch != nil {
        return aggregatedBranch, nil
    }

    return CreateAggregatedBranch(aggregatedBranchID, normalizedBranchIDs...)
}
```