# 5.2 Ledger State

The introduction of a voting-based consensus requires a fast and easy way to determine a node's initial opinion for every received transaction. This includes the ability to both detect double spends and transactions that try to spend non-existing funds. 
These conditions are fulfilled by the introduction of an Unspent Transaction Output (UTXO) model for record-keeping, which enables the validation of transactions in real time, see also the section on [UTXO](5.1%20UTXO.md).

The concept of UTXO style transactions is directly linked to the creation of a directed acyclic graph (DAG), in which the vertices are transactions and the links between these are determined by the outputs and inputs of transactions, see also the section on [UTXO](5.1%20UTXO.md). 

To deal with double spends and leverage on certain properties of UTXO, we introduce the Realities Ledger State. 

## 5.2.1 Realities Ledger State 

In the Realities Ledger State, we model the different perceptions of the ledger state that exist in the Tangle. In each “reality” on its own there are zero conflicting transactions. 
Each reality thus forms an in itself consistent UTXO sub-DAG, where every transaction can reference any other transaction.

Since outputs of transactions can only be consumed once, a transaction that double spends outputs creates a persistent branch in a corresponding UTXO DAG, and each branch receives a unique identifier `branchID`. These branches cannot be merged by any vertices (transactions). A transaction that attempts to merge incompatible branches fails to pass a validity check and is rejected. 

The composition of all realities defines the Realities Ledger State. 

From this composition nodes are able to know which possible outcomes for the Tangle exist, where they split, how they relate to each other, if they can be merged and which messages are valid tips. All of this information can be retrieved in a fast and efficient way without having to walk the Tangle. 

? Above it is mentioned that branches can be merged, but a few lines above the opposite is said. ?

Eventually, for a set of competing realities, only one reality can survive. It is then up to the consensus protocol to determine which branch is part of the correct or final reality.
?what happens to the conflicting realities when this is determined. Are they discarded?

In total the ledger state thus involves three different layers - the UTXO DAG, its extension to the corresponding branch DAG and the Tangle which projects the information from the UTXO layer onto the messages.

## 5.2.2 The UTXO DAG

The UTXO DAG models the relationship between transactions, by tracking which outputs have been spent by what transaction. Since outputs can only be spent once, we use this property to detect double spends. 

Instead of permitting immediately only one transaction into to the ledger state, we allow for different versions of the ledger to coexist temporarily. 
This is enabled by extending the UTXO DAG by the introduction of branches, see following section. We can then determine which conflicting versions of the ledger state exist in the presence of conflicts.

### 5.2.2.1 Conflict sets and detection of double spends

We maintain a list of consumers associated with every output, that keeps track of which transactions have spent that particular output. Outputs without consumers are considered to be unspent outputs. Transactions that consume an output that have more than one consumer are considered to be double spends.

? Is this consumer list the conflict set ?

<!-- Branches that were created by double spending transactions, i.e. spending the same output form a conflict set.  -->
Every conflict set is identified by the identifier of the output that was spent multiple times. A branch that was created by a transaction that spends multiple outputs can be part of multiple conflict sets.
? This is confusing. Above it states that the conflict set forms a branch but now several branches are forming a conflict set - which of the both ?


## 5.2.3 Branches and the branch DAG


### 5.2.3.1 Branches

The UTXO model and the concept of solidification of messages, see section [solidification ????](), makes all non-conflicting transactions converge to the same ledger state no matter in which order the transactions are received. Messages containing these transactions could always reference each other in the Tangle without limitations.

However, every double spend creates a new possible version of the ledger state that will no longer converge. Whenever a double spend is detected, we track the outputs created by the conflicting transactions and all of the transactions that spend these outputs separated from the rest by creating a container for them in the ledger which we call a conflict branch. 
? This is unclear - is it one conflict branch or several branches in the container ?
Every conflict set is identified by the identifier of the output that was spent multiple times. A branch that was created by a transaction that spends multiple outputs can be part of multiple conflict sets.

<!-- Branches that were created by double spending transactions are, i.e. they are spending the same output form a conflict set.  -->

Every conflict branch is identified by the unique identifier of the double spending transaction `transactionID`. Outputs inside a branch can be double spent again, recursively forming sub-branches.
? This contradicts how the containers work , is the statement about transactionID wrong ?

### 5.2.3.2 Creation of branches 

The `branchID` of a new branch is assigned according to the following rules:

Since the transaction ID is unique, we choose the transaction id `transactionID` of the double spending transaction as the `branchID`.
? I dont think this is correct, but what is correct? ?

* how it's inherited
* how can be merged
* how can be absorbed by the master branch
* how to clean up
* approval switch related interdependencies

<!-- * Branches (Ledger state) -->
<!-- * each output and transaction have an associated branch ID -->

On solidification, we *shall* store the corresponding branch identifier together with every output and the transaction metadata to enable instant lookups of this information.
Thus a transaction can be associated with a branch on solidification. 
<!-- The algorithms that are required to calculate to which branch a transaction and its outputs belong are defined in a later section.  -->

### 5.2.3.2 The branch DAG

A new branch is created for each transaction that is part of a double spend set. 

In the branch DAG, branches constitute the vertices of the DAG. A branch that is created by a transaction spending outputs from other branches has edges pointing to those branches.
The branch DAG maps the UTXO DAG to a simpler structure that ignores details about correlations of transactions inside the branches, and instead retains only details about the interrelations of conflicts.

At its root the branch DAG has the master branch, which consists of non-conflicting transaction and resolved transactions. From this root of the branch DAG the various branches emerge.
? is the statement about resolved transactions true ?
In other words the conflict branches and the aggregated branches appear as the children of the master branch. 

### 5.2.3.3 Detecting conflicting branches

The branch DAG can be used to check if branches are conflicting, which in turn can be used to identify messages or transactions that are trying to introduce an invalid perception of the ledger state by combining branches belonging to conflicting double spends.

Branches are conflicting if they or any of their ancestors are part of the same conflict set.

### 5.2.3.4 Aggregation of branches

A transaction that does not create a double spend inherits the branches of the input's branches. In the simplest case, where there is only one input branch the transaction inherits that branch. 

If outputs from multiple non-conflicting branches are spent in the same transaction, then the transaction and its resulting outputs are part of an aggregated branch. This type of branch is not part of any conflict set. Rather it simply combines the perception that the individual conflict branches associated to the transaction's inputs are the ones that will be accepted by the network.

To calculate the unique identifier of a new aggregated branch `aggregatedBranchID`, we take the identifiers of the branches that were aggregated, sort them lexicographically and hash the concatenated identifiers once:

```golang
// AggregatedBranchID returns the identifier for an aggregated branch.
func AggregatedBranchID(branchIDs ...BranchID) BranchID {
    return Hash(SortBranchIDS(branchIDS...)...)
}
```

<!-- Aggregated branches have no further branches as their children and are simply an entity that allows us to encapsulate the opinion about multiple pending conflicts at the same time (as expressed by the corresponding transaction).  -->

Note that an `aggregatedBranchID` is always created from the original referenced `branchID`, rather than any direct referenced `aggregatedBranchID`. Thus aggregated branches have no further branches as their children, but rather a new aggregated tip of the branch DAG is created. ???

<!-- A conflicting transaction that spends funds from aggregated branches will create again an aggregated branch. However, the new `aggregatedBranchID` is created from the `branchID`s rather than from the `aggregatedBranchID`, that directly references the conflict branches it relies on.  -->

### 5.2.3.5 Merging to the Master branch

The set of all non-conflicting transactions form the master branch.

? non-conflicting and confirmed, or how are they merged back into master ? 

??? How are Branches merged back into the master branch. ?


## 5.2.4 Approval weight propagation

We apply the rule that a message inherits the branches of its parents.
Thus, by attaching to certain messages the node is effectively also attaching to certain branches. This can be utilised to effectively make their opinions public about which parts of the Tangle they consider to be valid, see also [tip selection ???](). 

We build on this by associating the latest issued message of a given node with some approval weight that is tied to the consensus mana of that node. Furthermore, this allows for certain properties, such that the [approval weight???]() of a message can then be propagated monotonically towards its indirectly referenced messages. 

Individual nodes can then only add their approval weight to branches which they consider to be the correct branch. However, it would then be possible that messages cannot gain approval weight if they attach to the wrong part of the Tangle. To overcome this limitation, we introduce the concept of weak reference, with which the approval weight is only assigned to the referenced message and thus the branch of that message itself, see section [approval switch???]().


#  ??

Entity that manages the conflicting perception of the ledger state

* Double spend definition
    * solidity, already spent and other properties are provided by the UTXO

* IDEA: link msgID and outputID -> this way you can request missing transactions easily (i.e., same as solidification) 




# 5.2.5 Example 1

The following diagram shows an example of a UTXO DAG with several conflicts and their corresponding branches:


<!-- This DAG looks pretty complex, but it is an emergent complexity and the rules that create it are relatively simple. -->


# 5.2.6 Example 2

The branch DAG of the previous example looks like this:


*Note: We only need to keep information about branches that are still pending or not too old. If a branch has been confirmed then all of its outputs and transactions can be merged back into the master branch and the rejected branches can be discarded. This mechanism will keep the branch DAG relatively shallow and the algorithms efficient.*

# Algorithms

In the following section we will introduce some of the most important algorithms that are required to maintain the UTXO DAG, the branch DAG and the Tangle.

##### Determine conflict branches from set of branches

The first algorithm we introduce is a utility function that takes a list of branches and returns a unique set of conflict branches that these branches represent (by getting rid of duplicates and by resolving aggregated branches).

```golang
// ConflictBranches returns a unique list of conflict branches that the given branches represent.
func ConflictBranches(branches ...*Branch) map[BranchID]*Branch {
    result := make(map[BranchID]*Branch)
    for _, branch := range branches {
        if branch.IsConflictBranch() {
            result[branch.ID()] = branch

            continue
        }

        for _, parentBranch := range branch.ParentBranches() {
            result[parentBranch.ID()] = parentBranch
        }
    }

    return result
}
```

##### Normalizing branches

Since branches represent the ledger state associated with a double spend and sub-branches implicitly share the perception of their parents, we define an operation to normalize a list of branches that gets rid of all superfluous ancestors from a given list of branches. The function returns an error if the branches are conflicting and can not be merged.

```golang
// NormalizeBranches checks if the branches are conflicting and removes superfluous ancestors.
func NormalizeBranches(branches ...*Branch) (map[BranchID]*Branch, error) {
    conflictBranches := branchManager.ConflictBranches(branches...)
    if len(conflictBranches) == 1 {
        return conflictBranches, nil
    } else if len(conflictBranches) == 0 {
        return map[BranchID]*Branch{MasterBranchID: MasterBranch}, nil
    }

    traversedBranches := set.New()
    seenConflictSets := set.New()
    parentsToCheck := stack.New()

    checkConflictsAndQueueParents := func(currentBranch *Branch) error {
        if !traversedBranches.Add(currentBranch.ID()) {
            return nil
            }

        for conflictSetID := range currentBranch.Conflicts() {
            if !seenConflictSets.Add(conflictSetID) {
                return errors.New("branches conflicting")
            }
        }

        for parentBranch := range currentBranch.ParentBranches() {
            parentsToCheck.Push(parentBranch)
        }

        return nil
    }

    normalizedBranches := make(map[BranchID]*Branch)
    for conflictBranchID, conflictBranch := range conflictBranches {
        normalizedBranches[conflictBranchID] = conflictBranch

        if err := checkConflictsAndQueueParents(conflictBranch); err != nil {
            return nil, err
        }
    }

    for !parentsToCheck.IsEmpty() {
        parentBranch := parentsToCheck.Pop().(*Branch)

        delete(normalizedBranches, parentBranch.ID())

        if err := checkConflictsAndQueueParents(parentBranch); err != nil {
            return nil, err
        }
    }

    return normalizedBranches, nil
}
```

##### Inheriting branches of transactions

To be able to associate transactions and their outputs to a particular branch on solidification we introduce a method that allows them to inherit the branches of their consumed inputs according to the previously described rules. 

```golang
func InheritBranchOfTransaction(tx *Transaction) *Branch, error) {
    consumedBranches := make([]*Branch, 0)
    for _, outputID := range tx.Inputs() {
        consumedBranches = append(consumedBranches, utxoDAG.Output(outputID).Branch())
    }

    normalizedBranches, err := NormalizeBranches(consumedBranches...)
    if err != nil {
        return
    }
    normalizedBranchIDs := make([]BranchID, 0)
    for branchID := range normalizedBranches {
        normalizedBranchIDs = append(normalizedBranchIDs, branchID)
    }

    conflictingInputs := tx.ConflictingInputs()
    if len(conflictingInputs) != 0 {
        return CreateConflictBranch(tx.ID(), normalizedBranchIDs..., conflictingInputs...), nil
    }

    if len(normalizedBranchIDs) == 1 {
        return GetBranch(normalizedBranchIDs[0]), nil
    }

    aggregatedBranchID := AggregatedBranchID(normalizedBranchIDs...)
    if aggregatedBranch := GetBranch(aggregatedBranchID); aggregatedBranch != nil {
        return aggregatedBranch, nil
    }

    return CreateAggregatedBranch(aggregatedBranchID, normalizedBranchIDs...)
}
```