# 6.1 Objects of Consensus

## 6.1.1 Summary

FPC is a binary voting protocol: it takes an initial boolean value and outputs a final boolean value. The opinion changes through a series of queries. 

This note describes how this binary voting protocol interacts with the rest of the IOTA protocol.  Specifically, we define two functions, `QueryStatus` and `AnswerStatus` which govern when an object should be included in  a query or a response.

## 6.1.2 Motivation

The FPC module can vote on many different questions, however it itself is agnostic to the rest of the protocol.  Every node has to vote on timestamps and conflicts, however anyone can create other applications which use FPC.

We want a generic way for FPC to interact with data structures in other applications. Specifically, an application needs a way to determine when to have FPC run. For instance, it is not efficient to vote on every object of a particular type.  Moreover, we do not want FPC to vote on an object multiple times.  

Voting is a two-part process: querying and answering queries.  The function `QueryStatus` determines if a node should query about a particular object, and the function `AnswerStatus` determines if the node should respond.  

## 6.1.3 Detailed design
### 6.1.3.1 Parameters and lists
| Name | Type |Description |
| -----| ------ | ----------- |
|`DSMALL` | integer | small estimated network delay ~5 seconds| 
| `votingEnabledObjectTypes` | list | object types which will be voted upon|

## 6.1.3.2 Voting Objects list

FPC can potentially vote on a variety of matters.  The `votingEnabledObjectTypes` effectively lists which things will be voted upon by listing the object types which must be queried by FPC.  Specifically, when FPC prepares a querry, it iterates through each object type, and then finds which objects of that type it must include in the querry.  

By default, the object types `message` and `transaction` are in the list `votingEnabledObjectTypes`.  However, a second layer application can add other object types to this list, allowing other applications to use FPC. These applications will have no guarantee that they will receive responces with about custom object types, particularly if the application is not widly used.   

### 6.1.3.3 How opinions on objects are stored

For every object whose type is in `votingEnabledObjectTypes`, that the local meta dated stored with the object must include an `opinionField` which is either `NULL`  or the triplet `(opinion,level,timeFormed)`.  The field `opinion` is a Boolean value,  `level` is a number in the list $\{1,2,3\}$, and `timeFormed` is the time the field was changed from `NULL`.

As will be discussed in a different specification, an opinion field will be  `NULL` until the node has received information allowing it to form an opinion, e.g. detect a conflict.  For example,  a transaction should have opinion field  `NULL` until a conflict is detected.  Such transactions should be considered "good", and, in the honest setting, most transactions will have a `Null` opinion. 

### 6.1.3.4 Query Status

When FPC prepares a query, see the [FPC](link) specification, it must determine which objects to include include.  Conceptually, for each type in `votingEnabledObjectTypes`, the node must iterate through all objects of that type and individual decide if that object is to be included in the query. Clearly, this iteration would be inefficient expensive, and a node can use some method to speed up the process.  However, this is an implementation detail and thus beyond the scope of this document.

When FPC stops voting on an object, it sets the `opinion` to the  final opinion and modifies `level` so that `QuerryStatus` returns false.

To determine whether or not each object should be included into a query, a node applies the following `QueryStatus` function.  If the function returns true, then the object should be included into the query.
```
vbnet
FUNCTION Bool=QueryStatus(type,objectID)
IF type not in VotingEnabledObjectTypes
    RETURN FALSE
ELSEIF opinionField not= NULL AND level=1 and currentTime>timeFormed+DSMALL
    RETURN TRUE
ELSE RETURN FALSE      
```
Lastly, if the object does not exist, the function should return `FALSE`.
### 6.1.3.5 Answer Status

Every time FPC receives a query, it checks whether or not it should reply; see [FPC](Link).  To do so, it applies the following  `AnswerStatus` function that object to determine if a response should be made.

```
vbnet
FUNCTION Bool=AnswerStatus(type,objectID)
If type not in VotingEnabledObjectTypes
    RETURN FALSE
ELSE IF opinionField not=NULL AND (level=1 OR level=2) 
    RETURN TRUE
ELSE RETURN FALSE 
```
Lastly, if the object does not exist, the function should return `FALSE`.
# 6.1.4 Rationale and Alternatives

The `level` field indicates the level of knowledge. It tells us information about what other nodes know.
* Level 1 means that I only know that I hold this opinion.
* Level 2 means that I know that everyone else has this opinion too (with high probability).
* Level 3 means that I know that everyone has level 2 knowledge.

If a node node only has level 1 knowledge, it needs to vote.  However, if it has level 2 knowledge, it does not need to query as it knows that all nodes have the same opinion. With level 3 knowledge, it knows that no other nodes have level 2 knowledge and thus should not send its node queries.  Thus, with level 3 knowlege, the node does not need to respond. The level of knowledge is the primary criterion in these functions.  

Moreover, we should not query about objects whose opinion is `NULL`. In a similar vein, we need should not query about an object unill `d` time after the opinion was set, so we can be sure that all other nodes have set their opinion too. 

Alternatively, we can attempt to manage the same system with a series of finality flags.  However, this has two problems.  First,  we either mark objects which we have never voted upon as final, or some objects will never get a finality flag.  This leads to some complicated, unintuitive logic. 
Second, if an attacker can cause only small portions of the network to vote on an object, that vote would be susceptible to an attack.  Thus we need consensus about what to vote on. However, if voting is a binary "yes" or "no", we would need a consesus algorithm to determine when to vote.  The levels of knowlege does not treat voting in a binary way, bypassing this problem.  
